!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACLOCAL	Makefile	/^ACLOCAL = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run aclocal-1.12$/;"	m
ACLOCAL	include/Makefile	/^ACLOCAL = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run aclocal-1.12$/;"	m
ACLOCAL	sample/Makefile	/^ACLOCAL = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run aclocal-1.12$/;"	m
ACLOCAL	test/Makefile	/^ACLOCAL = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run aclocal-1.12$/;"	m
ACLOCAL_AMFLAGS	Makefile	/^ACLOCAL_AMFLAGS = -I m4$/;"	m
ACLOCAL_M4	Makefile	/^ACLOCAL_M4 = $(top_srcdir)\/aclocal.m4$/;"	m
ACLOCAL_M4	include/Makefile	/^ACLOCAL_M4 = $(top_srcdir)\/aclocal.m4$/;"	m
ACLOCAL_M4	sample/Makefile	/^ACLOCAL_M4 = $(top_srcdir)\/aclocal.m4$/;"	m
ACLOCAL_M4	test/Makefile	/^ACLOCAL_M4 = $(top_srcdir)\/aclocal.m4$/;"	m
ADD_ENTROPY	arc4random.c	71;"	d	file:
ADD_UDATA	kqueue.c	174;"	d	file:
AF_INET6	ipv6-internal.h	71;"	d
ALL_DATA_READ	http-internal.h	/^	ALL_DATA_READ = 1,$/;"	e	enum:message_read_status
ALL_NATIVE_AI_FLAGS	evutil.c	/^static const unsigned int ALL_NATIVE_AI_FLAGS =$/;"	v	file:
ALL_NONNATIVE_AI_FLAGS	evutil.c	/^static const unsigned int ALL_NONNATIVE_AI_FLAGS =$/;"	v	file:
AMTAR	Makefile	/^AMTAR = $${TAR-tar}$/;"	m
AMTAR	include/Makefile	/^AMTAR = $${TAR-tar}$/;"	m
AMTAR	sample/Makefile	/^AMTAR = $${TAR-tar}$/;"	m
AMTAR	test/Makefile	/^AMTAR = $${TAR-tar}$/;"	m
AM_CPPFLAGS	Makefile	/^AM_CPPFLAGS = -I$(srcdir)\/compat -I$(srcdir)\/include -I.\/include $(SYS_INCLUDES)$/;"	m
AM_CPPFLAGS	sample/Makefile	/^AM_CPPFLAGS = -I$(top_srcdir) -I$(top_srcdir)\/compat -I$(top_srcdir)\/include -I..\/include$/;"	m
AM_CPPFLAGS	test/Makefile	/^AM_CPPFLAGS = -I$(top_srcdir) -I$(top_srcdir)\/compat -I$(top_srcdir)\/include -I..\/include -DTINYTEST_LOCAL$/;"	m
AM_RECURSIVE_TARGETS	Makefile	/^AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\$/;"	m
APPEND16	evdns.c	1593;"	d	file:
APPEND16	evdns.c	2141;"	d	file:
APPEND32	evdns.c	1600;"	d	file:
APPEND32	evdns.c	2142;"	d	file:
APPEND_CHAIN	buffer.c	/^APPEND_CHAIN(struct evbuffer *dst, struct evbuffer *src)$/;"	f	file:	signature:(struct evbuffer *dst, struct evbuffer *src)
AR	Makefile	/^AR = ar$/;"	m
AR	include/Makefile	/^AR = ar$/;"	m
AR	sample/Makefile	/^AR = ar$/;"	m
AR	test/Makefile	/^AR = ar$/;"	m
ARC4RANDOM_EXPORT	arc4random.c	45;"	d	file:
ARC4RANDOM_EXPORT	evutil_rand.c	113;"	d	file:
ARC4RANDOM_NORANDOM	evutil_rand.c	122;"	d	file:
ARC4RANDOM_NOSTIR	evutil_rand.c	121;"	d	file:
ARC4RANDOM_NOUNIFORM	evutil_rand.c	123;"	d	file:
ARC4RANDOM_UINT32	arc4random.c	49;"	d	file:
ARC4RANDOM_UINT32	evutil_rand.c	120;"	d	file:
ASSERT_EVBUFFER_LOCKED	evbuffer-internal.h	229;"	d
ASSERT_LOCKED	evdns.c	417;"	d	file:
ASSERT_LOCKED	evdns.c	423;"	d	file:
ASSERT_VALID_REQUEST	evdns.c	133;"	d	file:
AUTOCONF	Makefile	/^AUTOCONF = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run autoconf$/;"	m
AUTOCONF	include/Makefile	/^AUTOCONF = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run autoconf$/;"	m
AUTOCONF	sample/Makefile	/^AUTOCONF = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run autoconf$/;"	m
AUTOCONF	test/Makefile	/^AUTOCONF = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run autoconf$/;"	m
AUTOHEADER	Makefile	/^AUTOHEADER = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run autoheader$/;"	m
AUTOHEADER	include/Makefile	/^AUTOHEADER = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run autoheader$/;"	m
AUTOHEADER	sample/Makefile	/^AUTOHEADER = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run autoheader$/;"	m
AUTOHEADER	test/Makefile	/^AUTOHEADER = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run autoheader$/;"	m
AUTOMAKE	Makefile	/^AUTOMAKE = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run automake-1.12$/;"	m
AUTOMAKE	include/Makefile	/^AUTOMAKE = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run automake-1.12$/;"	m
AUTOMAKE	sample/Makefile	/^AUTOMAKE = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run automake-1.12$/;"	m
AUTOMAKE	test/Makefile	/^AUTOMAKE = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run automake-1.12$/;"	m
AUTOMAKE_OPTIONS	Makefile	/^AUTOMAKE_OPTIONS = foreign 1.7$/;"	m
AUTOMAKE_OPTIONS	include/Makefile	/^AUTOMAKE_OPTIONS = foreign$/;"	m
AUTOMAKE_OPTIONS	sample/Makefile	/^AUTOMAKE_OPTIONS = foreign no-dependencies$/;"	m
AUTOMAKE_OPTIONS	test/Makefile	/^AUTOMAKE_OPTIONS = foreign$/;"	m
AWK	Makefile	/^AWK = gawk$/;"	m
AWK	include/Makefile	/^AWK = gawk$/;"	m
AWK	sample/Makefile	/^AWK = gawk$/;"	m
AWK	test/Makefile	/^AWK = gawk$/;"	m
AcceptEx	iocp-internal.h	/^	AcceptExPtr AcceptEx;$/;"	m	struct:win32_extension_fns	access:public
AcceptExPtr	iocp-internal.h	/^typedef BOOL (WINAPI *AcceptExPtr)(SOCKET, SOCKET, PVOID, DWORD, DWORD, DWORD, LPDWORD, LPOVERLAPPED);$/;"	t
AddDeclaration	event_rpcgen.py	/^    def AddDeclaration(self, funcname):$/;"	m	class:EntryArray	access:public
AddEntry	event_rpcgen.py	/^    def AddEntry(self, entry):$/;"	m	class:Struct	access:public
AddFuncName	event_rpcgen.py	/^    def AddFuncName(self):$/;"	m	class:Entry	access:public
Array	event_rpcgen.py	/^    def Array(self):$/;"	m	class:Entry	access:public
AssignDeclaration	event_rpcgen.py	/^    def AssignDeclaration(self, funcname):$/;"	m	class:Entry	access:public
AssignDeclaration	event_rpcgen.py	/^    def AssignDeclaration(self, funcname):$/;"	m	class:EntryArray	access:public
AssignDeclaration	event_rpcgen.py	/^    def AssignDeclaration(self, funcname):$/;"	m	class:EntryBytes	access:public
AssignDeclaration	event_rpcgen.py	/^    def AssignDeclaration(self, funcname):$/;"	m	class:EntryVarBytes	access:public
AssignFuncName	event_rpcgen.py	/^    def AssignFuncName(self):$/;"	m	class:Entry	access:public
BAD	test/regress_http.c	2014;"	d	file:
BAD	test/regress_http.c	2370;"	d	file:
BAD	test/regress_util.c	/^enum entry_status { NORMAL, CANONICAL, BAD };$/;"	e	enum:entry_status	file:
BASIC	test/regress.h	95;"	d
BASIC_REQUEST_BODY	test/regress_http.c	/^static char const BASIC_REQUEST_BODY[] = "This is funny";$/;"	v	file:
BEV_CTRL_CANCEL_ALL	bufferevent-internal.h	/^	BEV_CTRL_CANCEL_ALL$/;"	e	enum:bufferevent_ctrl_op
BEV_CTRL_GET_FD	bufferevent-internal.h	/^	BEV_CTRL_GET_FD,$/;"	e	enum:bufferevent_ctrl_op
BEV_CTRL_GET_UNDERLYING	bufferevent-internal.h	/^	BEV_CTRL_GET_UNDERLYING,$/;"	e	enum:bufferevent_ctrl_op
BEV_CTRL_SET_FD	bufferevent-internal.h	/^	BEV_CTRL_SET_FD,$/;"	e	enum:bufferevent_ctrl_op
BEV_DEL_GENERIC_READ_TIMEOUT	bufferevent-internal.h	368;"	d
BEV_DEL_GENERIC_WRITE_TIMEOUT	bufferevent-internal.h	370;"	d
BEV_ERROR	include/event2/bufferevent.h	/^	BEV_ERROR = 2$/;"	e	enum:bufferevent_filter_result
BEV_EVENT_CONNECTED	include/event2/bufferevent.h	103;"	d
BEV_EVENT_EOF	include/event2/bufferevent.h	100;"	d
BEV_EVENT_ERROR	include/event2/bufferevent.h	101;"	d
BEV_EVENT_READING	include/event2/bufferevent.h	98;"	d
BEV_EVENT_TIMEOUT	include/event2/bufferevent.h	102;"	d
BEV_EVENT_WRITING	include/event2/bufferevent.h	99;"	d
BEV_FINISHED	include/event2/bufferevent.h	/^	BEV_FINISHED = 2$/;"	e	enum:bufferevent_flush_mode
BEV_FLUSH	include/event2/bufferevent.h	/^	BEV_FLUSH = 1,$/;"	e	enum:bufferevent_flush_mode
BEV_IS_ASYNC	bufferevent-internal.h	267;"	d
BEV_IS_ASYNC	bufferevent-internal.h	269;"	d
BEV_IS_FILTER	bufferevent-internal.h	262;"	d
BEV_IS_PAIR	bufferevent-internal.h	263;"	d
BEV_IS_SOCKET	bufferevent-internal.h	261;"	d
BEV_LOCK	bufferevent-internal.h	379;"	d
BEV_LOCK	bufferevent-internal.h	383;"	d
BEV_NEED_MORE	include/event2/bufferevent.h	/^	BEV_NEED_MORE = 1,$/;"	e	enum:bufferevent_filter_result
BEV_NORMAL	include/event2/bufferevent.h	/^	BEV_NORMAL = 0,$/;"	e	enum:bufferevent_flush_mode
BEV_OK	include/event2/bufferevent.h	/^	BEV_OK = 0,$/;"	e	enum:bufferevent_filter_result
BEV_OPT_CLOSE_ON_FREE	include/event2/bufferevent.h	/^	BEV_OPT_CLOSE_ON_FREE = (1<<0),$/;"	e	enum:bufferevent_options
BEV_OPT_DEFER_CALLBACKS	include/event2/bufferevent.h	/^	BEV_OPT_DEFER_CALLBACKS = (1<<2),$/;"	e	enum:bufferevent_options
BEV_OPT_THREADSAFE	include/event2/bufferevent.h	/^	BEV_OPT_THREADSAFE = (1<<1),$/;"	e	enum:bufferevent_options
BEV_OPT_UNLOCK_CALLBACKS	include/event2/bufferevent.h	/^	BEV_OPT_UNLOCK_CALLBACKS = (1<<3)$/;"	e	enum:bufferevent_options
BEV_RESET_GENERIC_READ_TIMEOUT	bufferevent-internal.h	356;"	d
BEV_RESET_GENERIC_WRITE_TIMEOUT	bufferevent-internal.h	363;"	d
BEV_SUSPEND_BW	bufferevent-internal.h	54;"	d
BEV_SUSPEND_BW_GROUP	bufferevent-internal.h	56;"	d
BEV_SUSPEND_FILT_READ	bufferevent-internal.h	62;"	d
BEV_SUSPEND_LOOKUP	bufferevent-internal.h	59;"	d
BEV_SUSPEND_WM	bufferevent-internal.h	52;"	d
BEV_UNLOCK	bufferevent-internal.h	380;"	d
BEV_UNLOCK	bufferevent-internal.h	389;"	d
BEV_UPCAST	bufferevent-internal.h	376;"	d
BIO_TYPE_LIBEVENT	bufferevent_openssl.c	79;"	d	file:
BIO_new_bufferevent	bufferevent_openssl.c	/^BIO_new_bufferevent(struct bufferevent *bufferevent, int close_flag)$/;"	f	file:	signature:(struct bufferevent *bufferevent, int close_flag)
BIO_s_bufferevent	bufferevent_openssl.c	/^BIO_s_bufferevent(void)$/;"	f	file:	signature:(void)
BUFFEREVENT_SSL_ACCEPTING	include/event2/bufferevent_ssl.h	/^	BUFFEREVENT_SSL_ACCEPTING = 2$/;"	e	enum:bufferevent_ssl_state
BUFFEREVENT_SSL_CONNECTING	include/event2/bufferevent_ssl.h	/^	BUFFEREVENT_SSL_CONNECTING = 1,$/;"	e	enum:bufferevent_ssl_state
BUFFEREVENT_SSL_OPEN	include/event2/bufferevent_ssl.h	/^	BUFFEREVENT_SSL_OPEN = 0,$/;"	e	enum:bufferevent_ssl_state
BUILT_SOURCES	Makefile	/^BUILT_SOURCES = include\/event2\/event-config.h$/;"	m
BUILT_SOURCES	test/Makefile	/^BUILT_SOURCES = $(am__append_2)$/;"	m
BYTES_BEFORE_RESEED	arc4random.c	74;"	d	file:
BodyPreamble	event_rpcgen.py	/^    def BodyPreamble(self, name, header_file):$/;"	m	class:CCodeGenerator	access:public
CANONICAL	test/regress_util.c	/^enum entry_status { NORMAL, CANONICAL, BAD };$/;"	e	enum:entry_status	file:
CAN_CHECK_ERR	test/regress_util.c	463;"	d	file:
CB_COUNT	test/regress_thread.c	403;"	d	file:
CC	Makefile	/^CC = gcc$/;"	m
CC	include/Makefile	/^CC = gcc$/;"	m
CC	sample/Makefile	/^CC = gcc$/;"	m
CC	test/Makefile	/^CC = gcc$/;"	m
CCDEPMODE	Makefile	/^CCDEPMODE = depmode=gcc3$/;"	m
CCDEPMODE	include/Makefile	/^CCDEPMODE = depmode=gcc3$/;"	m
CCDEPMODE	sample/Makefile	/^CCDEPMODE = depmode=gcc3$/;"	m
CCDEPMODE	test/Makefile	/^CCDEPMODE = depmode=gcc3$/;"	m
CCLD	Makefile	/^CCLD = $(CC)$/;"	m
CCLD	sample/Makefile	/^CCLD = $(CC)$/;"	m
CCLD	test/Makefile	/^CCLD = $(CC)$/;"	m
CCodeGenerator	event_rpcgen.py	/^class CCodeGenerator:$/;"	c	inherits:
CFLAGS	Makefile	/^CFLAGS = -g -O2 -Wall -fno-strict-aliasing $/;"	m
CFLAGS	include/Makefile	/^CFLAGS = -g -O2 -Wall -fno-strict-aliasing $/;"	m
CFLAGS	sample/Makefile	/^CFLAGS = -g -O2 -Wall -fno-strict-aliasing $/;"	m
CFLAGS	test/Makefile	/^CFLAGS = -g -O2 -Wall -fno-strict-aliasing $/;"	m
CHAIN_PINNED	buffer.c	135;"	d	file:
CHAIN_PINNED_R	buffer.c	136;"	d	file:
CHAIN_SPACE_LEN	buffer.c	132;"	d	file:
CHAIN_SPACE_PTR	buffer.c	131;"	d	file:
CHAR_IS_UNRESERVED	http.c	2666;"	d	file:
CHUNKS	test/regress_http.c	/^static char const* const CHUNKS[] = {$/;"	v	file:
CHUNK_SZ	buffer.c	1330;"	d	file:
CHUNK_SZ	buffer.c	1351;"	d	file:
CIRCLEQ_EMPTY	compat/sys/queue.h	401;"	d
CIRCLEQ_END	compat/sys/queue.h	398;"	d
CIRCLEQ_ENTRY	compat/sys/queue.h	387;"	d
CIRCLEQ_FIRST	compat/sys/queue.h	396;"	d
CIRCLEQ_FOREACH	compat/sys/queue.h	404;"	d
CIRCLEQ_FOREACH_REVERSE	compat/sys/queue.h	409;"	d
CIRCLEQ_HEAD	compat/sys/queue.h	378;"	d
CIRCLEQ_HEAD_INITIALIZER	compat/sys/queue.h	384;"	d
CIRCLEQ_INIT	compat/sys/queue.h	417;"	d
CIRCLEQ_INSERT_AFTER	compat/sys/queue.h	422;"	d
CIRCLEQ_INSERT_BEFORE	compat/sys/queue.h	432;"	d
CIRCLEQ_INSERT_HEAD	compat/sys/queue.h	442;"	d
CIRCLEQ_INSERT_TAIL	compat/sys/queue.h	452;"	d
CIRCLEQ_LAST	compat/sys/queue.h	397;"	d
CIRCLEQ_NEXT	compat/sys/queue.h	399;"	d
CIRCLEQ_PREV	compat/sys/queue.h	400;"	d
CIRCLEQ_REMOVE	compat/sys/queue.h	462;"	d
CIRCLEQ_REPLACE	compat/sys/queue.h	475;"	d
CLAMPTO	bufferevent_ratelim.c	212;"	d	file:
CLASS_INET	evdns.c	153;"	d	file:
CLEANFILES	test/Makefile	/^CLEANFILES = rpcgen-attempted$/;"	m
CLOCK_SYNC_INTERVAL	event.c	349;"	d	file:
COMMON_TIMEOUT_IDX	event.c	1098;"	d	file:
COMMON_TIMEOUT_IDX_MASK	event.c	1093;"	d	file:
COMMON_TIMEOUT_IDX_SHIFT	event.c	1094;"	d	file:
COMMON_TIMEOUT_MAGIC	event.c	1096;"	d	file:
COMMON_TIMEOUT_MASK	event.c	1095;"	d	file:
COMMON_TIMEOUT_MICROSECONDS_MASK	event-internal.h	150;"	d
COMPILE	Makefile	/^COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\$/;"	m
COMPILE	sample/Makefile	/^COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\$/;"	m
COMPILE	test/Makefile	/^COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\$/;"	m
CONFIG_CLEAN_FILES	Makefile	/^CONFIG_CLEAN_FILES = libevent.pc libevent_openssl.pc \\$/;"	m
CONFIG_CLEAN_FILES	include/Makefile	/^CONFIG_CLEAN_FILES =$/;"	m
CONFIG_CLEAN_FILES	sample/Makefile	/^CONFIG_CLEAN_FILES =$/;"	m
CONFIG_CLEAN_FILES	test/Makefile	/^CONFIG_CLEAN_FILES =$/;"	m
CONFIG_CLEAN_VPATH_FILES	Makefile	/^CONFIG_CLEAN_VPATH_FILES =$/;"	m
CONFIG_CLEAN_VPATH_FILES	include/Makefile	/^CONFIG_CLEAN_VPATH_FILES =$/;"	m
CONFIG_CLEAN_VPATH_FILES	sample/Makefile	/^CONFIG_CLEAN_VPATH_FILES =$/;"	m
CONFIG_CLEAN_VPATH_FILES	test/Makefile	/^CONFIG_CLEAN_VPATH_FILES =$/;"	m
CONFIG_HEADER	Makefile	/^CONFIG_HEADER = config.h$/;"	m
CONFIG_HEADER	include/Makefile	/^CONFIG_HEADER = $(top_builddir)\/config.h$/;"	m
CONFIG_HEADER	sample/Makefile	/^CONFIG_HEADER = $(top_builddir)\/config.h$/;"	m
CONFIG_HEADER	test/Makefile	/^CONFIG_HEADER = $(top_builddir)\/config.h$/;"	m
COPY_CHAIN	buffer.c	/^COPY_CHAIN(struct evbuffer *dst, struct evbuffer *src)$/;"	f	file:	signature:(struct evbuffer *dst, struct evbuffer *src)
CORE_SRC	Makefile	/^CORE_SRC = event.c evthread.c buffer.c \\$/;"	m
CPP	Makefile	/^CPP = gcc -E$/;"	m
CPP	include/Makefile	/^CPP = gcc -E$/;"	m
CPP	sample/Makefile	/^CPP = gcc -E$/;"	m
CPP	test/Makefile	/^CPP = gcc -E$/;"	m
CPPFLAGS	Makefile	/^CPPFLAGS = $/;"	m
CPPFLAGS	include/Makefile	/^CPPFLAGS = $/;"	m
CPPFLAGS	sample/Makefile	/^CPPFLAGS = $/;"	m
CPPFLAGS	test/Makefile	/^CPPFLAGS = $/;"	m
CSCOPE	Makefile	/^CSCOPE = cscope$/;"	m
CTAGS	Makefile	/^CTAGS = ctags$/;"	m
CTAGS	include/Makefile	/^CTAGS = ctags$/;"	m
CTAGS	sample/Makefile	/^CTAGS = ctags$/;"	m
CTAGS	test/Makefile	/^CTAGS = ctags$/;"	m
CYGPATH_W	Makefile	/^CYGPATH_W = echo$/;"	m
CYGPATH_W	include/Makefile	/^CYGPATH_W = echo$/;"	m
CYGPATH_W	sample/Makefile	/^CYGPATH_W = echo$/;"	m
CYGPATH_W	test/Makefile	/^CYGPATH_W = echo$/;"	m
CodeAdd	event_rpcgen.py	/^    def CodeAdd(self):$/;"	f	access:public
CodeArrayAdd	event_rpcgen.py	/^    def CodeArrayAdd(self, varname, value):$/;"	m	class:EntryBytes	access:public
CodeArrayAdd	event_rpcgen.py	/^    def CodeArrayAdd(self, varname, value):$/;"	m	class:EntryInt	access:public
CodeArrayAdd	event_rpcgen.py	/^    def CodeArrayAdd(self, varname, value):$/;"	m	class:EntryString	access:public
CodeArrayAdd	event_rpcgen.py	/^    def CodeArrayAdd(self, varname, value):$/;"	m	class:EntryStruct	access:public
CodeArrayAdd	event_rpcgen.py	/^    def CodeArrayAdd(self, varname, value):$/;"	m	class:EntryVarBytes	access:public
CodeArrayAssign	event_rpcgen.py	/^    def CodeArrayAssign(self, var, srcvar):$/;"	m	class:EntryStruct	access:public
CodeArrayAssign	event_rpcgen.py	/^    def CodeArrayAssign(self, varname, srcvar):$/;"	m	class:EntryInt	access:public
CodeArrayAssign	event_rpcgen.py	/^    def CodeArrayAssign(self, varname, srcvar):$/;"	m	class:EntryString	access:public
CodeArrayFree	event_rpcgen.py	/^    def CodeArrayFree(self, var):$/;"	m	class:EntryInt	access:public
CodeArrayFree	event_rpcgen.py	/^    def CodeArrayFree(self, var):$/;"	m	class:EntryStruct	access:public
CodeArrayFree	event_rpcgen.py	/^    def CodeArrayFree(self, varname):$/;"	m	class:EntryString	access:public
CodeAssign	event_rpcgen.py	/^    def CodeAssign(self):$/;"	f	access:public
CodeAssign	event_rpcgen.py	/^    def CodeAssign(self):$/;"	m	class:Entry	access:public
CodeAssign	event_rpcgen.py	/^    def CodeAssign(self):$/;"	m	class:EntryBytes	access:public
CodeAssign	event_rpcgen.py	/^    def CodeAssign(self):$/;"	m	class:EntryString	access:public
CodeAssign	event_rpcgen.py	/^    def CodeAssign(self):$/;"	m	class:EntryStruct	access:public
CodeAssign	event_rpcgen.py	/^    def CodeAssign(self):$/;"	m	class:EntryVarBytes	access:public
CodeBase	event_rpcgen.py	/^    def CodeBase(self):$/;"	m	class:Entry	access:public
CodeClear	event_rpcgen.py	/^    def CodeClear(self, structname):$/;"	f	access:public
CodeClear	event_rpcgen.py	/^    def CodeClear(self, structname):$/;"	m	class:Entry	access:public
CodeClear	event_rpcgen.py	/^    def CodeClear(self, structname):$/;"	m	class:EntryBytes	access:public
CodeClear	event_rpcgen.py	/^    def CodeClear(self, structname):$/;"	m	class:EntryString	access:public
CodeClear	event_rpcgen.py	/^    def CodeClear(self, structname):$/;"	m	class:EntryStruct	access:public
CodeClear	event_rpcgen.py	/^    def CodeClear(self, structname):$/;"	m	class:EntryVarBytes	access:public
CodeComplete	event_rpcgen.py	/^    def CodeComplete(self, structname, var_name):$/;"	f	access:public
CodeComplete	event_rpcgen.py	/^    def CodeComplete(self, structname, var_name):$/;"	m	class:Entry	access:public
CodeComplete	event_rpcgen.py	/^    def CodeComplete(self, structname, var_name):$/;"	m	class:EntryStruct	access:public
CodeFilename	event_rpcgen.py	/^    def CodeFilename(self, filename):$/;"	m	class:CCodeGenerator	access:public
CodeFree	event_rpcgen.py	/^    def CodeFree(self, name):$/;"	m	class:Entry	access:public
CodeFree	event_rpcgen.py	/^    def CodeFree(self, name):$/;"	m	class:EntryString	access:public
CodeFree	event_rpcgen.py	/^    def CodeFree(self, name):$/;"	m	class:EntryStruct	access:public
CodeFree	event_rpcgen.py	/^    def CodeFree(self, name):$/;"	m	class:EntryVarBytes	access:public
CodeFree	event_rpcgen.py	/^    def CodeFree(self, structname):$/;"	f	access:public
CodeGet	event_rpcgen.py	/^    def CodeGet(self):$/;"	m	class:Entry	access:public
CodeGet	event_rpcgen.py	/^    def CodeGet(self):$/;"	m	class:EntryArray	access:public
CodeGet	event_rpcgen.py	/^    def CodeGet(self):$/;"	m	class:EntryBytes	access:public
CodeGet	event_rpcgen.py	/^    def CodeGet(self):$/;"	m	class:EntryStruct	access:public
CodeGet	event_rpcgen.py	/^    def CodeGet(self):$/;"	m	class:EntryVarBytes	access:public
CodeInitialize	event_rpcgen.py	/^    def CodeInitialize(self, name):$/;"	f	access:public
CodeInitialize	event_rpcgen.py	/^    def CodeInitialize(self, name):$/;"	m	class:EntryBytes	access:public
CodeInitialize	event_rpcgen.py	/^    def CodeInitialize(self, name):$/;"	m	class:EntryInt	access:public
CodeInitialize	event_rpcgen.py	/^    def CodeInitialize(self, name):$/;"	m	class:EntryString	access:public
CodeInitialize	event_rpcgen.py	/^    def CodeInitialize(self, name):$/;"	m	class:EntryStruct	access:public
CodeInitialize	event_rpcgen.py	/^    def CodeInitialize(self, name):$/;"	m	class:EntryVarBytes	access:public
CodeMakeInitalize	event_rpcgen.py	/^    def CodeMakeInitalize(self, varname):$/;"	m	class:EntryString	access:public
CodeMarshal	event_rpcgen.py	/^    def CodeMarshal(self, buf, tag_name, var_name, var_len):$/;"	f	access:public
CodeMarshal	event_rpcgen.py	/^    def CodeMarshal(self, buf, tag_name, var_name, var_len):$/;"	m	class:EntryBytes	access:public
CodeMarshal	event_rpcgen.py	/^    def CodeMarshal(self, buf, tag_name, var_name, var_len):$/;"	m	class:EntryInt	access:public
CodeMarshal	event_rpcgen.py	/^    def CodeMarshal(self, buf, tag_name, var_name, var_len):$/;"	m	class:EntryString	access:public
CodeMarshal	event_rpcgen.py	/^    def CodeMarshal(self, buf, tag_name, var_name, var_len):$/;"	m	class:EntryStruct	access:public
CodeMarshal	event_rpcgen.py	/^    def CodeMarshal(self, buf, tag_name, var_name, var_len):$/;"	m	class:EntryVarBytes	access:public
CodeUnmarshal	event_rpcgen.py	/^    def CodeUnmarshal(self, buf, tag_name, var_name, var_len):$/;"	f	access:public
CodeUnmarshal	event_rpcgen.py	/^    def CodeUnmarshal(self, buf, tag_name, var_name, var_len):$/;"	m	class:EntryBytes	access:public
CodeUnmarshal	event_rpcgen.py	/^    def CodeUnmarshal(self, buf, tag_name, var_name, var_len):$/;"	m	class:EntryInt	access:public
CodeUnmarshal	event_rpcgen.py	/^    def CodeUnmarshal(self, buf, tag_name, var_name, var_len):$/;"	m	class:EntryString	access:public
CodeUnmarshal	event_rpcgen.py	/^    def CodeUnmarshal(self, buf, tag_name, var_name, var_len):$/;"	m	class:EntryStruct	access:public
CodeUnmarshal	event_rpcgen.py	/^    def CodeUnmarshal(self, buf, tag_name, var_name, var_len):$/;"	m	class:EntryVarBytes	access:public
CommandLine	event_rpcgen.py	/^class CommandLine:$/;"	c	inherits:
ConnectEx	iocp-internal.h	/^	ConnectExPtr ConnectEx;$/;"	m	struct:win32_extension_fns	access:public
ConnectExPtr	iocp-internal.h	/^typedef BOOL (WINAPI *ConnectExPtr)(SOCKET, const struct sockaddr *, int, PVOID, DWORD, LPDWORD, LPOVERLAPPED);$/;"	t
CreateProcess	libtool	/^   CreateProcess().  We must quote the arguments since Win32 CreateProcess()$/;"	f
CreateProcess	ltmain.sh	/^   CreateProcess().  We must quote the arguments since Win32 CreateProcess()$/;"	f
DATA	Makefile	/^DATA = $(pkgconfig_DATA)$/;"	m
DATA_CORRUPTED	http-internal.h	/^	DATA_CORRUPTED = -1,$/;"	e	enum:message_read_status
DATA_TOO_LONG	http-internal.h	/^	DATA_TOO_LONG = -3$/;"	e	enum:message_read_status
DEC	test/regress_http.c	2393;"	d	file:
DEC	test/regress_http.c	2469;"	d	file:
DECODE_INT_INTERNAL	event_tagging.c	306;"	d	file:
DEFAULT_INCLUDES	Makefile	/^DEFAULT_INCLUDES = -I.$/;"	m
DEFAULT_INCLUDES	sample/Makefile	/^DEFAULT_INCLUDES = -I. -I$(top_builddir)$/;"	m
DEFAULT_INCLUDES	test/Makefile	/^DEFAULT_INCLUDES = -I. -I$(top_builddir)$/;"	m
DEFAULT_NFDS	evport.c	83;"	d	file:
DEFAULT_WRITE_IOVEC	buffer.c	1992;"	d	file:
DEFS	Makefile	/^DEFS = -DHAVE_CONFIG_H$/;"	m
DEFS	include/Makefile	/^DEFS = -DHAVE_CONFIG_H$/;"	m
DEFS	sample/Makefile	/^DEFS = -DHAVE_CONFIG_H$/;"	m
DEFS	test/Makefile	/^DEFS = -DHAVE_CONFIG_H$/;"	m
DEPDIR	Makefile	/^DEPDIR = .deps$/;"	m
DEPDIR	include/Makefile	/^DEPDIR = .deps$/;"	m
DEPDIR	sample/Makefile	/^DEPDIR = .deps$/;"	m
DEPDIR	test/Makefile	/^DEPDIR = .deps$/;"	m
DISTCLEANFILES	Makefile	/^DISTCLEANFILES = *~ libevent.pc .\/include\/event2\/event-config.h$/;"	m
DISTCLEANFILES	sample/Makefile	/^DISTCLEANFILES = *~$/;"	m
DISTCLEANFILES	test/Makefile	/^DISTCLEANFILES = test-script.sh *~$/;"	m
DISTFILES	Makefile	/^DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)$/;"	m
DISTFILES	include/Makefile	/^DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)$/;"	m
DISTFILES	sample/Makefile	/^DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)$/;"	m
DISTFILES	test/Makefile	/^DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)$/;"	m
DIST_ARCHIVES	Makefile	/^DIST_ARCHIVES = $(distdir).tar.gz$/;"	m
DIST_COMMON	Makefile	/^DIST_COMMON = README $(am__configure_deps) \\$/;"	m
DIST_COMMON	include/Makefile	/^DIST_COMMON = $(am__nobase_include_HEADERS_DIST) \\$/;"	m
DIST_COMMON	sample/Makefile	/^DIST_COMMON = $(srcdir)\/Makefile.am $(srcdir)\/Makefile.in$/;"	m
DIST_COMMON	test/Makefile	/^DIST_COMMON = $(noinst_HEADERS) $(srcdir)\/Makefile.am \\$/;"	m
DIST_SOURCES	Makefile	/^DIST_SOURCES = $(am__libevent_la_SOURCES_DIST) \\$/;"	m
DIST_SOURCES	include/Makefile	/^DIST_SOURCES =$/;"	m
DIST_SOURCES	sample/Makefile	/^DIST_SOURCES = $(dns_example_SOURCES) $(event_test_SOURCES) \\$/;"	m
DIST_SOURCES	test/Makefile	/^DIST_SOURCES = $(bench_SOURCES) $(bench_cascade_SOURCES) \\$/;"	m
DIST_SUBDIRS	Makefile	/^DIST_SUBDIRS = $(SUBDIRS)$/;"	m
DIST_TARGETS	Makefile	/^DIST_TARGETS = dist-gzip$/;"	m
DIV_ROUNDUP	select.c	63;"	d	file:
DLLTOOL	Makefile	/^DLLTOOL = false$/;"	m
DLLTOOL	include/Makefile	/^DLLTOOL = false$/;"	m
DLLTOOL	sample/Makefile	/^DLLTOOL = false$/;"	m
DLLTOOL	test/Makefile	/^DLLTOOL = false$/;"	m
DNS_ERR_CANCEL	include/event2/dns.h	168;"	d
DNS_ERR_FORMAT	include/event2/dns.h	148;"	d
DNS_ERR_NODATA	include/event2/dns.h	172;"	d
DNS_ERR_NONE	include/event2/dns.h	146;"	d
DNS_ERR_NOTEXIST	include/event2/dns.h	153;"	d
DNS_ERR_NOTIMPL	include/event2/dns.h	155;"	d
DNS_ERR_REFUSED	include/event2/dns.h	158;"	d
DNS_ERR_SERVERFAILED	include/event2/dns.h	151;"	d
DNS_ERR_SHUTDOWN	include/event2/dns.h	166;"	d
DNS_ERR_TIMEOUT	include/event2/dns.h	164;"	d
DNS_ERR_TRUNCATED	include/event2/dns.h	160;"	d
DNS_ERR_UNKNOWN	include/event2/dns.h	162;"	d
DNS_IPv4_A	include/event2/dns.h	174;"	d
DNS_IPv6_AAAA	include/event2/dns.h	176;"	d
DNS_LEGACY	test/regress_dns.c	1824;"	d	file:
DNS_NO_SEARCH	include/event2/dns.h	187;"	d
DNS_OPTIONS_ALL	include/event2/dns.h	184;"	d
DNS_OPTION_HOSTSFILE	include/event2/dns.h	183;"	d
DNS_OPTION_MISC	include/event2/dns.h	182;"	d
DNS_OPTION_NAMESERVERS	include/event2/dns.h	181;"	d
DNS_OPTION_SEARCH	include/event2/dns.h	180;"	d
DNS_PTR	include/event2/dns.h	175;"	d
DNS_QUERY_NO_SEARCH	include/event2/dns.h	178;"	d
DSYMUTIL	Makefile	/^DSYMUTIL = $/;"	m
DSYMUTIL	include/Makefile	/^DSYMUTIL = $/;"	m
DSYMUTIL	sample/Makefile	/^DSYMUTIL = $/;"	m
DSYMUTIL	test/Makefile	/^DSYMUTIL = $/;"	m
DUMPBIN	Makefile	/^DUMPBIN = $/;"	m
DUMPBIN	include/Makefile	/^DUMPBIN = $/;"	m
DUMPBIN	sample/Makefile	/^DUMPBIN = $/;"	m
DUMPBIN	test/Makefile	/^DUMPBIN = $/;"	m
Declaration	event_rpcgen.py	/^    def Declaration(self):$/;"	f	access:public
Declaration	event_rpcgen.py	/^    def Declaration(self):$/;"	m	class:EntryBytes	access:public
Declaration	event_rpcgen.py	/^    def Declaration(self):$/;"	m	class:EntryInt	access:public
Declaration	event_rpcgen.py	/^    def Declaration(self):$/;"	m	class:EntryString	access:public
Declaration	event_rpcgen.py	/^    def Declaration(self):$/;"	m	class:EntryStruct	access:public
Declaration	event_rpcgen.py	/^    def Declaration(self):$/;"	m	class:EntryVarBytes	access:public
E	evutil.c	1472;"	d	file:
E	evutil.c	1533;"	d	file:
ECHO_C	Makefile	/^ECHO_C = $/;"	m
ECHO_C	include/Makefile	/^ECHO_C = $/;"	m
ECHO_C	sample/Makefile	/^ECHO_C = $/;"	m
ECHO_C	test/Makefile	/^ECHO_C = $/;"	m
ECHO_N	Makefile	/^ECHO_N = -n$/;"	m
ECHO_N	include/Makefile	/^ECHO_N = -n$/;"	m
ECHO_N	sample/Makefile	/^ECHO_N = -n$/;"	m
ECHO_N	test/Makefile	/^ECHO_N = -n$/;"	m
ECHO_T	Makefile	/^ECHO_T = $/;"	m
ECHO_T	include/Makefile	/^ECHO_T = $/;"	m
ECHO_T	sample/Makefile	/^ECHO_T = $/;"	m
ECHO_T	test/Makefile	/^ECHO_T = $/;"	m
EFD_CLOEXEC	event.c	2781;"	d	file:
EGREP	Makefile	/^EGREP = \/bin\/grep -E$/;"	m
EGREP	include/Makefile	/^EGREP = \/bin\/grep -E$/;"	m
EGREP	sample/Makefile	/^EGREP = \/bin\/grep -E$/;"	m
EGREP	test/Makefile	/^EGREP = \/bin\/grep -E$/;"	m
ENC	test/regress_http.c	2379;"	d	file:
ENC	test/regress_http.c	2468;"	d	file:
ENCODE_INT_INTERNAL	event_tagging.c	115;"	d	file:
END_OF_GROUPS	test/tinytest.h	65;"	d
END_OF_TESTCASES	test/tinytest.h	58;"	d
ERR	evutil.c	204;"	d	file:
ERR	evutil.c	291;"	d	file:
ERR_FORMAT	http.c	2378;"	d	file:
ERR_FORMAT	http.c	2401;"	d	file:
ERR_FORMAT	http.c	3043;"	d	file:
ERR_FORMAT	http.c	3073;"	d	file:
ETAGS	Makefile	/^ETAGS = etags$/;"	m
ETAGS	include/Makefile	/^ETAGS = etags$/;"	m
ETAGS	sample/Makefile	/^ETAGS = etags$/;"	m
ETAGS	test/Makefile	/^ETAGS = etags$/;"	m
EVBASE_ACQUIRE_LOCK	evthread-internal.h	113;"	d
EVBASE_ACQUIRE_LOCK	evthread-internal.h	227;"	d
EVBASE_ACQUIRE_LOCK	evthread-internal.h	305;"	d
EVBASE_IN_THREAD	evthread-internal.h	195;"	d
EVBASE_IN_THREAD	evthread-internal.h	303;"	d
EVBASE_IN_THREAD	evthread-internal.h	61;"	d
EVBASE_NEED_NOTIFY	evthread-internal.h	197;"	d
EVBASE_NEED_NOTIFY	evthread-internal.h	304;"	d
EVBASE_NEED_NOTIFY	evthread-internal.h	68;"	d
EVBASE_RELEASE_LOCK	evthread-internal.h	118;"	d
EVBASE_RELEASE_LOCK	evthread-internal.h	232;"	d
EVBASE_RELEASE_LOCK	evthread-internal.h	306;"	d
EVBUFFER_CB_ENABLED	include/event2/buffer.h	727;"	d
EVBUFFER_CB_INTERNAL_FLAGS	buffer.c	125;"	d	file:
EVBUFFER_CB_NODEFER	evbuffer-internal.h	42;"	d
EVBUFFER_CB_OBSOLETE	buffer.c	128;"	d	file:
EVBUFFER_CB_USER_FLAGS	buffer.c	123;"	d	file:
EVBUFFER_CHAIN_EXTRA	evbuffer-internal.h	226;"	d
EVBUFFER_CHAIN_MAX	evbuffer-internal.h	158;"	d
EVBUFFER_CHAIN_MAX	evbuffer-internal.h	162;"	d
EVBUFFER_CHAIN_MAX	evbuffer-internal.h	164;"	d
EVBUFFER_CHAIN_MAX_AUTO_SIZE	buffer.c	1539;"	d	file:
EVBUFFER_CHAIN_SIZE	evbuffer-internal.h	224;"	d
EVBUFFER_DANGLING	evbuffer-internal.h	198;"	d
EVBUFFER_DATA	include/event2/buffer_compat.h	107;"	d
EVBUFFER_EOF	include/event2/bufferevent_compat.h	91;"	d
EVBUFFER_EOL_ANY	include/event2/buffer.h	/^	EVBUFFER_EOL_ANY,$/;"	e	enum:evbuffer_eol_style
EVBUFFER_EOL_CRLF	include/event2/buffer.h	/^	EVBUFFER_EOL_CRLF,$/;"	e	enum:evbuffer_eol_style
EVBUFFER_EOL_CRLF_STRICT	include/event2/buffer.h	/^	EVBUFFER_EOL_CRLF_STRICT,$/;"	e	enum:evbuffer_eol_style
EVBUFFER_EOL_LF	include/event2/buffer.h	/^	EVBUFFER_EOL_LF$/;"	e	enum:evbuffer_eol_style
EVBUFFER_ERROR	include/event2/bufferevent_compat.h	92;"	d
EVBUFFER_FLAG_DRAINS_TO_FD	include/event2/buffer.h	193;"	d
EVBUFFER_IMMUTABLE	evbuffer-internal.h	190;"	d
EVBUFFER_INITIAL_LENGTH	test/regress_buffer.c	1031;"	d	file:
EVBUFFER_INPUT	include/event2/bufferevent_compat.h	96;"	d
EVBUFFER_LENGTH	include/event2/buffer_compat.h	105;"	d
EVBUFFER_LOCK	evbuffer-internal.h	232;"	d
EVBUFFER_LOCK2	evbuffer-internal.h	240;"	d
EVBUFFER_MAX_READ	buffer.c	2016;"	d	file:
EVBUFFER_MEM_PINNED_ANY	evbuffer-internal.h	195;"	d
EVBUFFER_MEM_PINNED_R	evbuffer-internal.h	193;"	d
EVBUFFER_MEM_PINNED_W	evbuffer-internal.h	194;"	d
EVBUFFER_MMAP	evbuffer-internal.h	187;"	d
EVBUFFER_OUTPUT	include/event2/bufferevent_compat.h	98;"	d
EVBUFFER_PTR_ADD	include/event2/buffer.h	/^	EVBUFFER_PTR_ADD$/;"	e	enum:evbuffer_ptr_how
EVBUFFER_PTR_SET	include/event2/buffer.h	/^	EVBUFFER_PTR_SET,$/;"	e	enum:evbuffer_ptr_how
EVBUFFER_READ	include/event2/bufferevent_compat.h	89;"	d
EVBUFFER_REFERENCE	evbuffer-internal.h	189;"	d
EVBUFFER_SENDFILE	evbuffer-internal.h	188;"	d
EVBUFFER_TIMEOUT	include/event2/bufferevent_compat.h	93;"	d
EVBUFFER_UNLOCK	evbuffer-internal.h	236;"	d
EVBUFFER_UNLOCK2	evbuffer-internal.h	244;"	d
EVBUFFER_WRITE	include/event2/bufferevent_compat.h	90;"	d
EVCON_CONNECTING	http-internal.h	/^	EVCON_CONNECTING,	\/**< tries to currently connect *\/$/;"	e	enum:evhttp_connection_state
EVCON_DISCONNECTED	http-internal.h	/^	EVCON_DISCONNECTED,	\/**< not currently connected not trying either*\/$/;"	e	enum:evhttp_connection_state
EVCON_HTTP_BUFFER_ERROR	http-internal.h	/^	EVCON_HTTP_BUFFER_ERROR,$/;"	e	enum:evhttp_connection_error
EVCON_HTTP_EOF	http-internal.h	/^	EVCON_HTTP_EOF,$/;"	e	enum:evhttp_connection_error
EVCON_HTTP_INVALID_HEADER	http-internal.h	/^	EVCON_HTTP_INVALID_HEADER,$/;"	e	enum:evhttp_connection_error
EVCON_HTTP_REQUEST_CANCEL	http-internal.h	/^	EVCON_HTTP_REQUEST_CANCEL$/;"	e	enum:evhttp_connection_error
EVCON_HTTP_TIMEOUT	http-internal.h	/^	EVCON_HTTP_TIMEOUT,$/;"	e	enum:evhttp_connection_error
EVCON_IDLE	http-internal.h	/^	EVCON_IDLE,		\/**< connection is established *\/$/;"	e	enum:evhttp_connection_state
EVCON_READING_BODY	http-internal.h	/^	EVCON_READING_BODY,	\/**< reading request\/response body *\/$/;"	e	enum:evhttp_connection_state
EVCON_READING_FIRSTLINE	http-internal.h	/^	EVCON_READING_FIRSTLINE,\/**< reading Request-Line (incoming conn) or$/;"	e	enum:evhttp_connection_state
EVCON_READING_HEADERS	http-internal.h	/^	EVCON_READING_HEADERS,	\/**< reading request\/response headers *\/$/;"	e	enum:evhttp_connection_state
EVCON_READING_TRAILER	http-internal.h	/^	EVCON_READING_TRAILER,	\/**< reading request\/response chunked trailer *\/$/;"	e	enum:evhttp_connection_state
EVCON_WRITING	http-internal.h	/^	EVCON_WRITING		\/**< writing request\/response headers\/body *\/$/;"	e	enum:evhttp_connection_state
EVDNS_ADDITIONAL_SECTION	include/event2/dns.h	545;"	d
EVDNS_ANSWER_SECTION	include/event2/dns.h	543;"	d
EVDNS_AUTHORITY_SECTION	include/event2/dns.h	544;"	d
EVDNS_BASE_CONFIG_WINDOWS_NAMESERVERS_IMPLEMENTED	include/event2/dns.h	455;"	d
EVDNS_CLASS_INET	include/event2/dns.h	559;"	d
EVDNS_CONFIG_WINDOWS_NAMESERVERS_IMPLEMENTED	include/event2/dns_compat.h	329;"	d
EVDNS_FLAGS_AA	include/event2/dns.h	562;"	d
EVDNS_FLAGS_RD	include/event2/dns.h	563;"	d
EVDNS_LOCK	evdns.c	415;"	d	file:
EVDNS_LOCK	evdns.c	419;"	d	file:
EVDNS_LOG_CHECK	evdns.c	447;"	d	file:
EVDNS_LOG_CHECK	evdns.c	449;"	d	file:
EVDNS_LOG_DEBUG	evdns.c	120;"	d	file:
EVDNS_LOG_MSG	evdns.c	122;"	d	file:
EVDNS_LOG_WARN	evdns.c	121;"	d	file:
EVDNS_QTYPE_ALL	include/event2/dns.h	557;"	d
EVDNS_QTYPE_AXFR	include/event2/dns.h	556;"	d
EVDNS_TYPE_A	include/event2/dns.h	547;"	d
EVDNS_TYPE_AAAA	include/event2/dns.h	554;"	d
EVDNS_TYPE_CNAME	include/event2/dns.h	549;"	d
EVDNS_TYPE_MX	include/event2/dns.h	552;"	d
EVDNS_TYPE_NS	include/event2/dns.h	548;"	d
EVDNS_TYPE_PTR	include/event2/dns.h	551;"	d
EVDNS_TYPE_SOA	include/event2/dns.h	550;"	d
EVDNS_TYPE_TXT	include/event2/dns.h	553;"	d
EVDNS_UNLOCK	evdns.c	416;"	d	file:
EVDNS_UNLOCK	evdns.c	421;"	d	file:
EVENT1_HDRS	Makefile	/^EVENT1_HDRS = event.h evhttp.h evdns.h evrpc.h evutil.h$/;"	m
EVENT2_EXPORT	include/Makefile	/^EVENT2_EXPORT = \\$/;"	m
EVENTS_PER_GETN	evport.c	91;"	d	file:
EVENT_BASE_ASSERT_LOCKED	event.c	325;"	d	file:
EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST	include/event2/event.h	/^	EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10$/;"	e	enum:event_base_config_flag
EVENT_BASE_FLAG_IGNORE_ENV	include/event2/event.h	/^	EVENT_BASE_FLAG_IGNORE_ENV = 0x02,$/;"	e	enum:event_base_config_flag
EVENT_BASE_FLAG_NOLOCK	include/event2/event.h	/^	EVENT_BASE_FLAG_NOLOCK = 0x01,$/;"	e	enum:event_base_config_flag
EVENT_BASE_FLAG_NO_CACHE_TIME	include/event2/event.h	/^	EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08,$/;"	e	enum:event_base_config_flag
EVENT_BASE_FLAG_STARTUP_IOCP	include/event2/event.h	/^	EVENT_BASE_FLAG_STARTUP_IOCP = 0x04,$/;"	e	enum:event_base_config_flag
EVENT_CHANGELIST_FDINFO_SIZE	changelist-internal.h	82;"	d
EVENT_DEBUG_MODE_IS_ON	event-internal.h	165;"	d
EVENT_DEBUG_MODE_IS_ON	event-internal.h	167;"	d
EVENT_FD	include/event2/event_compat.h	212;"	d
EVENT_LOG_DEBUG	include/event2/event.h	566;"	d
EVENT_LOG_ERR	include/event2/event.h	569;"	d
EVENT_LOG_MSG	include/event2/event.h	567;"	d
EVENT_LOG_WARN	include/event2/event.h	568;"	d
EVENT_MAX_PRIORITIES	include/event2/event.h	1090;"	d
EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED	include/event2/event.h	1181;"	d
EVENT_SIGNAL	include/event2/event_compat.h	213;"	d
EVHTTP_CON_CLOSEDETECT	http-internal.h	84;"	d
EVHTTP_CON_INCOMING	http-internal.h	82;"	d
EVHTTP_CON_OUTGOING	http-internal.h	83;"	d
EVHTTP_PROXY_REQUEST	include/event2/http_struct.h	73;"	d
EVHTTP_REQUEST	include/event2/http.h	/^enum evhttp_request_kind { EVHTTP_REQUEST, EVHTTP_RESPONSE };$/;"	e	enum:evhttp_request_kind
EVHTTP_REQ_CONNECT	include/event2/http.h	/^	EVHTTP_REQ_CONNECT = 1 << 7,$/;"	e	enum:evhttp_cmd_type
EVHTTP_REQ_DEFER_FREE	include/event2/http_struct.h	77;"	d
EVHTTP_REQ_DELETE	include/event2/http.h	/^	EVHTTP_REQ_DELETE  = 1 << 4,$/;"	e	enum:evhttp_cmd_type
EVHTTP_REQ_GET	include/event2/http.h	/^	EVHTTP_REQ_GET     = 1 << 0,$/;"	e	enum:evhttp_cmd_type
EVHTTP_REQ_HEAD	include/event2/http.h	/^	EVHTTP_REQ_HEAD    = 1 << 2,$/;"	e	enum:evhttp_cmd_type
EVHTTP_REQ_NEEDS_FREE	include/event2/http_struct.h	79;"	d
EVHTTP_REQ_OPTIONS	include/event2/http.h	/^	EVHTTP_REQ_OPTIONS = 1 << 5,$/;"	e	enum:evhttp_cmd_type
EVHTTP_REQ_OWN_CONNECTION	include/event2/http_struct.h	71;"	d
EVHTTP_REQ_PATCH	include/event2/http.h	/^	EVHTTP_REQ_PATCH   = 1 << 8$/;"	e	enum:evhttp_cmd_type
EVHTTP_REQ_POST	include/event2/http.h	/^	EVHTTP_REQ_POST    = 1 << 1,$/;"	e	enum:evhttp_cmd_type
EVHTTP_REQ_PUT	include/event2/http.h	/^	EVHTTP_REQ_PUT     = 1 << 3,$/;"	e	enum:evhttp_cmd_type
EVHTTP_REQ_TRACE	include/event2/http.h	/^	EVHTTP_REQ_TRACE   = 1 << 6,$/;"	e	enum:evhttp_cmd_type
EVHTTP_RESPONSE	include/event2/http.h	/^enum evhttp_request_kind { EVHTTP_REQUEST, EVHTTP_RESPONSE };$/;"	e	enum:evhttp_request_kind
EVHTTP_URI_NONCONFORMANT	include/event2/http.h	830;"	d
EVHTTP_USER_OWNED	include/event2/http_struct.h	75;"	d
EVLIST_ACTIVE	include/event2/event_struct.h	60;"	d
EVLIST_ALL	include/event2/event_struct.h	65;"	d
EVLIST_INIT	include/event2/event_struct.h	62;"	d
EVLIST_INSERTED	include/event2/event_struct.h	58;"	d
EVLIST_INTERNAL	include/event2/event_struct.h	61;"	d
EVLIST_SIGNAL	include/event2/event_struct.h	59;"	d
EVLIST_TIMEOUT	include/event2/event_struct.h	57;"	d
EVLIST_X_IOFOUND	evmap.c	732;"	d	file:
EVLIST_X_SIGFOUND	evmap.c	731;"	d	file:
EVLOCK_ASSERT_LOCKED	evthread-internal.h	124;"	d
EVLOCK_ASSERT_LOCKED	evthread-internal.h	238;"	d
EVLOCK_ASSERT_LOCKED	evthread-internal.h	307;"	d
EVLOCK_LOCK	evthread-internal.h	212;"	d
EVLOCK_LOCK	evthread-internal.h	298;"	d
EVLOCK_LOCK	evthread-internal.h	88;"	d
EVLOCK_LOCK2	evthread-internal.h	300;"	d
EVLOCK_LOCK2	evthread-internal.h	336;"	d
EVLOCK_TRY_LOCK	evthread-internal.h	/^EVLOCK_TRY_LOCK(void *lock)$/;"	f	signature:(void *lock)
EVLOCK_TRY_LOCK	evthread-internal.h	/^static inline int EVLOCK_TRY_LOCK(void *lock);$/;"	p	signature:(void *lock)
EVLOCK_TRY_LOCK	evthread-internal.h	309;"	d
EVLOCK_UNLOCK	evthread-internal.h	219;"	d
EVLOCK_UNLOCK	evthread-internal.h	299;"	d
EVLOCK_UNLOCK	evthread-internal.h	95;"	d
EVLOCK_UNLOCK2	evthread-internal.h	301;"	d
EVLOCK_UNLOCK2	evthread-internal.h	346;"	d
EVLOOP_NONBLOCK	include/event2/event.h	639;"	d
EVLOOP_ONCE	include/event2/event.h	636;"	d
EVMAP_USE_HT	event-internal.h	107;"	d
EVRPC_CONTINUE	include/event2/rpc.h	/^	EVRPC_CONTINUE = 0,	\/**< continue processing the rpc *\/$/;"	e	enum:EVRPC_HOOK_RESULT
EVRPC_GENERATE	include/event2/rpc.h	233;"	d
EVRPC_HEADER	include/event2/rpc.h	172;"	d
EVRPC_HOOK_RESULT	include/event2/rpc.h	/^enum EVRPC_HOOK_RESULT {$/;"	g
EVRPC_HOOK_TYPE	include/event2/rpc.h	/^enum EVRPC_HOOK_TYPE {$/;"	g
EVRPC_INPUT	include/event2/rpc.h	/^	EVRPC_INPUT,		\/**< apply the function to an input hook *\/$/;"	e	enum:EVRPC_HOOK_TYPE
EVRPC_MAKE_CTX	include/event2/rpc.h	213;"	d
EVRPC_MAKE_REQUEST	include/event2/rpc.h	374;"	d
EVRPC_OUTPUT	include/event2/rpc.h	/^	EVRPC_OUTPUT		\/**< apply the function to an output hook *\/$/;"	e	enum:EVRPC_HOOK_TYPE
EVRPC_PAUSE	include/event2/rpc.h	/^	EVRPC_PAUSE = 1		\/**< pause processing request until resumed *\/$/;"	e	enum:EVRPC_HOOK_RESULT
EVRPC_REGISTER	include/event2/rpc.h	319;"	d
EVRPC_REQUEST_DONE	include/event2/rpc.h	274;"	d
EVRPC_REQUEST_HTTP	include/event2/rpc.h	257;"	d
EVRPC_STATUS_ERR_BADPAYLOAD	include/event2/rpc_struct.h	47;"	d
EVRPC_STATUS_ERR_HOOKABORTED	include/event2/rpc_struct.h	49;"	d
EVRPC_STATUS_ERR_NONE	include/event2/rpc_struct.h	45;"	d
EVRPC_STATUS_ERR_TIMEOUT	include/event2/rpc_struct.h	46;"	d
EVRPC_STATUS_ERR_UNSTARTED	include/event2/rpc_struct.h	48;"	d
EVRPC_STRUCT	include/event2/rpc.h	155;"	d
EVRPC_STRUCT	test/regress_rpc.c	/^MessageCb(EVRPC_STRUCT(Message)* rpc, void *arg)$/;"	f	file:
EVRPC_STRUCT	test/regress_rpc.c	/^NeverReplyCb(EVRPC_STRUCT(NeverReply)* rpc, void *arg)$/;"	f	file:
EVRPC_STRUCT	test/regress_rpc.c	/^static EVRPC_STRUCT(NeverReply) *saved_rpc;$/;"	p	file:
EVRPC_TERMINATE	include/event2/rpc.h	/^	EVRPC_TERMINATE = -1,	\/**< indicates the rpc should be terminated *\/$/;"	e	enum:EVRPC_HOOK_RESULT
EVRPC_UNREGISTER	include/event2/rpc.h	348;"	d
EVRPC_URI_PREFIX	evrpc-internal.h	35;"	d
EVSIGBASE_LOCK	signal.c	115;"	d	file:
EVSIGBASE_UNLOCK	signal.c	116;"	d	file:
EVTAG_ADD	include/event2/rpc_compat.h	46;"	d
EVTAG_ADD	include/event2/rpc_compat.h	52;"	d
EVTAG_ARRAY_ADD	include/event2/rpc.h	132;"	d
EVTAG_ARRAY_ADD_VALUE	include/event2/rpc.h	127;"	d
EVTAG_ARRAY_GET	include/event2/rpc.h	137;"	d
EVTAG_ARRAY_LEN	include/event2/rpc.h	142;"	d
EVTAG_ASSIGN	include/event2/rpc.h	88;"	d
EVTAG_ASSIGN	include/event2/rpc_compat.h	44;"	d
EVTAG_ASSIGN	include/event2/rpc_compat.h	48;"	d
EVTAG_ASSIGN_WITH_LEN	include/event2/rpc.h	98;"	d
EVTAG_GET	include/event2/rpc.h	108;"	d
EVTAG_GET	include/event2/rpc_compat.h	45;"	d
EVTAG_GET	include/event2/rpc_compat.h	50;"	d
EVTAG_GET_WITH_LEN	include/event2/rpc.h	119;"	d
EVTAG_HAS	include/event2/rpc.h	76;"	d
EVTAG_LEN	include/event2/rpc_compat.h	55;"	d
EVTHREAD_ALLOC_COND	evthread-internal.h	148;"	d
EVTHREAD_ALLOC_COND	evthread-internal.h	262;"	d
EVTHREAD_ALLOC_COND	evthread-internal.h	311;"	d
EVTHREAD_ALLOC_LOCK	evthread-internal.h	201;"	d
EVTHREAD_ALLOC_LOCK	evthread-internal.h	295;"	d
EVTHREAD_ALLOC_LOCK	evthread-internal.h	75;"	d
EVTHREAD_CONDITION_API_VERSION	include/event2/thread.h	129;"	d
EVTHREAD_COND_BROADCAST	evthread-internal.h	163;"	d
EVTHREAD_COND_BROADCAST	evthread-internal.h	276;"	d
EVTHREAD_COND_BROADCAST	evthread-internal.h	314;"	d
EVTHREAD_COND_SIGNAL	evthread-internal.h	160;"	d
EVTHREAD_COND_SIGNAL	evthread-internal.h	273;"	d
EVTHREAD_COND_SIGNAL	evthread-internal.h	313;"	d
EVTHREAD_COND_WAIT	evthread-internal.h	169;"	d
EVTHREAD_COND_WAIT	evthread-internal.h	282;"	d
EVTHREAD_COND_WAIT	evthread-internal.h	315;"	d
EVTHREAD_COND_WAIT_TIMED	evthread-internal.h	173;"	d
EVTHREAD_COND_WAIT_TIMED	evthread-internal.h	286;"	d
EVTHREAD_COND_WAIT_TIMED	evthread-internal.h	316;"	d
EVTHREAD_EXPOSE_STRUCTS	evthread-internal.h	44;"	d
EVTHREAD_FREE_COND	evthread-internal.h	154;"	d
EVTHREAD_FREE_COND	evthread-internal.h	267;"	d
EVTHREAD_FREE_COND	evthread-internal.h	312;"	d
EVTHREAD_FREE_LOCK	evthread-internal.h	204;"	d
EVTHREAD_FREE_LOCK	evthread-internal.h	296;"	d
EVTHREAD_FREE_LOCK	evthread-internal.h	80;"	d
EVTHREAD_GET_ID	evthread-internal.h	194;"	d
EVTHREAD_GET_ID	evthread-internal.h	294;"	d
EVTHREAD_GET_ID	evthread-internal.h	56;"	d
EVTHREAD_LOCKING_ENABLED	evthread-internal.h	177;"	d
EVTHREAD_LOCKING_ENABLED	evthread-internal.h	289;"	d
EVTHREAD_LOCKING_ENABLED	evthread-internal.h	318;"	d
EVTHREAD_LOCKTYPE_READWRITE	include/event2/thread.h	86;"	d
EVTHREAD_LOCKTYPE_RECURSIVE	include/event2/thread.h	83;"	d
EVTHREAD_LOCK_API_VERSION	include/event2/thread.h	74;"	d
EVTHREAD_READ	include/event2/thread.h	65;"	d
EVTHREAD_SETUP_GLOBAL_LOCK	evthread-internal.h	362;"	d
EVTHREAD_TRY	include/event2/thread.h	69;"	d
EVTHREAD_USE_PTHREADS_IMPLEMENTED	include/event2/thread.h	210;"	d
EVTHREAD_USE_WINDOWS_THREADS_IMPLEMENTED	include/event2/thread.h	199;"	d
EVTHREAD_WRITE	include/event2/thread.h	62;"	d
EVUTIL_AI_ADDRCONFIG	include/event2/util.h	623;"	d
EVUTIL_AI_ADDRCONFIG	include/event2/util.h	625;"	d
EVUTIL_AI_ALL	include/event2/util.h	618;"	d
EVUTIL_AI_ALL	include/event2/util.h	620;"	d
EVUTIL_AI_CANONNAME	include/event2/util.h	598;"	d
EVUTIL_AI_CANONNAME	include/event2/util.h	600;"	d
EVUTIL_AI_LIBEVENT_ALLOCATED	evutil.c	640;"	d	file:
EVUTIL_AI_NUMERICHOST	include/event2/util.h	603;"	d
EVUTIL_AI_NUMERICHOST	include/event2/util.h	605;"	d
EVUTIL_AI_NUMERICSERV	include/event2/util.h	608;"	d
EVUTIL_AI_NUMERICSERV	include/event2/util.h	610;"	d
EVUTIL_AI_PASSIVE	include/event2/util.h	593;"	d
EVUTIL_AI_PASSIVE	include/event2/util.h	595;"	d
EVUTIL_AI_V4MAPPED	include/event2/util.h	613;"	d
EVUTIL_AI_V4MAPPED	include/event2/util.h	615;"	d
EVUTIL_ASSERT	util-internal.h	195;"	d
EVUTIL_ASSERT	util-internal.h	198;"	d
EVUTIL_CLOSESOCKET	include/event2/util.h	324;"	d
EVUTIL_EAI_ADDRFAMILY	include/event2/util.h	532;"	d
EVUTIL_EAI_ADDRFAMILY	include/event2/util.h	534;"	d
EVUTIL_EAI_AGAIN	include/event2/util.h	537;"	d
EVUTIL_EAI_AGAIN	include/event2/util.h	539;"	d
EVUTIL_EAI_BADFLAGS	include/event2/util.h	542;"	d
EVUTIL_EAI_BADFLAGS	include/event2/util.h	544;"	d
EVUTIL_EAI_CANCEL	include/event2/util.h	590;"	d
EVUTIL_EAI_FAIL	include/event2/util.h	547;"	d
EVUTIL_EAI_FAIL	include/event2/util.h	549;"	d
EVUTIL_EAI_FAMILY	include/event2/util.h	552;"	d
EVUTIL_EAI_FAMILY	include/event2/util.h	554;"	d
EVUTIL_EAI_MEMORY	include/event2/util.h	557;"	d
EVUTIL_EAI_MEMORY	include/event2/util.h	559;"	d
EVUTIL_EAI_NEED_RESOLVE	util-internal.h	233;"	d
EVUTIL_EAI_NODATA	include/event2/util.h	565;"	d
EVUTIL_EAI_NODATA	include/event2/util.h	567;"	d
EVUTIL_EAI_NONAME	include/event2/util.h	570;"	d
EVUTIL_EAI_NONAME	include/event2/util.h	572;"	d
EVUTIL_EAI_SERVICE	include/event2/util.h	575;"	d
EVUTIL_EAI_SERVICE	include/event2/util.h	577;"	d
EVUTIL_EAI_SOCKTYPE	include/event2/util.h	580;"	d
EVUTIL_EAI_SOCKTYPE	include/event2/util.h	582;"	d
EVUTIL_EAI_SYSTEM	include/event2/util.h	585;"	d
EVUTIL_EAI_SYSTEM	include/event2/util.h	587;"	d
EVUTIL_ERR_ACCEPT_RETRIABLE	util-internal.h	102;"	d
EVUTIL_ERR_ACCEPT_RETRIABLE	util-internal.h	83;"	d
EVUTIL_ERR_CONNECT_REFUSED	util-internal.h	105;"	d
EVUTIL_ERR_CONNECT_REFUSED	util-internal.h	87;"	d
EVUTIL_ERR_CONNECT_RETRIABLE	util-internal.h	80;"	d
EVUTIL_ERR_CONNECT_RETRIABLE	util-internal.h	96;"	d
EVUTIL_ERR_RW_RETRIABLE	util-internal.h	77;"	d
EVUTIL_ERR_RW_RETRIABLE	util-internal.h	92;"	d
EVUTIL_FAILURE_CHECK	util-internal.h	196;"	d
EVUTIL_FAILURE_CHECK	util-internal.h	212;"	d
EVUTIL_ISALNUM	util-internal.h	/^int EVUTIL_ISALNUM(char c);$/;"	p	signature:(char c)
EVUTIL_ISALNUM_TABLE	evutil.c	/^static const ev_uint32_t EVUTIL_ISALNUM_TABLE[8] =$/;"	v	file:
EVUTIL_ISALPHA	util-internal.h	/^int EVUTIL_ISALPHA(char c);$/;"	p	signature:(char c)
EVUTIL_ISALPHA_TABLE	evutil.c	/^static const ev_uint32_t EVUTIL_ISALPHA_TABLE[8] =$/;"	v	file:
EVUTIL_ISDIGIT	util-internal.h	/^int EVUTIL_ISDIGIT(char c);$/;"	p	signature:(char c)
EVUTIL_ISDIGIT_TABLE	evutil.c	/^static const ev_uint32_t EVUTIL_ISDIGIT_TABLE[8] = { 0, 0x3ff0000, 0, 0, 0, 0, 0, 0 };$/;"	v	file:
EVUTIL_ISLOWER	util-internal.h	/^int EVUTIL_ISLOWER(char c);$/;"	p	signature:(char c)
EVUTIL_ISLOWER_TABLE	evutil.c	/^static const ev_uint32_t EVUTIL_ISLOWER_TABLE[8] = { 0, 0, 0, 0x7fffffe, 0, 0, 0, 0 };$/;"	v	file:
EVUTIL_ISPRINT	util-internal.h	/^int EVUTIL_ISPRINT(char c);$/;"	p	signature:(char c)
EVUTIL_ISPRINT_TABLE	evutil.c	/^static const ev_uint32_t EVUTIL_ISPRINT_TABLE[8] =$/;"	v	file:
EVUTIL_ISSPACE	util-internal.h	/^int EVUTIL_ISSPACE(char c);$/;"	p	signature:(char c)
EVUTIL_ISSPACE_TABLE	evutil.c	/^static const ev_uint32_t EVUTIL_ISSPACE_TABLE[8] = { 0x3e00, 0x1, 0, 0, 0, 0, 0, 0 };$/;"	v	file:
EVUTIL_ISUPPER	util-internal.h	/^int EVUTIL_ISUPPER(char c);$/;"	p	signature:(char c)
EVUTIL_ISUPPER_TABLE	evutil.c	/^static const ev_uint32_t EVUTIL_ISUPPER_TABLE[8] = { 0, 0, 0x7fffffe, 0, 0, 0, 0, 0 };$/;"	v	file:
EVUTIL_ISXDIGIT	util-internal.h	/^int EVUTIL_ISXDIGIT(char c);$/;"	p	signature:(char c)
EVUTIL_ISXDIGIT_TABLE	evutil.c	/^static const ev_uint32_t EVUTIL_ISXDIGIT_TABLE[8] =$/;"	v	file:
EVUTIL_SET_SOCKET_ERROR	include/event2/util.h	331;"	d
EVUTIL_SET_SOCKET_ERROR	include/event2/util.h	355;"	d
EVUTIL_SET_SOCKET_ERROR	include/event2/util.h	363;"	d
EVUTIL_SHUT_BOTH	util-internal.h	126;"	d
EVUTIL_SHUT_BOTH	util-internal.h	128;"	d
EVUTIL_SHUT_RD	util-internal.h	116;"	d
EVUTIL_SHUT_RD	util-internal.h	118;"	d
EVUTIL_SHUT_WR	util-internal.h	121;"	d
EVUTIL_SHUT_WR	util-internal.h	123;"	d
EVUTIL_SOCKET_ERROR	include/event2/util.h	329;"	d
EVUTIL_SOCKET_ERROR	include/event2/util.h	353;"	d
EVUTIL_SOCKET_ERROR	include/event2/util.h	362;"	d
EVUTIL_TOLOWER	util-internal.h	/^char EVUTIL_TOLOWER(char c);$/;"	p	signature:(char c)
EVUTIL_TOLOWER_TABLE	evutil.c	/^static const unsigned char EVUTIL_TOLOWER_TABLE[256] = {$/;"	v	file:
EVUTIL_TOUPPER	evutil.c	/^char EVUTIL_TOUPPER(char c)$/;"	f	signature:(char c)
EVUTIL_TOUPPER	util-internal.h	/^char EVUTIL_TOUPPER(char c);$/;"	p	signature:(char c)
EVUTIL_TOUPPER_TABLE	evutil.c	/^static const unsigned char EVUTIL_TOUPPER_TABLE[256] = {$/;"	v	file:
EVUTIL_UNLIKELY	util-internal.h	188;"	d
EVUTIL_UNLIKELY	util-internal.h	190;"	d
EVUTIL_UPCAST	util-internal.h	161;"	d
EVUTIL_V4ADDR_IS_CLASSD	evutil.c	546;"	d	file:
EVUTIL_V4ADDR_IS_LOCALHOST	evutil.c	541;"	d	file:
EV_CHANGE_ADD	changelist-internal.h	70;"	d
EV_CHANGE_DEL	changelist-internal.h	72;"	d
EV_CHANGE_ET	changelist-internal.h	78;"	d
EV_CHANGE_PERSIST	changelist-internal.h	76;"	d
EV_CHANGE_SIGNAL	changelist-internal.h	74;"	d
EV_CHECK_FMT	log-internal.h	33;"	d
EV_CHECK_FMT	log-internal.h	36;"	d
EV_CHECK_FMT	log-internal.h	57;"	d
EV_CLOSURE_NONE	event-internal.h	55;"	d
EV_CLOSURE_PERSIST	event-internal.h	57;"	d
EV_CLOSURE_SIGNAL	event-internal.h	56;"	d
EV_ET	include/event2/event.h	746;"	d
EV_FEATURE_ET	include/event2/event.h	/^    EV_FEATURE_ET = 0x01,$/;"	e	enum:event_method_feature
EV_FEATURE_FDS	include/event2/event.h	/^    EV_FEATURE_FDS = 0x04$/;"	e	enum:event_method_feature
EV_FEATURE_O1	include/event2/event.h	/^    EV_FEATURE_O1 = 0x02,$/;"	e	enum:event_method_feature
EV_I64_ARG	util-internal.h	282;"	d
EV_I64_ARG	util-internal.h	287;"	d
EV_I64_FMT	util-internal.h	281;"	d
EV_I64_FMT	util-internal.h	286;"	d
EV_INT16_MAX	include/event2/util.h	225;"	d
EV_INT16_MIN	include/event2/util.h	226;"	d
EV_INT32_MAX	include/event2/util.h	222;"	d
EV_INT32_MIN	include/event2/util.h	223;"	d
EV_INT64_MAX	include/event2/util.h	219;"	d
EV_INT64_MIN	include/event2/util.h	220;"	d
EV_INT8_MAX	include/event2/util.h	228;"	d
EV_INT8_MIN	include/event2/util.h	229;"	d
EV_LIB_GDI	Makefile	/^EV_LIB_GDI = $/;"	m
EV_LIB_GDI	include/Makefile	/^EV_LIB_GDI = $/;"	m
EV_LIB_GDI	sample/Makefile	/^EV_LIB_GDI = $/;"	m
EV_LIB_GDI	test/Makefile	/^EV_LIB_GDI = $/;"	m
EV_LIB_WS32	Makefile	/^EV_LIB_WS32 = $/;"	m
EV_LIB_WS32	include/Makefile	/^EV_LIB_WS32 = $/;"	m
EV_LIB_WS32	sample/Makefile	/^EV_LIB_WS32 = $/;"	m
EV_LIB_WS32	test/Makefile	/^EV_LIB_WS32 = $/;"	m
EV_NORETURN	log-internal.h	34;"	d
EV_NORETURN	log-internal.h	37;"	d
EV_PERSIST	include/event2/event.h	744;"	d
EV_RATE_LIMIT_MAX	include/event2/bufferevent.h	613;"	d
EV_READ	include/event2/event.h	733;"	d
EV_SIGNAL	include/event2/event.h	737;"	d
EV_SIZE_ARG	util-internal.h	304;"	d
EV_SIZE_ARG	util-internal.h	313;"	d
EV_SIZE_ARG	util-internal.h	318;"	d
EV_SIZE_FMT	util-internal.h	302;"	d
EV_SIZE_FMT	util-internal.h	311;"	d
EV_SIZE_FMT	util-internal.h	316;"	d
EV_SIZE_MAX	include/event2/util.h	238;"	d
EV_SIZE_MAX	include/event2/util.h	241;"	d
EV_SIZE_MAX	include/event2/util.h	244;"	d
EV_SOCK_ARG	util-internal.h	294;"	d
EV_SOCK_ARG	util-internal.h	297;"	d
EV_SOCK_FMT	util-internal.h	293;"	d
EV_SOCK_FMT	util-internal.h	296;"	d
EV_SSIZE_ARG	util-internal.h	305;"	d
EV_SSIZE_ARG	util-internal.h	314;"	d
EV_SSIZE_ARG	util-internal.h	319;"	d
EV_SSIZE_FMT	util-internal.h	303;"	d
EV_SSIZE_FMT	util-internal.h	312;"	d
EV_SSIZE_FMT	util-internal.h	317;"	d
EV_SSIZE_MAX	include/event2/util.h	239;"	d
EV_SSIZE_MAX	include/event2/util.h	242;"	d
EV_SSIZE_MAX	include/event2/util.h	245;"	d
EV_SSIZE_MIN	include/event2/util.h	250;"	d
EV_TIMEOUT	include/event2/event.h	731;"	d
EV_U64_ARG	util-internal.h	283;"	d
EV_U64_ARG	util-internal.h	288;"	d
EV_U64_FMT	util-internal.h	280;"	d
EV_U64_FMT	util-internal.h	285;"	d
EV_UINT16_MAX	include/event2/util.h	224;"	d
EV_UINT32_MAX	include/event2/util.h	221;"	d
EV_UINT64_MAX	include/event2/util.h	218;"	d
EV_UINT8_MAX	include/event2/util.h	227;"	d
EV_WRITE	include/event2/event.h	735;"	d
EXEEXT	Makefile	/^EXEEXT = $/;"	m
EXEEXT	include/Makefile	/^EXEEXT = $/;"	m
EXEEXT	sample/Makefile	/^EXEEXT = $/;"	m
EXEEXT	test/Makefile	/^EXEEXT = $/;"	m
EXTRA_DIST	Makefile	/^EXTRA_DIST = \\$/;"	m
EXTRA_DIST	test/Makefile	/^EXTRA_DIST = regress.rpc regress.gen.h regress.gen.c rpcgen_wrapper.sh test.sh$/;"	m
EXTRA_PROGRAMS	test/Makefile	/^EXTRA_PROGRAMS = regress$(EXEEXT)$/;"	m
EXTRA_SRC	Makefile	/^EXTRA_SRC = event_tagging.c http.c evdns.c evrpc.c$/;"	m
EXTRA_SRC	include/Makefile	/^EXTRA_SRC = $(EVENT2_EXPORT)$/;"	m
Entry	event_rpcgen.py	/^class Entry:$/;"	c	inherits:
EntryArray	event_rpcgen.py	/^    def EntryArray(self, entry):$/;"	m	class:CCodeGenerator	access:public
EntryArray	event_rpcgen.py	/^class EntryArray(Entry):$/;"	c	inherits:Entry
EntryBytes	event_rpcgen.py	/^    def EntryBytes(self, entry_type, name, tag, fixed_length):$/;"	m	class:CCodeGenerator	access:public
EntryBytes	event_rpcgen.py	/^class EntryBytes(Entry):$/;"	c	inherits:Entry
EntryInt	event_rpcgen.py	/^    def EntryInt(self, entry_type, name, tag, bits=32):$/;"	m	class:CCodeGenerator	access:public
EntryInt	event_rpcgen.py	/^class EntryInt(Entry):$/;"	c	inherits:Entry
EntryString	event_rpcgen.py	/^    def EntryString(self, entry_type, name, tag):$/;"	m	class:CCodeGenerator	access:public
EntryString	event_rpcgen.py	/^class EntryString(Entry):$/;"	c	inherits:Entry
EntryStruct	event_rpcgen.py	/^    def EntryStruct(self, entry_type, name, tag, struct_name):$/;"	m	class:CCodeGenerator	access:public
EntryStruct	event_rpcgen.py	/^class EntryStruct(Entry):$/;"	c	inherits:Entry
EntryTagName	event_rpcgen.py	/^    def EntryTagName(self, entry):$/;"	m	class:Struct	access:public
EntryVarBytes	event_rpcgen.py	/^    def EntryVarBytes(self, entry_type, name, tag):$/;"	m	class:CCodeGenerator	access:public
EntryVarBytes	event_rpcgen.py	/^class EntryVarBytes(Entry):$/;"	c	inherits:Entry
FAIL	test/tinytest.c	/^enum outcome { SKIP=2, OK=1, FAIL=0 };$/;"	e	enum:outcome	file:
FDINFO_OFFSET	evmap.c	184;"	d	file:
FDI_HAS_EVENTS	evport.c	104;"	d	file:
FDI_HAS_READ	evport.c	102;"	d	file:
FDI_HAS_WRITE	evport.c	103;"	d	file:
FDI_TO_SYSEVENTS	evport.c	105;"	d	file:
FD_SET_ALLOC_SIZE	win32select.c	97;"	d	file:
FGREP	Makefile	/^FGREP = \/bin\/grep -F$/;"	m
FGREP	include/Makefile	/^FGREP = \/bin\/grep -F$/;"	m
FGREP	sample/Makefile	/^FGREP = \/bin\/grep -F$/;"	m
FGREP	test/Makefile	/^FGREP = \/bin\/grep -F$/;"	m
FOREACH_RANDOM_ORDER	bufferevent_ratelim.c	473;"	d	file:
FORK_BREAKS_GCOV	test/regress_main.c	38;"	d	file:
FORK_BREAKS_GCOV	test/tinytest.c	47;"	d	file:
FREEZE_EQ	test/regress_buffer.c	1572;"	d	file:
GAIC_MAGIC	test/regress_dns.c	1577;"	d	file:
GENERIC_LDFLAGS	Makefile	/^GENERIC_LDFLAGS = -version-info $(VERSION_INFO) $(RELEASE) $(NO_UNDEFINED)$/;"	m
GET16	evdns.c	1287;"	d	file:
GET16	evdns.c	949;"	d	file:
GET32	evdns.c	1286;"	d	file:
GET32	evdns.c	948;"	d	file:
GET8	evdns.c	1288;"	d	file:
GET8	evdns.c	950;"	d	file:
GET_IO_SLOT	evmap.c	111;"	d	file:
GET_IO_SLOT	evmap.c	181;"	d	file:
GET_IO_SLOT_AND_CTOR	evmap.c	119;"	d	file:
GET_IO_SLOT_AND_CTOR	evmap.c	182;"	d	file:
GET_SIGNAL_SLOT	evmap.c	159;"	d	file:
GET_SIGNAL_SLOT_AND_CTOR	evmap.c	166;"	d	file:
GLOBAL	evthread.c	42;"	d	file:
GLOBAL	evthread.c	44;"	d	file:
GREP	Makefile	/^GREP = \/bin\/grep$/;"	m
GREP	include/Makefile	/^GREP = \/bin\/grep$/;"	m
GREP	sample/Makefile	/^GREP = \/bin\/grep$/;"	m
GREP	test/Makefile	/^GREP = \/bin\/grep$/;"	m
GROUP_SUSPENDED	bufferevent_ratelim.c	208;"	d	file:
GZIP_ENV	Makefile	/^GZIP_ENV = --best$/;"	m
GetAcceptExSockaddrs	iocp-internal.h	/^	GetAcceptExSockaddrsPtr GetAcceptExSockaddrs;$/;"	m	struct:win32_extension_fns	access:public
GetAcceptExSockaddrsPtr	iocp-internal.h	/^typedef void (WINAPI *GetAcceptExSockaddrsPtr)(PVOID, DWORD, DWORD, DWORD, LPSOCKADDR *, LPINT, LPSOCKADDR *, LPINT);$/;"	t
GetDeclaration	event_rpcgen.py	/^    def GetDeclaration(self, funcname):$/;"	m	class:Entry	access:public
GetDeclaration	event_rpcgen.py	/^    def GetDeclaration(self, funcname):$/;"	m	class:EntryArray	access:public
GetDeclaration	event_rpcgen.py	/^    def GetDeclaration(self, funcname):$/;"	m	class:EntryBytes	access:public
GetDeclaration	event_rpcgen.py	/^    def GetDeclaration(self, funcname):$/;"	m	class:EntryVarBytes	access:public
GetFuncName	event_rpcgen.py	/^    def GetFuncName(self):$/;"	m	class:Entry	access:public
GetInitializer	event_rpcgen.py	/^    def GetInitializer(self):$/;"	m	class:Entry	access:public
GetInitializer	event_rpcgen.py	/^    def GetInitializer(self):$/;"	m	class:EntryArray	access:public
GetInitializer	event_rpcgen.py	/^    def GetInitializer(self):$/;"	m	class:EntryBytes	access:public
GetInitializer	event_rpcgen.py	/^    def GetInitializer(self):$/;"	m	class:EntryInt	access:public
GetInitializer	event_rpcgen.py	/^    def GetInitializer(self):$/;"	m	class:EntryString	access:public
GetInitializer	event_rpcgen.py	/^    def GetInitializer(self):$/;"	m	class:EntryStruct	access:public
GetInitializer	event_rpcgen.py	/^    def GetInitializer(self):$/;"	m	class:EntryVarBytes	access:public
GetNetworkParams_fn_t	evdns.c	/^typedef DWORD(WINAPI *GetNetworkParams_fn_t)(FIXED_INFO *, DWORD*);$/;"	t	file:
GetNextStruct	event_rpcgen.py	/^def GetNextStruct(file):$/;"	f	access:public
GetTranslation	event_rpcgen.py	/^    def GetTranslation(self, extradict = {}):$/;"	m	class:Entry	access:public
GetVarLen	event_rpcgen.py	/^    def GetVarLen(self, var):$/;"	m	class:Entry	access:public
GetVarLen	event_rpcgen.py	/^    def GetVarLen(self, var):$/;"	m	class:EntryBytes	access:public
GetVarLen	event_rpcgen.py	/^    def GetVarLen(self, var):$/;"	m	class:EntryString	access:public
GetVarLen	event_rpcgen.py	/^    def GetVarLen(self, var):$/;"	m	class:EntryStruct	access:public
GetVarLen	event_rpcgen.py	/^    def GetVarLen(self, var):$/;"	m	class:EntryVarBytes	access:public
GetVarLen	event_rpcgen.py	/^    def GetVarLen(self, var_name):$/;"	m	class:EntryArray	access:public
GetVarName	event_rpcgen.py	/^        def GetVarName(var_name):$/;"	f	function:EntryArray.__init__	access:public
GetVarName	event_rpcgen.py	/^    def GetVarName(self, var):$/;"	m	class:Entry	access:public
GetVarName	event_rpcgen.py	/^    def GetVarName(self, var_name):$/;"	m	class:EntryArray	access:public
GotErrorCb	test/regress_rpc.c	/^GotErrorCb(struct evrpc_status *status,$/;"	f	file:	signature:(struct evrpc_status *status, struct msg *msg, struct kill *kill, void *arg)
GotKillCb	test/regress_rpc.c	/^GotKillCb(struct evrpc_status *status,$/;"	f	file:	signature:(struct evrpc_status *status, struct msg *msg, struct kill *kill, void *arg)
GotKillCbTwo	test/regress_rpc.c	/^GotKillCbTwo(struct evrpc_status *status,$/;"	f	file:	signature:(struct evrpc_status *status, struct msg *msg, struct kill *kill, void *arg)
GuardName	event_rpcgen.py	/^    def GuardName(self, name):$/;"	m	class:CCodeGenerator	access:public
HAS_PINNED_R	buffer.c	/^HAS_PINNED_R(struct evbuffer *buf)$/;"	f	file:	signature:(struct evbuffer *buf)
HAVE_ARPA_INET_H	config.h	20;"	d
HAVE_CLOCK_GETTIME	config.h	23;"	d
HAVE_DECL_CTL_KERN	config.h	27;"	d
HAVE_DECL_KERN_ARND	config.h	31;"	d
HAVE_DECL_KERN_RANDOM	config.h	35;"	d
HAVE_DECL_RANDOM_UUID	config.h	39;"	d
HAVE_DLFCN_H	config.h	45;"	d
HAVE_EPOLL	config.h	48;"	d
HAVE_EPOLL_CTL	config.h	51;"	d
HAVE_EVENTFD	config.h	54;"	d
HAVE_FCNTL	config.h	60;"	d
HAVE_FCNTL_H	config.h	63;"	d
HAVE_FD_MASK	config.h	66;"	d
HAVE_GETADDRINFO	config.h	69;"	d
HAVE_GETEGID	config.h	72;"	d
HAVE_GETEUID	config.h	75;"	d
HAVE_GETNAMEINFO	config.h	90;"	d
HAVE_GETPROTOBYNUMBER	config.h	93;"	d
HAVE_GETTIMEOFDAY	config.h	99;"	d
HAVE_INET_ATON	config.h	102;"	d
HAVE_INET_NTOP	config.h	105;"	d
HAVE_INET_PTON	config.h	108;"	d
HAVE_INTTYPES_H	config.h	111;"	d
HAVE_MEMORY_H	config.h	123;"	d
HAVE_MMAP	config.h	126;"	d
HAVE_NETDB_H	config.h	129;"	d
HAVE_NETINET_IN_H	config.h	135;"	d
HAVE_PIPE	config.h	144;"	d
HAVE_POLL	config.h	147;"	d
HAVE_POLL_H	config.h	150;"	d
HAVE_PTHREADS	config.h	162;"	d
HAVE_PUTENV	config.h	165;"	d
HAVE_SA_FAMILY_T	config.h	168;"	d
HAVE_SELECT	config.h	171;"	d
HAVE_SENDFILE	config.h	174;"	d
HAVE_SETENV	config.h	177;"	d
HAVE_SETFD	config.h	180;"	d
HAVE_SIGACTION	config.h	183;"	d
HAVE_SIGNAL	config.h	186;"	d
HAVE_SPLICE	config.h	189;"	d
HAVE_STDARG_H	config.h	192;"	d
HAVE_STDDEF_H	config.h	195;"	d
HAVE_STDINT_H	config.h	198;"	d
HAVE_STDLIB_H	config.h	201;"	d
HAVE_STRINGS_H	config.h	204;"	d
HAVE_STRING_H	config.h	207;"	d
HAVE_STRSEP	config.h	213;"	d
HAVE_STRTOK_R	config.h	216;"	d
HAVE_STRTOLL	config.h	219;"	d
HAVE_STRUCT_ADDRINFO	config.h	222;"	d
HAVE_STRUCT_IN6_ADDR	config.h	225;"	d
HAVE_STRUCT_IN6_ADDR_S6_ADDR16	config.h	228;"	d
HAVE_STRUCT_IN6_ADDR_S6_ADDR32	config.h	231;"	d
HAVE_STRUCT_SOCKADDR_IN6	config.h	234;"	d
HAVE_STRUCT_SOCKADDR_STORAGE	config.h	243;"	d
HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY	config.h	246;"	d
HAVE_SYSCTL	config.h	252;"	d
HAVE_SYS_EPOLL_H	config.h	258;"	d
HAVE_SYS_EVENTFD_H	config.h	261;"	d
HAVE_SYS_IOCTL_H	config.h	267;"	d
HAVE_SYS_MMAN_H	config.h	270;"	d
HAVE_SYS_PARAM_H	config.h	273;"	d
HAVE_SYS_QUEUE_H	config.h	276;"	d
HAVE_SYS_SELECT_H	config.h	279;"	d
HAVE_SYS_SENDFILE_H	config.h	282;"	d
HAVE_SYS_SOCKET_H	config.h	285;"	d
HAVE_SYS_STAT_H	config.h	288;"	d
HAVE_SYS_SYSCTL_H	config.h	291;"	d
HAVE_SYS_TIME_H	config.h	294;"	d
HAVE_SYS_TYPES_H	config.h	297;"	d
HAVE_SYS_UIO_H	config.h	300;"	d
HAVE_SYS_WAIT_H	config.h	303;"	d
HAVE_TAILQFOREACH	config.h	306;"	d
HAVE_TIMERADD	config.h	309;"	d
HAVE_TIMERCLEAR	config.h	312;"	d
HAVE_TIMERCMP	config.h	315;"	d
HAVE_TIMERISSET	config.h	318;"	d
HAVE_UINT16_T	config.h	321;"	d
HAVE_UINT32_T	config.h	324;"	d
HAVE_UINT64_T	config.h	327;"	d
HAVE_UINT8_T	config.h	330;"	d
HAVE_UINTPTR_T	config.h	333;"	d
HAVE_UMASK	config.h	336;"	d
HAVE_UNISTD_H	config.h	339;"	d
HAVE_UNSETENV	config.h	342;"	d
HAVE_VASPRINTF	config.h	345;"	d
HEADERS	Makefile	/^HEADERS = $(include_HEADERS) $(noinst_HEADERS)$/;"	m
HEADERS	include/Makefile	/^HEADERS = $(nobase_include_HEADERS) $(nobase_nodist_include_HEADERS) \\$/;"	m
HEADERS	test/Makefile	/^HEADERS = $(noinst_HEADERS)$/;"	m
HOST_NAME_MAX	evdns.c	125;"	d	file:
HTTP	test/regress_http.c	3580;"	d	file:
HTTP_BADMETHOD	include/event2/http.h	60;"	d
HTTP_BADREQUEST	include/event2/http.h	58;"	d
HTTP_CONNECT_TIMEOUT	http-internal.h	17;"	d
HTTP_DEFAULTPORT	http-internal.h	22;"	d
HTTP_ENTITYTOOLARGE	include/event2/http.h	61;"	d
HTTP_EXPECTATIONFAILED	include/event2/http.h	62;"	d
HTTP_INTERNAL	include/event2/http.h	63;"	d
HTTP_LEGACY	test/regress_http.c	3576;"	d	file:
HTTP_MOVEPERM	include/event2/http.h	55;"	d
HTTP_MOVETEMP	include/event2/http.h	56;"	d
HTTP_NOCONTENT	include/event2/http.h	54;"	d
HTTP_NOTFOUND	include/event2/http.h	59;"	d
HTTP_NOTIMPLEMENTED	include/event2/http.h	64;"	d
HTTP_NOTMODIFIED	include/event2/http.h	57;"	d
HTTP_OK	include/event2/http.h	53;"	d
HTTP_PREFIX	http-internal.h	21;"	d
HTTP_READ_TIMEOUT	http-internal.h	19;"	d
HTTP_SERVUNAVAIL	include/event2/http.h	65;"	d
HTTP_WRITE_TIMEOUT	http-internal.h	18;"	d
HT_CLEAR	ht-internal.h	55;"	d
HT_EMPTY	ht-internal.h	41;"	d
HT_ENTRY	event.c	/^	HT_ENTRY(event_debug_entry) node;$/;"	p	struct:event_debug_entry	file:	access:public
HT_ENTRY	evmap.c	/^	HT_ENTRY(event_map_entry) map_node;$/;"	p	struct:event_map_entry	file:	access:public
HT_ENTRY	ht-internal.h	29;"	d
HT_ENTRY	ht-internal.h	35;"	d
HT_FIND	ht-internal.h	48;"	d
HT_FOREACH	ht-internal.h	120;"	d
HT_GENERATE	ht-internal.h	296;"	d
HT_HEAD	event.c	/^static HT_HEAD(event_debug_map, event_debug_entry) global_debug_map =$/;"	p	file:
HT_HEAD	ht-internal.h	11;"	d
HT_INIT	ht-internal.h	56;"	d
HT_INITIALIZER	ht-internal.h	25;"	d
HT_INSERT	ht-internal.h	49;"	d
HT_NEXT	ht-internal.h	53;"	d
HT_NEXT_RMV	ht-internal.h	54;"	d
HT_PROTOTYPE	evmap.c	/^HT_PROTOTYPE(event_io_map, event_map_entry, map_node, hashsocket, eqsocket)$/;"	f
HT_PROTOTYPE	ht-internal.h	125;"	d
HT_REMOVE	ht-internal.h	51;"	d
HT_REPLACE	ht-internal.h	50;"	d
HT_SIZE	ht-internal.h	45;"	d
HT_START	ht-internal.h	52;"	d
HeaderFilename	event_rpcgen.py	/^    def HeaderFilename(self, filename):$/;"	m	class:CCodeGenerator	access:public
HeaderPostamble	event_rpcgen.py	/^    def HeaderPostamble(self, name):$/;"	m	class:CCodeGenerator	access:public
HeaderPreamble	event_rpcgen.py	/^    def HeaderPreamble(self, name):$/;"	m	class:CCodeGenerator	access:public
I64_FMT	test/bench_httpclient.c	206;"	d	file:
I64_TYP	test/bench_httpclient.c	207;"	d	file:
IMPL_CTYPE_FN	evutil.c	/^IMPL_CTYPE_FN(ISALPHA)$/;"	f
IMPL_CTYPE_FN	evutil.c	2021;"	d	file:
INITIAL_NEVENT	epoll.c	96;"	d	file:
INPUT	include/event2/rpc.h	460;"	d
INSTALL	Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL	include/Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL	sample/Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL	test/Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL_DATA	Makefile	/^INSTALL_DATA = ${INSTALL} -m 644$/;"	m
INSTALL_DATA	include/Makefile	/^INSTALL_DATA = ${INSTALL} -m 644$/;"	m
INSTALL_DATA	sample/Makefile	/^INSTALL_DATA = ${INSTALL} -m 644$/;"	m
INSTALL_DATA	test/Makefile	/^INSTALL_DATA = ${INSTALL} -m 644$/;"	m
INSTALL_HEADER	Makefile	/^INSTALL_HEADER = $(INSTALL_DATA)$/;"	m
INSTALL_HEADER	include/Makefile	/^INSTALL_HEADER = $(INSTALL_DATA)$/;"	m
INSTALL_HEADER	sample/Makefile	/^INSTALL_HEADER = $(INSTALL_DATA)$/;"	m
INSTALL_HEADER	test/Makefile	/^INSTALL_HEADER = $(INSTALL_DATA)$/;"	m
INSTALL_PROGRAM	Makefile	/^INSTALL_PROGRAM = ${INSTALL}$/;"	m
INSTALL_PROGRAM	include/Makefile	/^INSTALL_PROGRAM = ${INSTALL}$/;"	m
INSTALL_PROGRAM	sample/Makefile	/^INSTALL_PROGRAM = ${INSTALL}$/;"	m
INSTALL_PROGRAM	test/Makefile	/^INSTALL_PROGRAM = ${INSTALL}$/;"	m
INSTALL_SCRIPT	Makefile	/^INSTALL_SCRIPT = ${INSTALL}$/;"	m
INSTALL_SCRIPT	include/Makefile	/^INSTALL_SCRIPT = ${INSTALL}$/;"	m
INSTALL_SCRIPT	sample/Makefile	/^INSTALL_SCRIPT = ${INSTALL}$/;"	m
INSTALL_SCRIPT	test/Makefile	/^INSTALL_SCRIPT = ${INSTALL}$/;"	m
INSTALL_STRIP_PROGRAM	Makefile	/^INSTALL_STRIP_PROGRAM = $(install_sh) -c -s$/;"	m
INSTALL_STRIP_PROGRAM	include/Makefile	/^INSTALL_STRIP_PROGRAM = $(install_sh) -c -s$/;"	m
INSTALL_STRIP_PROGRAM	sample/Makefile	/^INSTALL_STRIP_PROGRAM = $(install_sh) -c -s$/;"	m
INSTALL_STRIP_PROGRAM	test/Makefile	/^INSTALL_STRIP_PROGRAM = $(install_sh) -c -s$/;"	m
INT_TO_UDATA	kqueue.c	54;"	d	file:
INT_TO_UDATA	kqueue.c	57;"	d	file:
IOV_LEN_FIELD	buffer.c	2004;"	d	file:
IOV_LEN_FIELD	buffer.c	2010;"	d	file:
IOV_LEN_TYPE	buffer.c	2005;"	d	file:
IOV_LEN_TYPE	buffer.c	2011;"	d	file:
IOV_PTR_FIELD	buffer.c	2003;"	d	file:
IOV_PTR_FIELD	buffer.c	2009;"	d	file:
IOV_TYPE	buffer.c	2002;"	d	file:
IOV_TYPE	buffer.c	2008;"	d	file:
InitializeConditionVariable_fn	evthread_win32.c	/^static void WINAPI (*InitializeConditionVariable_fn)(PCONDITION_VARIABLE)$/;"	v	file:
KEY	test/regress_ssl.c	/^static const char KEY[] =$/;"	v	file:
LD	Makefile	/^LD = \/usr\/bin\/ld$/;"	m
LD	include/Makefile	/^LD = \/usr\/bin\/ld$/;"	m
LD	sample/Makefile	/^LD = \/usr\/bin\/ld$/;"	m
LD	test/Makefile	/^LD = \/usr\/bin\/ld$/;"	m
LDADD	sample/Makefile	/^LDADD = $(LIBEVENT_GC_SECTIONS) ..\/libevent.la$/;"	m
LDFLAGS	Makefile	/^LDFLAGS = $/;"	m
LDFLAGS	include/Makefile	/^LDFLAGS = $/;"	m
LDFLAGS	sample/Makefile	/^LDFLAGS = $/;"	m
LDFLAGS	test/Makefile	/^LDFLAGS = $/;"	m
LEGACY	test/regress.h	98;"	d
LEV_OPT_CLOSE_ON_EXEC	include/event2/listener.h	65;"	d
LEV_OPT_CLOSE_ON_FREE	include/event2/listener.h	63;"	d
LEV_OPT_LEAVE_SOCKETS_BLOCKING	include/event2/listener.h	60;"	d
LEV_OPT_REUSEABLE	include/event2/listener.h	68;"	d
LEV_OPT_THREADSAFE	include/event2/listener.h	71;"	d
LIBEVENT_GC_SECTIONS	Makefile	/^LIBEVENT_GC_SECTIONS = $/;"	m
LIBEVENT_GC_SECTIONS	include/Makefile	/^LIBEVENT_GC_SECTIONS = $/;"	m
LIBEVENT_GC_SECTIONS	sample/Makefile	/^LIBEVENT_GC_SECTIONS = $/;"	m
LIBEVENT_GC_SECTIONS	test/Makefile	/^LIBEVENT_GC_SECTIONS = $/;"	m
LIBEVENT_LIBS_LA	Makefile	/^LIBEVENT_LIBS_LA = libevent.la libevent_core.la libevent_extra.la \\$/;"	m
LIBEVENT_PKGCONFIG	Makefile	/^LIBEVENT_PKGCONFIG = libevent.pc $(am__append_2) $(am__append_4)$/;"	m
LIBEVENT_VERSION	include/event2/event.h	1084;"	d
LIBEVENT_VERSION_NUMBER	include/event2/event.h	1087;"	d
LIBOBJS	Makefile	/^LIBOBJS = $/;"	m
LIBOBJS	include/Makefile	/^LIBOBJS = $/;"	m
LIBOBJS	sample/Makefile	/^LIBOBJS = $/;"	m
LIBOBJS	test/Makefile	/^LIBOBJS = $/;"	m
LIBS	Makefile	/^LIBS = -lrt $/;"	m
LIBS	include/Makefile	/^LIBS = -lrt $/;"	m
LIBS	sample/Makefile	/^LIBS = -lrt $/;"	m
LIBS	test/Makefile	/^LIBS = -lrt $/;"	m
LIBTOOL	Makefile	/^LIBTOOL = $(SHELL) $(top_builddir)\/libtool$/;"	m
LIBTOOL	include/Makefile	/^LIBTOOL = $(SHELL) $(top_builddir)\/libtool$/;"	m
LIBTOOL	sample/Makefile	/^LIBTOOL = $(SHELL) $(top_builddir)\/libtool$/;"	m
LIBTOOL	test/Makefile	/^LIBTOOL = $(SHELL) $(top_builddir)\/libtool$/;"	m
LIBTOOL_DEPS	Makefile	/^LIBTOOL_DEPS = .\/ltmain.sh$/;"	m
LIBTOOL_DEPS	include/Makefile	/^LIBTOOL_DEPS = .\/ltmain.sh$/;"	m
LIBTOOL_DEPS	sample/Makefile	/^LIBTOOL_DEPS = .\/ltmain.sh$/;"	m
LIBTOOL_DEPS	test/Makefile	/^LIBTOOL_DEPS = .\/ltmain.sh$/;"	m
LIM	bufferevent_ratelim.c	205;"	d	file:
LINK	Makefile	/^LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
LINK	sample/Makefile	/^LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
LINK	test/Makefile	/^LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
LIPO	Makefile	/^LIPO = $/;"	m
LIPO	include/Makefile	/^LIPO = $/;"	m
LIPO	sample/Makefile	/^LIPO = $/;"	m
LIPO	test/Makefile	/^LIPO = $/;"	m
LIST_EMPTY	compat/sys/queue.h	159;"	d
LIST_END	compat/sys/queue.h	158;"	d
LIST_ENTRY	compat/sys/queue.h	148;"	d
LIST_FIRST	compat/sys/queue.h	157;"	d
LIST_FOREACH	compat/sys/queue.h	162;"	d
LIST_HEAD	compat/sys/queue.h	140;"	d
LIST_HEAD_INITIALIZER	compat/sys/queue.h	145;"	d
LIST_INIT	compat/sys/queue.h	170;"	d
LIST_INSERT_AFTER	compat/sys/queue.h	174;"	d
LIST_INSERT_BEFORE	compat/sys/queue.h	182;"	d
LIST_INSERT_HEAD	compat/sys/queue.h	189;"	d
LIST_NEXT	compat/sys/queue.h	160;"	d
LIST_REMOVE	compat/sys/queue.h	196;"	d
LIST_REPLACE	compat/sys/queue.h	203;"	d
LN_S	Makefile	/^LN_S = ln -s$/;"	m
LN_S	include/Makefile	/^LN_S = ln -s$/;"	m
LN_S	sample/Makefile	/^LN_S = ln -s$/;"	m
LN_S	test/Makefile	/^LN_S = ln -s$/;"	m
LOAD	evthread_win32.c	112;"	d	file:
LOCAL_SOCKETPAIR_AF	event.c	2804;"	d	file:
LOCAL_SOCKETPAIR_AF	test/regress.c	418;"	d	file:
LOCAL_SOCKETPAIR_AF	test/regress_et.c	75;"	d	file:
LOCAL_SOCKETPAIR_AF	test/regress_et.c	77;"	d	file:
LOCK	listener.c	103;"	d	file:
LOCK_DEFERRED_QUEUE	defer-internal.h	87;"	d
LOCK_GROUP	bufferevent_ratelim.c	187;"	d	file:
LOGEQ	test/regress_util.c	524;"	d	file:
LOGEQ	test/regress_util.c	594;"	d	file:
LONGEST_TEST_NAME	test/tinytest.c	59;"	d	file:
LTCOMPILE	Makefile	/^LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
LTCOMPILE	sample/Makefile	/^LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
LTCOMPILE	test/Makefile	/^LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
LTLIBOBJS	Makefile	/^LTLIBOBJS = $/;"	m
LTLIBOBJS	include/Makefile	/^LTLIBOBJS = $/;"	m
LTLIBOBJS	sample/Makefile	/^LTLIBOBJS = $/;"	m
LTLIBOBJS	test/Makefile	/^LTLIBOBJS = $/;"	m
LTLIBRARIES	Makefile	/^LTLIBRARIES = $(lib_LTLIBRARIES) $(noinst_LTLIBRARIES)$/;"	m
LT_OBJDIR	config.h	355;"	d
LineCount	event_rpcgen.py	/^    def LineCount(self):$/;"	m	class:Entry	access:public
MAGIC_EXITCODE	test/tinytest.c	110;"	d	file:
MAKEINFO	Makefile	/^MAKEINFO = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run makeinfo$/;"	m
MAKEINFO	include/Makefile	/^MAKEINFO = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run makeinfo$/;"	m
MAKEINFO	sample/Makefile	/^MAKEINFO = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run makeinfo$/;"	m
MAKEINFO	test/Makefile	/^MAKEINFO = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/missing --run makeinfo$/;"	m
MANIFEST_TOOL	Makefile	/^MANIFEST_TOOL = :$/;"	m
MANIFEST_TOOL	include/Makefile	/^MANIFEST_TOOL = :$/;"	m
MANIFEST_TOOL	sample/Makefile	/^MANIFEST_TOOL = :$/;"	m
MANIFEST_TOOL	test/Makefile	/^MANIFEST_TOOL = :$/;"	m
MANY	test/regress.c	2343;"	d	file:
MANY	test/regress.c	2397;"	d	file:
MAP_FAILED	buffer.c	96;"	d	file:
MAX_CALLS	test/regress_iocp.c	56;"	d	file:
MAX_COMMON_TIMEOUTS	event.c	1179;"	d	file:
MAX_DEFERRED	event.c	1402;"	d	file:
MAX_DEFERRED	event.c	1417;"	d	file:
MAX_EPOLL_TIMEOUT_MSEC	epoll.c	105;"	d	file:
MAX_LABELS	evdns.c	1517;"	d	file:
MAX_NEVENT	epoll.c	97;"	d	file:
MAX_OUTPUT	sample/le-proxy.c	40;"	d	file:
MAX_PROBE_TIMEOUT	evdns.c	524;"	d	file:
MAX_SECONDS_IN_MSEC_LONG	evutil.c	2139;"	d	file:
MAX_TO_COPY_IN_EXPAND	buffer.c	1728;"	d	file:
MAX_TO_READ_EVER	bufferevent_ratelim.c	182;"	d	file:
MAX_TO_REALIGN_IN_EXPAND	buffer.c	1729;"	d	file:
MAX_TO_WRITE_EVER	bufferevent_ratelim.c	185;"	d	file:
MAX_V4_ADDRS	evdns.c	143;"	d	file:
MAX_V6_ADDRS	evdns.c	144;"	d	file:
MAX_WSABUFS	buffer_iocp.c	49;"	d	file:
MAYBE_CORE	Makefile	/^MAYBE_CORE = $/;"	m
MEMBERSOF	http.c	2581;"	d	file:
MESSAGE	sample/hello-world.c	/^static const char MESSAGE[] = "Hello, World!\\n";$/;"	v	file:
MICROSECONDS_MASK	event.c	1092;"	d	file:
MIN	evdns.c	130;"	d	file:
MIN	evdns.c	131;"	d	file:
MIN	http.c	165;"	d	file:
MIN_BUFFER_SIZE	evbuffer-internal.h	53;"	d
MIN_BUFFER_SIZE	evbuffer-internal.h	55;"	d
MKDIR_P	Makefile	/^MKDIR_P = \/bin\/mkdir -p$/;"	m
MKDIR_P	include/Makefile	/^MKDIR_P = \/bin\/mkdir -p$/;"	m
MKDIR_P	sample/Makefile	/^MKDIR_P = \/bin\/mkdir -p$/;"	m
MKDIR_P	test/Makefile	/^MKDIR_P = \/bin\/mkdir -p$/;"	m
MORE_DATA_EXPECTED	http-internal.h	/^	MORE_DATA_EXPECTED = 0,$/;"	e	enum:message_read_status
MakeArray	event_rpcgen.py	/^    def MakeArray(self, yes=1):$/;"	m	class:Entry	access:public
MakeOptional	event_rpcgen.py	/^    def MakeOptional(self):$/;"	m	class:Entry	access:public
NCF	test/regress_http.c	2019;"	d	file:
NDEBUG	test/regress_bufferevent.c	29;"	d	file:
NDEBUG	test/regress_rpc.c	29;"	d	file:
NDEBUG	test/regress_thread.c	28;"	d	file:
NDEBUG	test/regress_zlib.c	28;"	d	file:
NEVENT	devpoll.c	79;"	d	file:
NEVENT	kqueue.c	67;"	d	file:
NEVENT	test/test-time.c	47;"	d	file:
NEVENT	win32select.c	175;"	d	file:
NEXT_TOKEN	evdns.c	3475;"	d	file:
NEXT_TOKEN	evdns.c	3508;"	d	file:
NEXT_TOKEN	evdns.c	4046;"	d	file:
NEXT_TOKEN	evdns.c	4086;"	d	file:
NFDBITS	select.c	59;"	d	file:
NI_MAXHOST	http.c	107;"	d	file:
NI_MAXSERV	http.c	106;"	d	file:
NI_MAXSERV	test/regress_http.c	126;"	d	file:
NI_NUMERICHOST	http.c	110;"	d	file:
NI_NUMERICSERV	http.c	114;"	d	file:
NM	Makefile	/^NM = \/usr\/bin\/nm -B$/;"	m
NM	include/Makefile	/^NM = \/usr\/bin\/nm -B$/;"	m
NM	sample/Makefile	/^NM = \/usr\/bin\/nm -B$/;"	m
NM	test/Makefile	/^NM = \/usr\/bin\/nm -B$/;"	m
NMEDIT	Makefile	/^NMEDIT = $/;"	m
NMEDIT	include/Makefile	/^NMEDIT = $/;"	m
NMEDIT	sample/Makefile	/^NMEDIT = $/;"	m
NMEDIT	test/Makefile	/^NMEDIT = $/;"	m
NORMAL	test/regress_util.c	/^enum entry_status { NORMAL, CANONICAL, BAD };$/;"	e	enum:entry_status	file:
NORMAL_INSTALL	Makefile	/^NORMAL_INSTALL = :$/;"	m
NORMAL_INSTALL	include/Makefile	/^NORMAL_INSTALL = :$/;"	m
NORMAL_INSTALL	sample/Makefile	/^NORMAL_INSTALL = :$/;"	m
NORMAL_INSTALL	test/Makefile	/^NORMAL_INSTALL = :$/;"	m
NORMAL_UNINSTALL	Makefile	/^NORMAL_UNINSTALL = :$/;"	m
NORMAL_UNINSTALL	include/Makefile	/^NORMAL_UNINSTALL = :$/;"	m
NORMAL_UNINSTALL	sample/Makefile	/^NORMAL_UNINSTALL = :$/;"	m
NORMAL_UNINSTALL	test/Makefile	/^NORMAL_UNINSTALL = :$/;"	m
NOTIFICATION_KEY	event_iocp.c	45;"	d	file:
NO_PYTHON_EXISTS	test/regress.gen.h	1;"	d
NO_UNDEFINED	Makefile	/^NO_UNDEFINED = $/;"	m
NUMERIC_VERSION	config.h	361;"	d
NUM_ERRORS	bufferevent_openssl.c	306;"	d	file:
NUM_ITERATIONS	test/regress_thread.c	109;"	d	file:
NUM_READ_IOVEC	buffer.c	2014;"	d	file:
NUM_THREADS	test/regress_thread.c	108;"	d	file:
NUM_THREADS	test/regress_thread.c	272;"	d	file:
NUM_THREADS	test/regress_thread.c	273;"	d	file:
NUM_WRITE_IOVEC	buffer.c	1995;"	d	file:
NUM_WRITE_IOVEC	buffer.c	1997;"	d	file:
NUM_WRITE_IOVEC	buffer.c	1999;"	d	file:
NUM_WRITE_IOVEC	buffer.c	2007;"	d	file:
N_ACTIVE_CALLBACKS	event-internal.h	341;"	d
N_CPUS_DEFAULT	event_iocp.c	172;"	d	file:
N_REQUESTS	test/bench_httpclient.c	/^const int N_REQUESTS = 20000;$/;"	v
N_SOCKETS_PER_LISTENER	listener.c	797;"	d	file:
N_TO_READ	evutil.c	160;"	d	file:
Name	event_rpcgen.py	/^    def Name(self):$/;"	m	class:Entry	access:public
Name	event_rpcgen.py	/^    def Name(self):$/;"	m	class:Struct	access:public
NormalizeLine	event_rpcgen.py	/^def NormalizeLine(line):$/;"	f	access:public
OBJDUMP	Makefile	/^OBJDUMP = objdump$/;"	m
OBJDUMP	include/Makefile	/^OBJDUMP = objdump$/;"	m
OBJDUMP	sample/Makefile	/^OBJDUMP = objdump$/;"	m
OBJDUMP	test/Makefile	/^OBJDUMP = objdump$/;"	m
OBJEXT	Makefile	/^OBJEXT = o$/;"	m
OBJEXT	include/Makefile	/^OBJEXT = o$/;"	m
OBJEXT	sample/Makefile	/^OBJEXT = o$/;"	m
OBJEXT	test/Makefile	/^OBJEXT = o$/;"	m
OK	test/tinytest.c	/^enum outcome { SKIP=2, OK=1, FAIL=0 };$/;"	e	enum:outcome	file:
OLD_DEC	test/regress_http.c	2402;"	d	file:
OLD_DEC	test/regress_http.c	2470;"	d	file:
OPENSSL_LIBADD	Makefile	/^OPENSSL_LIBADD = $/;"	m
OPENSSL_LIBADD	include/Makefile	/^OPENSSL_LIBADD = $/;"	m
OPENSSL_LIBADD	sample/Makefile	/^OPENSSL_LIBADD = $/;"	m
OPENSSL_LIBADD	test/Makefile	/^OPENSSL_LIBADD = $/;"	m
OPENSSL_LIBS	Makefile	/^OPENSSL_LIBS = $/;"	m
OPENSSL_LIBS	include/Makefile	/^OPENSSL_LIBS = $/;"	m
OPENSSL_LIBS	sample/Makefile	/^OPENSSL_LIBS = $/;"	m
OPENSSL_LIBS	test/Makefile	/^OPENSSL_LIBS = $/;"	m
OP_BLOCKED	bufferevent_openssl.c	560;"	d	file:
OP_ERR	bufferevent_openssl.c	561;"	d	file:
OP_MADE_PROGRESS	bufferevent_openssl.c	559;"	d	file:
OTOOL	Makefile	/^OTOOL = $/;"	m
OTOOL	include/Makefile	/^OTOOL = $/;"	m
OTOOL	sample/Makefile	/^OTOOL = $/;"	m
OTOOL	test/Makefile	/^OTOOL = $/;"	m
OTOOL64	Makefile	/^OTOOL64 = $/;"	m
OTOOL64	include/Makefile	/^OTOOL64 = $/;"	m
OTOOL64	sample/Makefile	/^OTOOL64 = $/;"	m
OTOOL64	test/Makefile	/^OTOOL64 = $/;"	m
OUTPUT	include/event2/rpc.h	463;"	d
O_RDONLY	sample/http-server.c	55;"	d	file:
Optional	event_rpcgen.py	/^    def Optional(self):$/;"	m	class:Entry	access:public
PACKAGE	Makefile	/^PACKAGE = libevent$/;"	m
PACKAGE	config.h	364;"	d
PACKAGE	include/Makefile	/^PACKAGE = libevent$/;"	m
PACKAGE	sample/Makefile	/^PACKAGE = libevent$/;"	m
PACKAGE	test/Makefile	/^PACKAGE = libevent$/;"	m
PACKAGE_BUGREPORT	Makefile	/^PACKAGE_BUGREPORT = $/;"	m
PACKAGE_BUGREPORT	config.h	367;"	d
PACKAGE_BUGREPORT	include/Makefile	/^PACKAGE_BUGREPORT = $/;"	m
PACKAGE_BUGREPORT	sample/Makefile	/^PACKAGE_BUGREPORT = $/;"	m
PACKAGE_BUGREPORT	test/Makefile	/^PACKAGE_BUGREPORT = $/;"	m
PACKAGE_NAME	Makefile	/^PACKAGE_NAME = $/;"	m
PACKAGE_NAME	config.h	370;"	d
PACKAGE_NAME	include/Makefile	/^PACKAGE_NAME = $/;"	m
PACKAGE_NAME	sample/Makefile	/^PACKAGE_NAME = $/;"	m
PACKAGE_NAME	test/Makefile	/^PACKAGE_NAME = $/;"	m
PACKAGE_STRING	Makefile	/^PACKAGE_STRING = $/;"	m
PACKAGE_STRING	config.h	373;"	d
PACKAGE_STRING	include/Makefile	/^PACKAGE_STRING = $/;"	m
PACKAGE_STRING	sample/Makefile	/^PACKAGE_STRING = $/;"	m
PACKAGE_STRING	test/Makefile	/^PACKAGE_STRING = $/;"	m
PACKAGE_TARNAME	Makefile	/^PACKAGE_TARNAME = $/;"	m
PACKAGE_TARNAME	config.h	376;"	d
PACKAGE_TARNAME	include/Makefile	/^PACKAGE_TARNAME = $/;"	m
PACKAGE_TARNAME	sample/Makefile	/^PACKAGE_TARNAME = $/;"	m
PACKAGE_TARNAME	test/Makefile	/^PACKAGE_TARNAME = $/;"	m
PACKAGE_URL	Makefile	/^PACKAGE_URL = $/;"	m
PACKAGE_URL	config.h	379;"	d
PACKAGE_URL	include/Makefile	/^PACKAGE_URL = $/;"	m
PACKAGE_URL	sample/Makefile	/^PACKAGE_URL = $/;"	m
PACKAGE_URL	test/Makefile	/^PACKAGE_URL = $/;"	m
PACKAGE_VERSION	Makefile	/^PACKAGE_VERSION = $/;"	m
PACKAGE_VERSION	config.h	382;"	d
PACKAGE_VERSION	include/Makefile	/^PACKAGE_VERSION = $/;"	m
PACKAGE_VERSION	sample/Makefile	/^PACKAGE_VERSION = $/;"	m
PACKAGE_VERSION	test/Makefile	/^PACKAGE_VERSION = $/;"	m
PARALLELISM	test/bench_httpclient.c	/^const int PARALLELISM = 200;$/;"	v
PART_FRAGMENT	http.c	/^	PART_FRAGMENT$/;"	e	enum:uri_part	file:
PART_PATH	http.c	/^	PART_PATH,$/;"	e	enum:uri_part	file:
PART_QUERY	http.c	/^	PART_QUERY,$/;"	e	enum:uri_part	file:
PATH_SEPARATOR	Makefile	/^PATH_SEPARATOR = :$/;"	m
PATH_SEPARATOR	include/Makefile	/^PATH_SEPARATOR = :$/;"	m
PATH_SEPARATOR	sample/Makefile	/^PATH_SEPARATOR = :$/;"	m
PATH_SEPARATOR	test/Makefile	/^PATH_SEPARATOR = :$/;"	m
PF_INET6	ipv6-internal.h	74;"	d
PLATFORM_DEPENDENT_SRC	Makefile	/^PLATFORM_DEPENDENT_SRC = \\$/;"	m
PORT	sample/hello-world.c	/^static const int PORT = 9995;$/;"	v	file:
POST_DATA	test/regress_http.c	1456;"	d	file:
POST_INSTALL	Makefile	/^POST_INSTALL = :$/;"	m
POST_INSTALL	include/Makefile	/^POST_INSTALL = :$/;"	m
POST_INSTALL	sample/Makefile	/^POST_INSTALL = :$/;"	m
POST_INSTALL	test/Makefile	/^POST_INSTALL = :$/;"	m
POST_UNINSTALL	Makefile	/^POST_UNINSTALL = :$/;"	m
POST_UNINSTALL	include/Makefile	/^POST_UNINSTALL = :$/;"	m
POST_UNINSTALL	sample/Makefile	/^POST_UNINSTALL = :$/;"	m
POST_UNINSTALL	test/Makefile	/^POST_UNINSTALL = :$/;"	m
PREPEND_CHAIN	buffer.c	/^PREPEND_CHAIN(struct evbuffer *dst, struct evbuffer *src)$/;"	f	file:	signature:(struct evbuffer *dst, struct evbuffer *src)
PRESERVE_PINNED	buffer.c	/^PRESERVE_PINNED(struct evbuffer *src, struct evbuffer_chain **first,$/;"	f	file:	signature:(struct evbuffer *src, struct evbuffer_chain **first, struct evbuffer_chain **last)
PRE_INSTALL	Makefile	/^PRE_INSTALL = :$/;"	m
PRE_INSTALL	include/Makefile	/^PRE_INSTALL = :$/;"	m
PRE_INSTALL	sample/Makefile	/^PRE_INSTALL = :$/;"	m
PRE_INSTALL	test/Makefile	/^PRE_INSTALL = :$/;"	m
PRE_UNINSTALL	Makefile	/^PRE_UNINSTALL = :$/;"	m
PRE_UNINSTALL	include/Makefile	/^PRE_UNINSTALL = :$/;"	m
PRE_UNINSTALL	sample/Makefile	/^PRE_UNINSTALL = :$/;"	m
PRE_UNINSTALL	test/Makefile	/^PRE_UNINSTALL = :$/;"	m
PROGRAMS	sample/Makefile	/^PROGRAMS = $(noinst_PROGRAMS)$/;"	m
PROGRAMS	test/Makefile	/^PROGRAMS = $(noinst_PROGRAMS)$/;"	m
PTHREAD_CC	Makefile	/^PTHREAD_CC = gcc$/;"	m
PTHREAD_CC	include/Makefile	/^PTHREAD_CC = gcc$/;"	m
PTHREAD_CC	sample/Makefile	/^PTHREAD_CC = gcc$/;"	m
PTHREAD_CC	test/Makefile	/^PTHREAD_CC = gcc$/;"	m
PTHREAD_CFLAGS	Makefile	/^PTHREAD_CFLAGS = $/;"	m
PTHREAD_CFLAGS	include/Makefile	/^PTHREAD_CFLAGS = $/;"	m
PTHREAD_CFLAGS	sample/Makefile	/^PTHREAD_CFLAGS = $/;"	m
PTHREAD_CFLAGS	test/Makefile	/^PTHREAD_CFLAGS = $/;"	m
PTHREAD_LIBS	Makefile	/^PTHREAD_LIBS = $/;"	m
PTHREAD_LIBS	include/Makefile	/^PTHREAD_LIBS = $/;"	m
PTHREAD_LIBS	sample/Makefile	/^PTHREAD_LIBS = $/;"	m
PTHREAD_LIBS	test/Makefile	/^PTHREAD_LIBS =  $(am__append_3)$/;"	m
PTR_TO_UDATA	kqueue.c	53;"	d	file:
PTR_TO_UDATA	kqueue.c	56;"	d	file:
PUT_DATA	test/regress_http.c	1596;"	d	file:
Parse	event_rpcgen.py	/^def Parse(factory, file):$/;"	f	access:public
PrintCode	event_rpcgen.py	/^    def PrintCode(self, file):$/;"	m	class:StructCCode	access:public
PrintDeclaration	event_rpcgen.py	/^    def PrintDeclaration(self, file):$/;"	m	class:StructCCode	access:public
PrintForwardDeclaration	event_rpcgen.py	/^    def PrintForwardDeclaration(self, file):$/;"	m	class:StructCCode	access:public
PrintIndented	event_rpcgen.py	/^    def PrintIndented(self, file, ident, code):$/;"	m	class:Struct	access:public
PrintTags	event_rpcgen.py	/^    def PrintTags(self, file):$/;"	m	class:StructCCode	access:public
ProcessOneEntry	event_rpcgen.py	/^def ProcessOneEntry(factory, newstruct, entry):$/;"	f	access:public
ProcessStruct	event_rpcgen.py	/^def ProcessStruct(factory, data):$/;"	f	access:public
QUEUE_THREAD_COUNT	test/regress_thread.c	404;"	d	file:
RANLIB	Makefile	/^RANLIB = ranlib$/;"	m
RANLIB	include/Makefile	/^RANLIB = ranlib$/;"	m
RANLIB	sample/Makefile	/^RANLIB = ranlib$/;"	m
RANLIB	test/Makefile	/^RANLIB = ranlib$/;"	m
RB_AUGMENT	WIN32-Code/tree.h	1009;"	d
RB_AUGMENT	WIN32-Code/tree.h	332;"	d
RB_BLACK	WIN32-Code/tree.h	303;"	d
RB_BLACK	WIN32-Code/tree.h	980;"	d
RB_COLOR	WIN32-Code/tree.h	316;"	d
RB_COLOR	WIN32-Code/tree.h	993;"	d
RB_EMPTY	WIN32-Code/tree.h	318;"	d
RB_EMPTY	WIN32-Code/tree.h	995;"	d
RB_ENTRY	WIN32-Code/tree.h	305;"	d
RB_ENTRY	WIN32-Code/tree.h	982;"	d
RB_FIND	WIN32-Code/tree.h	1344;"	d
RB_FIND	WIN32-Code/tree.h	667;"	d
RB_FOREACH	WIN32-Code/tree.h	1349;"	d
RB_FOREACH	WIN32-Code/tree.h	672;"	d
RB_GENERATE	WIN32-Code/tree.h	1066;"	d
RB_GENERATE	WIN32-Code/tree.h	389;"	d
RB_HEAD	WIN32-Code/tree.h	291;"	d
RB_HEAD	WIN32-Code/tree.h	968;"	d
RB_INF	WIN32-Code/tree.h	1340;"	d
RB_INF	WIN32-Code/tree.h	663;"	d
RB_INIT	WIN32-Code/tree.h	299;"	d
RB_INIT	WIN32-Code/tree.h	976;"	d
RB_INITIALIZER	WIN32-Code/tree.h	296;"	d
RB_INITIALIZER	WIN32-Code/tree.h	973;"	d
RB_INSERT	WIN32-Code/tree.h	1342;"	d
RB_INSERT	WIN32-Code/tree.h	665;"	d
RB_LEFT	WIN32-Code/tree.h	313;"	d
RB_LEFT	WIN32-Code/tree.h	990;"	d
RB_MAX	WIN32-Code/tree.h	1347;"	d
RB_MAX	WIN32-Code/tree.h	670;"	d
RB_MIN	WIN32-Code/tree.h	1346;"	d
RB_MIN	WIN32-Code/tree.h	669;"	d
RB_NEGINF	WIN32-Code/tree.h	1339;"	d
RB_NEGINF	WIN32-Code/tree.h	662;"	d
RB_NEXT	WIN32-Code/tree.h	1345;"	d
RB_NEXT	WIN32-Code/tree.h	668;"	d
RB_PARENT	WIN32-Code/tree.h	315;"	d
RB_PARENT	WIN32-Code/tree.h	992;"	d
RB_PROTOTYPE	WIN32-Code/tree.h	1053;"	d
RB_PROTOTYPE	WIN32-Code/tree.h	376;"	d
RB_RED	WIN32-Code/tree.h	304;"	d
RB_RED	WIN32-Code/tree.h	981;"	d
RB_REMOVE	WIN32-Code/tree.h	1343;"	d
RB_REMOVE	WIN32-Code/tree.h	666;"	d
RB_RIGHT	WIN32-Code/tree.h	314;"	d
RB_RIGHT	WIN32-Code/tree.h	991;"	d
RB_ROOT	WIN32-Code/tree.h	317;"	d
RB_ROOT	WIN32-Code/tree.h	994;"	d
RB_ROTATE_LEFT	WIN32-Code/tree.h	1012;"	d
RB_ROTATE_LEFT	WIN32-Code/tree.h	335;"	d
RB_ROTATE_RIGHT	WIN32-Code/tree.h	1032;"	d
RB_ROTATE_RIGHT	WIN32-Code/tree.h	355;"	d
RB_SET	WIN32-Code/tree.h	320;"	d
RB_SET	WIN32-Code/tree.h	997;"	d
RB_SET_BLACKRED	WIN32-Code/tree.h	1003;"	d
RB_SET_BLACKRED	WIN32-Code/tree.h	326;"	d
READ_DEFAULT	bufferevent_openssl.c	715;"	d	file:
RECURSIVE_CLEAN_TARGETS	Makefile	/^RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\\$/;"	m
RECURSIVE_TARGETS	Makefile	/^RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\$/;"	m
RELEASE	Makefile	/^RELEASE = -release 2.0$/;"	m
REQUEST_CANCELED	http-internal.h	/^	REQUEST_CANCELED = -2,$/;"	e	enum:message_read_status
REQ_HEAD	evdns.c	386;"	d	file:
REQ_VERSION_ATLEAST	http.c	160;"	d	file:
REQ_VERSION_BEFORE	http.c	156;"	d	file:
RESET	test/regress_util.c	519;"	d	file:
RESET	test/regress_util.c	593;"	d	file:
RESTORE_PINNED	buffer.c	/^RESTORE_PINNED(struct evbuffer *src, struct evbuffer_chain *pinned,$/;"	f	file:	signature:(struct evbuffer *src, struct evbuffer_chain *pinned, struct evbuffer_chain *last)
RPC_LEGACY	test/regress_rpc.c	876;"	d	file:
RPC_LEGACY	test/regress_rpc.c	883;"	d	file:
RpcGenError	event_rpcgen.py	/^class RpcGenError(Exception):$/;"	c	inherits:Exception
SCHEDULE_DEFERRED	bufferevent.c	210;"	d	file:
SCRIPTS	Makefile	/^SCRIPTS = $(dist_bin_SCRIPTS)$/;"	m
SECONDS	test/regress.c	90;"	d	file:
SED	Makefile	/^SED = \/bin\/sed$/;"	m
SED	include/Makefile	/^SED = \/bin\/sed$/;"	m
SED	sample/Makefile	/^SED = \/bin\/sed$/;"	m
SED	test/Makefile	/^SED = \/bin\/sed$/;"	m
SELECT_ALLOC_SIZE	select.c	66;"	d	file:
SENDFILE_IS_FREEBSD	buffer.c	105;"	d	file:
SENDFILE_IS_LINUX	buffer.c	102;"	d	file:
SENDFILE_IS_MACOSX	buffer.c	108;"	d	file:
SENDFILE_IS_SOLARIS	buffer.c	111;"	d	file:
SERVICES_KEY	evdns.c	3745;"	d	file:
SETENV_OK	test/regress.c	1978;"	d	file:
SETENV_OK	test/regress.c	1986;"	d	file:
SET_MAKE	Makefile	/^SET_MAKE = $/;"	m
SET_MAKE	include/Makefile	/^SET_MAKE = $/;"	m
SET_MAKE	sample/Makefile	/^SET_MAKE = $/;"	m
SET_MAKE	test/Makefile	/^SET_MAKE = $/;"	m
SHELL	Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	include/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	sample/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	test/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHUT_WR	test/regress.c	93;"	d	file:
SHUT_WR	test/regress_et.c	71;"	d	file:
SHUT_WR	test/regress_http.c	491;"	d	file:
SHUT_WR	test/regress_http.c	493;"	d	file:
SHUT_WR	test/test-eof.c	85;"	d	file:
SIGFPE_REQ	win32select.c	/^volatile double SIGFPE_REQ = 0.0f;$/;"	v
SIMPLEQ_EMPTY	compat/sys/queue.h	233;"	d
SIMPLEQ_END	compat/sys/queue.h	232;"	d
SIMPLEQ_ENTRY	compat/sys/queue.h	223;"	d
SIMPLEQ_FIRST	compat/sys/queue.h	231;"	d
SIMPLEQ_FOREACH	compat/sys/queue.h	236;"	d
SIMPLEQ_HEAD	compat/sys/queue.h	214;"	d
SIMPLEQ_HEAD_INITIALIZER	compat/sys/queue.h	220;"	d
SIMPLEQ_INIT	compat/sys/queue.h	244;"	d
SIMPLEQ_INSERT_AFTER	compat/sys/queue.h	261;"	d
SIMPLEQ_INSERT_HEAD	compat/sys/queue.h	249;"	d
SIMPLEQ_INSERT_TAIL	compat/sys/queue.h	255;"	d
SIMPLEQ_NEXT	compat/sys/queue.h	234;"	d
SIMPLEQ_REMOVE_HEAD	compat/sys/queue.h	267;"	d
SIZEOF_INT	config.h	389;"	d
SIZEOF_LONG	config.h	392;"	d
SIZEOF_LONG_LONG	config.h	395;"	d
SIZEOF_OFF_T	config.h	398;"	d
SIZEOF_PTHREAD_T	config.h	401;"	d
SIZEOF_SHORT	config.h	404;"	d
SIZEOF_SIZE_T	config.h	407;"	d
SIZEOF_VOID_P	config.h	410;"	d
SKIP	test/tinytest.c	/^enum outcome { SKIP=2, OK=1, FAIL=0 };$/;"	e	enum:outcome	file:
SKIP_NAME	evdns.c	1041;"	d	file:
SKIP_NAME	evdns.c	1285;"	d	file:
SLEEP_MS	test/regress_thread.c	407;"	d	file:
SLEEP_MS	test/regress_thread.c	409;"	d	file:
SLIST_EMPTY	compat/sys/queue.h	108;"	d
SLIST_END	compat/sys/queue.h	107;"	d
SLIST_ENTRY	compat/sys/queue.h	97;"	d
SLIST_FIRST	compat/sys/queue.h	106;"	d
SLIST_FOREACH	compat/sys/queue.h	111;"	d
SLIST_HEAD	compat/sys/queue.h	88;"	d
SLIST_HEAD_INITIALIZER	compat/sys/queue.h	93;"	d
SLIST_INIT	compat/sys/queue.h	119;"	d
SLIST_INSERT_AFTER	compat/sys/queue.h	123;"	d
SLIST_INSERT_HEAD	compat/sys/queue.h	128;"	d
SLIST_NEXT	compat/sys/queue.h	109;"	d
SLIST_REMOVE_HEAD	compat/sys/queue.h	133;"	d
SOURCES	Makefile	/^SOURCES = $(libevent_la_SOURCES) $(libevent_core_la_SOURCES) \\$/;"	m
SOURCES	include/Makefile	/^SOURCES =$/;"	m
SOURCES	sample/Makefile	/^SOURCES = $(dns_example_SOURCES) $(event_test_SOURCES) \\$/;"	m
SOURCES	test/Makefile	/^SOURCES = $(bench_SOURCES) $(bench_cascade_SOURCES) \\$/;"	m
SO_UPDATE_CONNECT_CONTEXT	bufferevent_async.c	68;"	d	file:
SPIN_COUNT	evthread_win32.c	46;"	d	file:
SPLAY_ASSEMBLE	WIN32-Code/tree.h	105;"	d
SPLAY_ASSEMBLE	WIN32-Code/tree.h	782;"	d
SPLAY_EMPTY	WIN32-Code/tree.h	755;"	d
SPLAY_EMPTY	WIN32-Code/tree.h	78;"	d
SPLAY_ENTRY	WIN32-Code/tree.h	69;"	d
SPLAY_ENTRY	WIN32-Code/tree.h	746;"	d
SPLAY_FIND	WIN32-Code/tree.h	278;"	d
SPLAY_FIND	WIN32-Code/tree.h	955;"	d
SPLAY_FOREACH	WIN32-Code/tree.h	285;"	d
SPLAY_FOREACH	WIN32-Code/tree.h	962;"	d
SPLAY_GENERATE	WIN32-Code/tree.h	156;"	d
SPLAY_GENERATE	WIN32-Code/tree.h	833;"	d
SPLAY_HEAD	WIN32-Code/tree.h	57;"	d
SPLAY_HEAD	WIN32-Code/tree.h	734;"	d
SPLAY_INF	WIN32-Code/tree.h	274;"	d
SPLAY_INF	WIN32-Code/tree.h	951;"	d
SPLAY_INIT	WIN32-Code/tree.h	65;"	d
SPLAY_INIT	WIN32-Code/tree.h	742;"	d
SPLAY_INITIALIZER	WIN32-Code/tree.h	62;"	d
SPLAY_INITIALIZER	WIN32-Code/tree.h	739;"	d
SPLAY_INSERT	WIN32-Code/tree.h	276;"	d
SPLAY_INSERT	WIN32-Code/tree.h	953;"	d
SPLAY_LEFT	WIN32-Code/tree.h	752;"	d
SPLAY_LEFT	WIN32-Code/tree.h	75;"	d
SPLAY_LINKLEFT	WIN32-Code/tree.h	770;"	d
SPLAY_LINKLEFT	WIN32-Code/tree.h	93;"	d
SPLAY_LINKRIGHT	WIN32-Code/tree.h	776;"	d
SPLAY_LINKRIGHT	WIN32-Code/tree.h	99;"	d
SPLAY_MAX	WIN32-Code/tree.h	282;"	d
SPLAY_MAX	WIN32-Code/tree.h	959;"	d
SPLAY_MIN	WIN32-Code/tree.h	280;"	d
SPLAY_MIN	WIN32-Code/tree.h	957;"	d
SPLAY_NEGINF	WIN32-Code/tree.h	273;"	d
SPLAY_NEGINF	WIN32-Code/tree.h	950;"	d
SPLAY_NEXT	WIN32-Code/tree.h	279;"	d
SPLAY_NEXT	WIN32-Code/tree.h	956;"	d
SPLAY_PROTOTYPE	WIN32-Code/tree.h	114;"	d
SPLAY_PROTOTYPE	WIN32-Code/tree.h	791;"	d
SPLAY_REMOVE	WIN32-Code/tree.h	277;"	d
SPLAY_REMOVE	WIN32-Code/tree.h	954;"	d
SPLAY_RIGHT	WIN32-Code/tree.h	753;"	d
SPLAY_RIGHT	WIN32-Code/tree.h	76;"	d
SPLAY_ROOT	WIN32-Code/tree.h	754;"	d
SPLAY_ROOT	WIN32-Code/tree.h	77;"	d
SPLAY_ROTATE_LEFT	WIN32-Code/tree.h	764;"	d
SPLAY_ROTATE_LEFT	WIN32-Code/tree.h	87;"	d
SPLAY_ROTATE_RIGHT	WIN32-Code/tree.h	758;"	d
SPLAY_ROTATE_RIGHT	WIN32-Code/tree.h	81;"	d
STDC_HEADERS	config.h	413;"	d
STRIP	Makefile	/^STRIP = strip$/;"	m
STRIP	include/Makefile	/^STRIP = strip$/;"	m
STRIP	sample/Makefile	/^STRIP = strip$/;"	m
STRIP	test/Makefile	/^STRIP = strip$/;"	m
SUBDELIMS	http.c	3959;"	d	file:
SUBDIRS	Makefile	/^SUBDIRS = . include sample test$/;"	m
SYS_INCLUDES	Makefile	/^SYS_INCLUDES = $/;"	m
SYS_LIBS	Makefile	/^SYS_LIBS = $/;"	m
SYS_SRC	Makefile	/^SYS_SRC = $(am__append_5) $(am__append_6) \\$/;"	m
S_ISDIR	sample/http-server.c	23;"	d	file:
SetLineCount	event_rpcgen.py	/^    def SetLineCount(self, number):$/;"	m	class:Entry	access:public
SetStruct	event_rpcgen.py	/^    def SetStruct(self, struct):$/;"	m	class:Entry	access:public
SleepConditionVariableCS_fn	evthread_win32.c	/^static BOOL WINAPI (*SleepConditionVariableCS_fn)($/;"	v	file:
Struct	event_rpcgen.py	/^    def Struct(self, name):$/;"	m	class:CCodeGenerator	access:public
Struct	event_rpcgen.py	/^class Struct:$/;"	c	inherits:
StructCCode	event_rpcgen.py	/^class StructCCode(Struct):$/;"	c	inherits:Struct
TAILQ_EMPTY	compat/sys/queue.h	301;"	d
TAILQ_END	compat/sys/queue.h	294;"	d
TAILQ_END	event-internal.h	318;"	d
TAILQ_ENTRY	compat/sys/queue.h	284;"	d
TAILQ_ENTRY	evdns.c	/^	TAILQ_ENTRY(hosts_entry) next;$/;"	p	struct:hosts_entry	file:	access:public
TAILQ_ENTRY	include/event2/event_struct.h	130;"	d
TAILQ_ENTRY	include/event2/event_struct.h	70;"	d
TAILQ_ENTRY	include/event2/keyvalq_struct.h	38;"	d
TAILQ_ENTRY	include/event2/keyvalq_struct.h	69;"	d
TAILQ_FIRST	compat/sys/queue.h	293;"	d
TAILQ_FIRST	event-internal.h	315;"	d
TAILQ_FOREACH	compat/sys/queue.h	304;"	d
TAILQ_FOREACH	event-internal.h	325;"	d
TAILQ_FOREACH_REVERSE	compat/sys/queue.h	309;"	d
TAILQ_HEAD	compat/sys/queue.h	275;"	d
TAILQ_HEAD	evdns.c	/^	TAILQ_HEAD(hosts_list, hosts_entry) hostsdb;$/;"	p	struct:evdns_base	file:	access:public
TAILQ_HEAD	evrpc-internal.h	/^	TAILQ_HEAD(evrpc_requestq, evrpc_request_wrapper) (requests);$/;"	p	struct:evrpc_pool	access:public	signature:(evrpc_requestq, evrpc_request_wrapper)
TAILQ_HEAD	include/event2/event_struct.h	134;"	d
TAILQ_HEAD	include/event2/event_struct.h	79;"	d
TAILQ_HEAD	include/event2/keyvalq_struct.h	47;"	d
TAILQ_HEAD	include/event2/keyvalq_struct.h	73;"	d
TAILQ_HEAD_INITIALIZER	compat/sys/queue.h	281;"	d
TAILQ_INIT	compat/sys/queue.h	317;"	d
TAILQ_INSERT_AFTER	compat/sys/queue.h	339;"	d
TAILQ_INSERT_BEFORE	compat/sys/queue.h	349;"	d
TAILQ_INSERT_BEFORE	event-internal.h	332;"	d
TAILQ_INSERT_HEAD	compat/sys/queue.h	322;"	d
TAILQ_INSERT_TAIL	compat/sys/queue.h	332;"	d
TAILQ_LAST	compat/sys/queue.h	296;"	d
TAILQ_NEXT	compat/sys/queue.h	295;"	d
TAILQ_NEXT	event-internal.h	321;"	d
TAILQ_PREV	compat/sys/queue.h	299;"	d
TAILQ_REMOVE	compat/sys/queue.h	356;"	d
TAILQ_REPLACE	compat/sys/queue.h	365;"	d
TEST	test/regress_thread.c	496;"	d	file:
TEST1	test/regress.c	89;"	d	file:
TESTS	test/Makefile	/^TESTS = test-script.sh$/;"	m
TEST_MAX_INT	test/regress.c	1750;"	d	file:
TEST_NAME	evdns.c	1047;"	d	file:
TEST_STR	test/regress_bufferevent.c	424;"	d	file:
THREAD_FN	test/regress_thread.c	68;"	d	file:
THREAD_FN	test/regress_thread.c	75;"	d	file:
THREAD_JOIN	test/regress_thread.c	72;"	d	file:
THREAD_JOIN	test/regress_thread.c	81;"	d	file:
THREAD_RETURN	test/regress_thread.c	69;"	d	file:
THREAD_RETURN	test/regress_thread.c	76;"	d	file:
THREAD_START	test/regress_thread.c	70;"	d	file:
THREAD_START	test/regress_thread.c	77;"	d	file:
THREAD_T	test/regress_thread.c	67;"	d	file:
THREAD_T	test/regress_thread.c	74;"	d	file:
TIMEOUT_BACKOFF_FACTOR	evdns.c	525;"	d	file:
TIME_WITH_SYS_TIME	config.h	416;"	d
TO_SERVER_REQUEST	evdns.c	382;"	d	file:
TRY	evdns.c	3754;"	d	file:
TRY	evdns.c	3802;"	d	file:
TRY_SEED_PROC_SYS_KERNEL_RANDOM_UUID	arc4random.c	250;"	d	file:
TRY_SEED_SYSCTL_BSD	arc4random.c	209;"	d	file:
TRY_SEED_SYSCTL_LINUX	arc4random.c	172;"	d	file:
TRY_SEED_URANDOM	arc4random.c	295;"	d	file:
TRY_SEED_WIN32	arc4random.c	144;"	d	file:
TT_BLATHER	test/tinytest_macros.h	52;"	d
TT_DECLARE	test/tinytest_macros.h	41;"	d
TT_DIE	test/tinytest_macros.h	57;"	d
TT_ENABLE_IOCP	test/regress.h	89;"	d
TT_ENABLE_IOCP_FLAG	test/regress.h	88;"	d
TT_EXIT_TEST_FUNCTION	test/tinytest_macros.h	36;"	d
TT_FAIL	test/tinytest_macros.h	64;"	d
TT_FIRST_USER_FLAG	test/tinytest.h	36;"	d
TT_FORK	test/tinytest.h	30;"	d
TT_GRIPE	test/tinytest_macros.h	49;"	d
TT_ISOLATED	test/regress.h	92;"	d
TT_LEGACY	test/regress.h	85;"	d
TT_NEED_BASE	test/regress.h	83;"	d
TT_NEED_DNS	test/regress.h	84;"	d
TT_NEED_SOCKETPAIR	test/regress.h	82;"	d
TT_NEED_THREADS	test/regress.h	86;"	d
TT_NO_LOGS	test/regress.h	87;"	d
TT_SKIP	test/tinytest.h	32;"	d
TT_STMT_BEGIN	test/tinytest_macros.h	30;"	d
TT_STMT_END	test/tinytest_macros.h	31;"	d
TT_URI	test/regress_http.c	2001;"	d	file:
TT_URI	test/regress_http.c	2369;"	d	file:
TYPE_A	evdns.c	147;"	d	file:
TYPE_AAAA	evdns.c	151;"	d	file:
TYPE_CNAME	evdns.c	148;"	d	file:
TYPE_PTR	evdns.c	149;"	d	file:
TYPE_SOA	evdns.c	150;"	d	file:
Tag	event_rpcgen.py	/^    def Tag(self):$/;"	m	class:Entry	access:public
TranslateList	event_rpcgen.py	/^def TranslateList(mylist, mydict):$/;"	f	access:public
Type	event_rpcgen.py	/^    def Type(self):$/;"	m	class:Entry	access:public
UNLOCK	listener.c	104;"	d	file:
UNLOCKED	bufferevent.c	172;"	d	file:
UNLOCKED	bufferevent.c	207;"	d	file:
UNLOCK_DEFERRED_QUEUE	defer-internal.h	89;"	d
UNLOCK_GROUP	bufferevent_ratelim.c	188;"	d	file:
UNSETENV_OK	test/regress.c	1990;"	d	file:
UNSETENV_OK	test/regress.c	1998;"	d	file:
URI_PARSE	test/regress_http.c	1998;"	d	file:
URI_PARSE	test/regress_http.c	2368;"	d	file:
USE_INTERNAL_NTOP	evutil.c	1583;"	d	file:
USE_INTERNAL_PTON	evutil.c	1584;"	d	file:
USE_IOVEC_IMPL	buffer.c	1983;"	d	file:
USE_NATIVE_GETADDRINFO	evutil.c	926;"	d	file:
USE_SENDFILE	buffer.c	101;"	d	file:
USE_SENDFILE	buffer.c	104;"	d	file:
USE_SENDFILE	buffer.c	107;"	d	file:
USE_SENDFILE	buffer.c	110;"	d	file:
Usage	event_rpcgen.py	/^class Usage(RpcGenError):$/;"	c	inherits:RpcGenError
VERSION	Makefile	/^VERSION = 2.0.22-stable$/;"	m
VERSION	config.h	419;"	d
VERSION	include/Makefile	/^VERSION = 2.0.22-stable$/;"	m
VERSION	sample/Makefile	/^VERSION = 2.0.22-stable$/;"	m
VERSION	test/Makefile	/^VERSION = 2.0.22-stable$/;"	m
VERSION_INFO	Makefile	/^VERSION_INFO = 6:9:1$/;"	m
Verify	event_rpcgen.py	/^    def Verify(self):$/;"	m	class:Entry	access:public
Verify	event_rpcgen.py	/^    def Verify(self):$/;"	m	class:EntryBytes	access:public
WIN32_LEAN_AND_MEAN	event.c	31;"	d	file:
WIN32_LEAN_AND_MEAN	event.c	33;"	d	file:
WIN32_LEAN_AND_MEAN	event.h	61;"	d
WIN32_LEAN_AND_MEAN	event.h	65;"	d
WIN32_LEAN_AND_MEAN	event_tagging.c	38;"	d	file:
WIN32_LEAN_AND_MEAN	event_tagging.c	41;"	d	file:
WIN32_LEAN_AND_MEAN	evmap.c	30;"	d	file:
WIN32_LEAN_AND_MEAN	evmap.c	32;"	d	file:
WIN32_LEAN_AND_MEAN	evrpc.c	30;"	d	file:
WIN32_LEAN_AND_MEAN	evrpc.c	33;"	d	file:
WIN32_LEAN_AND_MEAN	evthread_win32.c	34;"	d	file:
WIN32_LEAN_AND_MEAN	evthread_win32.c	36;"	d	file:
WIN32_LEAN_AND_MEAN	evutil.c	34;"	d	file:
WIN32_LEAN_AND_MEAN	evutil.c	36;"	d	file:
WIN32_LEAN_AND_MEAN	log.c	44;"	d	file:
WIN32_LEAN_AND_MEAN	log.c	46;"	d	file:
WIN32_LEAN_AND_MEAN	signal.c	32;"	d	file:
WIN32_LEAN_AND_MEAN	signal.c	35;"	d	file:
WIN32_LEAN_AND_MEAN	test/bench.c	44;"	d	file:
WIN32_LEAN_AND_MEAN	test/bench_cascade.c	36;"	d	file:
WIN32_LEAN_AND_MEAN	test/regress_iocp.c	42;"	d	file:
WIN32_LEAN_AND_MEAN	test/regress_iocp.c	45;"	d	file:
WIN_NS_9X_KEY	evdns.c	3746;"	d	file:
WIN_NS_NT_KEY	evdns.c	3747;"	d	file:
WRITE_FRAME	bufferevent_openssl.c	713;"	d	file:
WSABUF_FROM_EVBUFFER_IOV	evbuffer-internal.h	277;"	d
WSAID_ACCEPTEX	event_iocp.c	132;"	d	file:
WSAID_CONNECTEX	event_iocp.c	136;"	d	file:
WSAID_GETACCEPTEXSOCKADDRS	event_iocp.c	140;"	d	file:
WakeAllConditionVariable_fn	evthread_win32.c	/^static void WINAPI (*WakeAllConditionVariable_fn)(PCONDITION_VARIABLE) = NULL;$/;"	v	file:
WakeConditionVariable_fn	evthread_win32.c	/^static void WINAPI (*WakeConditionVariable_fn)(PCONDITION_VARIABLE) = NULL;$/;"	v	file:
XFREE	win32select.c	50;"	d	file:
ZERO_CHAIN	buffer.c	/^ZERO_CHAIN(struct evbuffer *dst)$/;"	f	file:	signature:(struct evbuffer *dst)
ZLIB_LIBS	Makefile	/^ZLIB_LIBS = $/;"	m
ZLIB_LIBS	include/Makefile	/^ZLIB_LIBS = $/;"	m
ZLIB_LIBS	sample/Makefile	/^ZLIB_LIBS = $/;"	m
ZLIB_LIBS	test/Makefile	/^ZLIB_LIBS = $/;"	m
_ARC4_LOCK	evutil_rand.c	114;"	d	file:
_ARC4_UNLOCK	evutil_rand.c	115;"	d	file:
_BUFFEREVENT_INTERNAL_H_	bufferevent-internal.h	27;"	d
_CHANGELIST_H_	changelist-internal.h	27;"	d
_DEFER_INTERNAL_H_	defer-internal.h	27;"	d
_EVBUFFER_INTERNAL_H_	evbuffer-internal.h	28;"	d
_EVBUFFER_IOVEC_IS_NATIVE	include/event2/buffer.h	127;"	d
_EVDNS_H_	evdns.h	28;"	d
_EVENT2_BUFFEREVENT_COMPAT_H_	include/event2/bufferevent_compat.h	29;"	d
_EVENT2_BUFFEREVENT_H_	include/event2/bufferevent.h	28;"	d
_EVENT2_BUFFEREVENT_SSL_H_	include/event2/bufferevent_ssl.h	27;"	d
_EVENT2_BUFFEREVENT_STRUCT_H_	include/event2/bufferevent_struct.h	28;"	d
_EVENT2_BUFFER_COMPAT_H_	include/event2/buffer_compat.h	28;"	d
_EVENT2_BUFFER_H_	include/event2/buffer.h	27;"	d
_EVENT2_DNS_COMPAT_H_	include/event2/dns_compat.h	28;"	d
_EVENT2_DNS_H_	include/event2/dns.h	136;"	d
_EVENT2_DNS_STRUCT_H_	include/event2/dns_struct.h	28;"	d
_EVENT2_EVENT_COMPAT_H_	include/event2/event_compat.h	28;"	d
_EVENT2_EVENT_CONFIG_H_	include/event2/event-config.h	12;"	d
_EVENT2_EVENT_H_	include/event2/event.h	28;"	d
_EVENT2_EVENT_KEYVALQ_STRUCT_H_	include/event2/keyvalq_struct.h	28;"	d
_EVENT2_EVENT_STRUCT_H_	include/event2/event_struct.h	28;"	d
_EVENT2_HTTP_COMPAT_H_	include/event2/http_compat.h	28;"	d
_EVENT2_HTTP_H_	include/event2/http.h	28;"	d
_EVENT2_HTTP_STRUCT_H_	include/event2/http_struct.h	28;"	d
_EVENT2_LISTENER_H_	include/event2/listener.h	28;"	d
_EVENT2_RPC_COMPAT_H_	include/event2/rpc_compat.h	28;"	d
_EVENT2_RPC_H_	include/event2/rpc.h	28;"	d
_EVENT2_RPC_STRUCT_H_	include/event2/rpc_struct.h	28;"	d
_EVENT2_TAG_COMPAT_H_	include/event2/tag_compat.h	28;"	d
_EVENT2_TAG_H_	include/event2/tag.h	28;"	d
_EVENT2_THREAD_H_	include/event2/thread.h	27;"	d
_EVENT2_UTIL_H_	include/event2/util.h	27;"	d
_EVENT_CONFIG_H_	WIN32-Code/event2/event-config.h	11;"	d
_EVENT_DEFINED_TQENTRY	include/event2/event_struct.h	69;"	d
_EVENT_DEFINED_TQENTRY	include/event2/keyvalq_struct.h	37;"	d
_EVENT_DEFINED_TQHEAD	include/event2/event_struct.h	78;"	d
_EVENT_DEFINED_TQHEAD	include/event2/keyvalq_struct.h	46;"	d
_EVENT_DNS_USE_FTIME_FOR_ID	WIN32-Code/event2/event-config.h	26;"	d
_EVENT_ERR_ABORT	log-internal.h	40;"	d
_EVENT_HAVE_ARPA_INET_H	include/event2/event-config.h	33;"	d
_EVENT_HAVE_CLOCK_GETTIME	include/event2/event-config.h	36;"	d
_EVENT_HAVE_DECL_CTL_KERN	include/event2/event-config.h	40;"	d
_EVENT_HAVE_DECL_KERN_ARND	include/event2/event-config.h	44;"	d
_EVENT_HAVE_DECL_KERN_RANDOM	include/event2/event-config.h	48;"	d
_EVENT_HAVE_DECL_RANDOM_UUID	include/event2/event-config.h	52;"	d
_EVENT_HAVE_DLFCN_H	include/event2/event-config.h	58;"	d
_EVENT_HAVE_EPOLL	include/event2/event-config.h	61;"	d
_EVENT_HAVE_EPOLL_CTL	include/event2/event-config.h	64;"	d
_EVENT_HAVE_EVENTFD	include/event2/event-config.h	67;"	d
_EVENT_HAVE_FCNTL	include/event2/event-config.h	73;"	d
_EVENT_HAVE_FCNTL_H	WIN32-Code/event2/event-config.h	56;"	d
_EVENT_HAVE_FCNTL_H	include/event2/event-config.h	76;"	d
_EVENT_HAVE_FD_MASK	include/event2/event-config.h	79;"	d
_EVENT_HAVE_GETADDRINFO	WIN32-Code/event2/event-config.h	59;"	d
_EVENT_HAVE_GETADDRINFO	include/event2/event-config.h	82;"	d
_EVENT_HAVE_GETEGID	include/event2/event-config.h	85;"	d
_EVENT_HAVE_GETEUID	include/event2/event-config.h	88;"	d
_EVENT_HAVE_GETNAMEINFO	WIN32-Code/event2/event-config.h	62;"	d
_EVENT_HAVE_GETNAMEINFO	include/event2/event-config.h	103;"	d
_EVENT_HAVE_GETPROTOBYNUMBER	WIN32-Code/event2/event-config.h	65;"	d
_EVENT_HAVE_GETPROTOBYNUMBER	include/event2/event-config.h	106;"	d
_EVENT_HAVE_GETSERVBYNAME	WIN32-Code/event2/event-config.h	68;"	d
_EVENT_HAVE_GETTIMEOFDAY	include/event2/event-config.h	112;"	d
_EVENT_HAVE_INET_ATON	include/event2/event-config.h	115;"	d
_EVENT_HAVE_INET_NTOP	include/event2/event-config.h	118;"	d
_EVENT_HAVE_INET_PTON	include/event2/event-config.h	121;"	d
_EVENT_HAVE_INTTYPES_H	include/event2/event-config.h	124;"	d
_EVENT_HAVE_MEMORY_H	WIN32-Code/event2/event-config.h	92;"	d
_EVENT_HAVE_MEMORY_H	include/event2/event-config.h	136;"	d
_EVENT_HAVE_MMAP	include/event2/event-config.h	139;"	d
_EVENT_HAVE_NETDB_H	include/event2/event-config.h	142;"	d
_EVENT_HAVE_NETINET_IN_H	include/event2/event-config.h	148;"	d
_EVENT_HAVE_PIPE	include/event2/event-config.h	157;"	d
_EVENT_HAVE_POLL	include/event2/event-config.h	160;"	d
_EVENT_HAVE_POLL_H	include/event2/event-config.h	163;"	d
_EVENT_HAVE_PTHREADS	include/event2/event-config.h	175;"	d
_EVENT_HAVE_PUTENV	include/event2/event-config.h	178;"	d
_EVENT_HAVE_SA_FAMILY_T	include/event2/event-config.h	181;"	d
_EVENT_HAVE_SELECT	include/event2/event-config.h	184;"	d
_EVENT_HAVE_SENDFILE	include/event2/event-config.h	187;"	d
_EVENT_HAVE_SETENV	include/event2/event-config.h	190;"	d
_EVENT_HAVE_SETFD	include/event2/event-config.h	193;"	d
_EVENT_HAVE_SIGACTION	include/event2/event-config.h	196;"	d
_EVENT_HAVE_SIGNAL	WIN32-Code/event2/event-config.h	140;"	d
_EVENT_HAVE_SIGNAL	include/event2/event-config.h	199;"	d
_EVENT_HAVE_SPLICE	include/event2/event-config.h	202;"	d
_EVENT_HAVE_STDARG_H	WIN32-Code/event2/event-config.h	146;"	d
_EVENT_HAVE_STDARG_H	include/event2/event-config.h	205;"	d
_EVENT_HAVE_STDDEF_H	WIN32-Code/event2/event-config.h	149;"	d
_EVENT_HAVE_STDDEF_H	include/event2/event-config.h	208;"	d
_EVENT_HAVE_STDINT_H	include/event2/event-config.h	211;"	d
_EVENT_HAVE_STDLIB_H	WIN32-Code/event2/event-config.h	155;"	d
_EVENT_HAVE_STDLIB_H	include/event2/event-config.h	214;"	d
_EVENT_HAVE_STRINGS_H	WIN32-Code/event2/event-config.h	158;"	d
_EVENT_HAVE_STRINGS_H	include/event2/event-config.h	217;"	d
_EVENT_HAVE_STRING_H	WIN32-Code/event2/event-config.h	161;"	d
_EVENT_HAVE_STRING_H	include/event2/event-config.h	220;"	d
_EVENT_HAVE_STRSEP	include/event2/event-config.h	226;"	d
_EVENT_HAVE_STRTOK_R	include/event2/event-config.h	229;"	d
_EVENT_HAVE_STRTOLL	include/event2/event-config.h	232;"	d
_EVENT_HAVE_STRUCT_ADDRINFO	WIN32-Code/event2/event-config.h	175;"	d
_EVENT_HAVE_STRUCT_ADDRINFO	include/event2/event-config.h	235;"	d
_EVENT_HAVE_STRUCT_IN6_ADDR	WIN32-Code/event2/event-config.h	178;"	d
_EVENT_HAVE_STRUCT_IN6_ADDR	include/event2/event-config.h	238;"	d
_EVENT_HAVE_STRUCT_IN6_ADDR_S6_ADDR16	WIN32-Code/event2/event-config.h	181;"	d
_EVENT_HAVE_STRUCT_IN6_ADDR_S6_ADDR16	include/event2/event-config.h	241;"	d
_EVENT_HAVE_STRUCT_IN6_ADDR_S6_ADDR32	WIN32-Code/event2/event-config.h	184;"	d
_EVENT_HAVE_STRUCT_IN6_ADDR_S6_ADDR32	include/event2/event-config.h	244;"	d
_EVENT_HAVE_STRUCT_SOCKADDR_IN6	WIN32-Code/event2/event-config.h	187;"	d
_EVENT_HAVE_STRUCT_SOCKADDR_IN6	include/event2/event-config.h	247;"	d
_EVENT_HAVE_STRUCT_SOCKADDR_STORAGE	WIN32-Code/event2/event-config.h	196;"	d
_EVENT_HAVE_STRUCT_SOCKADDR_STORAGE	include/event2/event-config.h	256;"	d
_EVENT_HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY	include/event2/event-config.h	259;"	d
_EVENT_HAVE_SYSCTL	include/event2/event-config.h	265;"	d
_EVENT_HAVE_SYS_EPOLL_H	include/event2/event-config.h	271;"	d
_EVENT_HAVE_SYS_EVENTFD_H	include/event2/event-config.h	274;"	d
_EVENT_HAVE_SYS_IOCTL_H	include/event2/event-config.h	280;"	d
_EVENT_HAVE_SYS_MMAN_H	include/event2/event-config.h	283;"	d
_EVENT_HAVE_SYS_PARAM_H	include/event2/event-config.h	286;"	d
_EVENT_HAVE_SYS_QUEUE_H	include/event2/event-config.h	289;"	d
_EVENT_HAVE_SYS_SELECT_H	include/event2/event-config.h	292;"	d
_EVENT_HAVE_SYS_SENDFILE_H	include/event2/event-config.h	295;"	d
_EVENT_HAVE_SYS_SOCKET_H	include/event2/event-config.h	298;"	d
_EVENT_HAVE_SYS_STAT_H	WIN32-Code/event2/event-config.h	232;"	d
_EVENT_HAVE_SYS_STAT_H	include/event2/event-config.h	301;"	d
_EVENT_HAVE_SYS_SYSCTL_H	include/event2/event-config.h	304;"	d
_EVENT_HAVE_SYS_TIME_H	include/event2/event-config.h	307;"	d
_EVENT_HAVE_SYS_TYPES_H	WIN32-Code/event2/event-config.h	238;"	d
_EVENT_HAVE_SYS_TYPES_H	include/event2/event-config.h	310;"	d
_EVENT_HAVE_SYS_UIO_H	include/event2/event-config.h	313;"	d
_EVENT_HAVE_SYS_WAIT_H	include/event2/event-config.h	316;"	d
_EVENT_HAVE_TAILQFOREACH	include/event2/event-config.h	319;"	d
_EVENT_HAVE_TIMERADD	include/event2/event-config.h	322;"	d
_EVENT_HAVE_TIMERCLEAR	WIN32-Code/event2/event-config.h	250;"	d
_EVENT_HAVE_TIMERCLEAR	include/event2/event-config.h	325;"	d
_EVENT_HAVE_TIMERCMP	WIN32-Code/event2/event-config.h	253;"	d
_EVENT_HAVE_TIMERCMP	include/event2/event-config.h	328;"	d
_EVENT_HAVE_TIMERISSET	WIN32-Code/event2/event-config.h	256;"	d
_EVENT_HAVE_TIMERISSET	include/event2/event-config.h	331;"	d
_EVENT_HAVE_UINT16_T	include/event2/event-config.h	334;"	d
_EVENT_HAVE_UINT32_T	include/event2/event-config.h	337;"	d
_EVENT_HAVE_UINT64_T	include/event2/event-config.h	340;"	d
_EVENT_HAVE_UINT8_T	include/event2/event-config.h	343;"	d
_EVENT_HAVE_UINTPTR_T	include/event2/event-config.h	346;"	d
_EVENT_HAVE_UMASK	include/event2/event-config.h	349;"	d
_EVENT_HAVE_UNISTD_H	include/event2/event-config.h	352;"	d
_EVENT_HAVE_UNSETENV	include/event2/event-config.h	355;"	d
_EVENT_HAVE_VASPRINTF	include/event2/event-config.h	358;"	d
_EVENT_HT_H	ht-internal.h	9;"	d
_EVENT_H_	event.h	28;"	d
_EVENT_INTERNAL_H_	event-internal.h	28;"	d
_EVENT_IOCP_INTERNAL_H	iocp-internal.h	28;"	d
_EVENT_IPV6_INTERNAL_H	ipv6-internal.h	31;"	d
_EVENT_LOG_DEBUG	include/event2/event.h	574;"	d
_EVENT_LOG_ERR	include/event2/event.h	577;"	d
_EVENT_LOG_MSG	include/event2/event.h	575;"	d
_EVENT_LOG_WARN	include/event2/event.h	576;"	d
_EVENT_LT_OBJDIR	include/event2/event-config.h	368;"	d
_EVENT_MM_INTERNAL_H	mm-internal.h	27;"	d
_EVENT_NUMERIC_VERSION	WIN32-Code/event2/event-config.h	280;"	d
_EVENT_NUMERIC_VERSION	include/event2/event-config.h	374;"	d
_EVENT_PACKAGE	WIN32-Code/event2/event-config.h	283;"	d
_EVENT_PACKAGE	include/event2/event-config.h	377;"	d
_EVENT_PACKAGE_BUGREPORT	WIN32-Code/event2/event-config.h	286;"	d
_EVENT_PACKAGE_BUGREPORT	include/event2/event-config.h	380;"	d
_EVENT_PACKAGE_NAME	WIN32-Code/event2/event-config.h	289;"	d
_EVENT_PACKAGE_NAME	include/event2/event-config.h	383;"	d
_EVENT_PACKAGE_STRING	WIN32-Code/event2/event-config.h	292;"	d
_EVENT_PACKAGE_STRING	include/event2/event-config.h	386;"	d
_EVENT_PACKAGE_TARNAME	WIN32-Code/event2/event-config.h	295;"	d
_EVENT_PACKAGE_TARNAME	include/event2/event-config.h	389;"	d
_EVENT_PACKAGE_URL	include/event2/event-config.h	392;"	d
_EVENT_PACKAGE_VERSION	WIN32-Code/event2/event-config.h	298;"	d
_EVENT_PACKAGE_VERSION	include/event2/event-config.h	395;"	d
_EVENT_SIZEOF_INT	WIN32-Code/event2/event-config.h	305;"	d
_EVENT_SIZEOF_INT	include/event2/event-config.h	402;"	d
_EVENT_SIZEOF_LONG	WIN32-Code/event2/event-config.h	308;"	d
_EVENT_SIZEOF_LONG	include/event2/event-config.h	405;"	d
_EVENT_SIZEOF_LONG_LONG	WIN32-Code/event2/event-config.h	311;"	d
_EVENT_SIZEOF_LONG_LONG	include/event2/event-config.h	408;"	d
_EVENT_SIZEOF_OFF_T	include/event2/event-config.h	411;"	d
_EVENT_SIZEOF_PTHREAD_T	include/event2/event-config.h	414;"	d
_EVENT_SIZEOF_SHORT	WIN32-Code/event2/event-config.h	314;"	d
_EVENT_SIZEOF_SHORT	include/event2/event-config.h	417;"	d
_EVENT_SIZEOF_SIZE_T	WIN32-Code/event2/event-config.h	318;"	d
_EVENT_SIZEOF_SIZE_T	WIN32-Code/event2/event-config.h	320;"	d
_EVENT_SIZEOF_SIZE_T	include/event2/event-config.h	420;"	d
_EVENT_SIZEOF_VOID_P	WIN32-Code/event2/event-config.h	325;"	d
_EVENT_SIZEOF_VOID_P	WIN32-Code/event2/event-config.h	327;"	d
_EVENT_SIZEOF_VOID_P	include/event2/event-config.h	423;"	d
_EVENT_SIZEOF_VOID_P	include/event2/util.h	74;"	d
_EVENT_STDC_HEADERS	WIN32-Code/event2/event-config.h	331;"	d
_EVENT_STDC_HEADERS	include/event2/event-config.h	426;"	d
_EVENT_TIME_WITH_SYS_TIME	WIN32-Code/event2/event-config.h	334;"	d
_EVENT_TIME_WITH_SYS_TIME	include/event2/event-config.h	429;"	d
_EVENT_UTIL_INTERNAL_H	util-internal.h	27;"	d
_EVENT_VERSION	WIN32-Code/event2/event-config.h	337;"	d
_EVENT_VERSION	include/event2/event-config.h	432;"	d
_EVENT___func__	WIN32-Code/event2/event-config.h	340;"	d
_EVENT_inline	WIN32-Code/event2/event-config.h	348;"	d
_EVENT_socklen_t	WIN32-Code/event2/event-config.h	358;"	d
_EVENT_ssize_t	WIN32-Code/event2/event-config.h	361;"	d
_EVHTTP_H_	evhttp.h	28;"	d
_EVHTTP_REQ_UNKNOWN	http-internal.h	45;"	d
_EVLOCK_SORTLOCKS	evthread-internal.h	102;"	d
_EVLOCK_SORTLOCKS	evthread-internal.h	325;"	d
_EVMAP_H_	evmap-internal.h	27;"	d
_EVRPC_H_	evrpc.h	28;"	d
_EVRPC_INTERNAL_H_	evrpc-internal.h	28;"	d
_EVSIGNAL_H_	evsignal-internal.h	28;"	d
_EVTHREAD_INTERNAL_H_	evthread-internal.h	27;"	d
_EVUTIL_H_	evutil.h	27;"	d
_EVUTIL_NIL_CONDITION	util-internal.h	62;"	d
_EVUTIL_NIL_STMT	util-internal.h	56;"	d
_FILE_OFFSET_BITS	test/regress_zlib.c	74;"	d	file:
_FORTIFY_SOURCE	evdns.c	55;"	d	file:
_GNU_SOURCE	buffer.c	38;"	d	file:
_GNU_SOURCE	evthread_pthread.c	29;"	d	file:
_GNU_SOURCE	evutil.c	29;"	d	file:
_GNU_SOURCE	include/event2/util.h	61;"	d
_GNU_SOURCE	kqueue.c	31;"	d	file:
_HTTP_INTERNAL_H_	http-internal.h	11;"	d
_HT_BUCKET	ht-internal.h	117;"	d
_HT_ELT_HASH	ht-internal.h	105;"	d
_HT_ELT_HASH	ht-internal.h	110;"	d
_HT_FIND_OR_INSERT	ht-internal.h	422;"	d
_HT_FOI_INSERT	ht-internal.h	437;"	d
_HT_SET_HASH	ht-internal.h	101;"	d
_HT_SET_HASH	ht-internal.h	108;"	d
_HT_SET_HASHVAL	ht-internal.h	103;"	d
_HT_SET_HASHVAL	ht-internal.h	112;"	d
_LARGEFILE64_SOURCE	test/regress_zlib.c	68;"	d	file:
_LFS64_LARGEFILE	test/regress_zlib.c	71;"	d	file:
_LOG_H_	log-internal.h	28;"	d
_MIN_HEAP_H_	minheap-internal.h	29;"	d
_NAME	event_rpcgen.py	/^_NAME = "event_rpcgen.py"$/;"	v
_RATELIM_INTERNAL_H_	ratelim-internal.h	27;"	d
_REGRESS_H_	test/regress.h	28;"	d
_STRLCPY_INTERNAL_H_	strlcpy-internal.h	2;"	d
_SYS_QUEUE_H_	compat/sys/queue.h	36;"	d
_SYS_TREE_H_	WIN32-Code/tree.h	28;"	d
_SYS_TREE_H_	WIN32-Code/tree.h	705;"	d
_TESTUTILS_H	test/regress_testutils.h	28;"	d
_TINYTEST_H	test/tinytest.h	27;"	d
_TINYTEST_MACROS_H	test/tinytest_macros.h	27;"	d
_TT_ENABLED	test/tinytest.h	34;"	d
_URI_ADD	http.c	4355;"	d	file:
_URI_ADD	http.c	4409;"	d	file:
_URI_FREE_STR	http.c	4332;"	d	file:
_URI_FREE_STR	http.c	4345;"	d	file:
_URI_SET_STR	http.c	4448;"	d	file:
_VERSION	event_rpcgen.py	/^_VERSION = "0.1"$/;"	v
_WIN32_IE	evdns.c	80;"	d	file:
_WIN32_WINNT	event_iocp.c	29;"	d	file:
_WIN32_WINNT	evthread_win32.c	31;"	d	file:
_WIN32_WINNT	listener.c	34;"	d	file:
__anon14::code	evutil.c	/^static struct { int code; const char *msg; } windows_socket_errors[] = {$/;"	m	struct:__anon14	file:	access:public
__anon14::msg	evutil.c	/^static struct { int code; const char *msg; } windows_socket_errors[] = {$/;"	m	struct:__anon14	file:	access:public
__attribute__	test/tinytest.c	53;"	d	file:
__cdecl	signal.c	87;"	d	file:
__func__	sample/signal-test.c	30;"	d	file:
__func__	test/regress_main.c	46;"	d	file:
__func__	test/test-eof.c	52;"	d	file:
__func__	test/test-weof.c	55;"	d	file:
__func__	util-internal.h	52;"	d
__init__	event_rpcgen.py	/^        def __init__(self, why):$/;"	m	class:RpcGenError	access:public
__init__	event_rpcgen.py	/^    def __init__(self):$/;"	m	class:CCodeGenerator	access:public
__init__	event_rpcgen.py	/^    def __init__(self, argv):$/;"	m	class:CommandLine	access:public
__init__	event_rpcgen.py	/^    def __init__(self, argv0):$/;"	m	class:Usage	access:public
__init__	event_rpcgen.py	/^    def __init__(self, entry):$/;"	m	class:EntryArray	access:public
__init__	event_rpcgen.py	/^    def __init__(self, name):$/;"	m	class:Struct	access:public
__init__	event_rpcgen.py	/^    def __init__(self, name):$/;"	m	class:StructCCode	access:public
__init__	event_rpcgen.py	/^    def __init__(self, type, name, tag):$/;"	m	class:Entry	access:public
__init__	event_rpcgen.py	/^    def __init__(self, type, name, tag):$/;"	m	class:EntryString	access:public
__init__	event_rpcgen.py	/^    def __init__(self, type, name, tag):$/;"	m	class:EntryVarBytes	access:public
__init__	event_rpcgen.py	/^    def __init__(self, type, name, tag, bits=32):$/;"	m	class:EntryInt	access:public
__init__	event_rpcgen.py	/^    def __init__(self, type, name, tag, length):$/;"	m	class:EntryBytes	access:public
__init__	event_rpcgen.py	/^    def __init__(self, type, name, tag, refname):$/;"	m	class:EntryStruct	access:public
__str__	event_rpcgen.py	/^        def __str__(self):$/;"	m	class:RpcGenError	file:	access:private
_bev_group_random_element	bufferevent_ratelim.c	/^_bev_group_random_element(struct bufferevent_rate_limit_group *group)$/;"	f	file:	signature:(struct bufferevent_rate_limit_group *group)
_bev_group_refill_callback	bufferevent_ratelim.c	/^_bev_group_refill_callback(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
_bev_group_suspend_reading	bufferevent_ratelim.c	/^_bev_group_suspend_reading(struct bufferevent_rate_limit_group *g)$/;"	f	file:	signature:(struct bufferevent_rate_limit_group *g)
_bev_group_suspend_reading	bufferevent_ratelim.c	/^static int _bev_group_suspend_reading(struct bufferevent_rate_limit_group *g);$/;"	p	file:	signature:(struct bufferevent_rate_limit_group *g)
_bev_group_suspend_writing	bufferevent_ratelim.c	/^_bev_group_suspend_writing(struct bufferevent_rate_limit_group *g)$/;"	f	file:	signature:(struct bufferevent_rate_limit_group *g)
_bev_group_suspend_writing	bufferevent_ratelim.c	/^static int _bev_group_suspend_writing(struct bufferevent_rate_limit_group *g);$/;"	p	file:	signature:(struct bufferevent_rate_limit_group *g)
_bev_group_unsuspend_reading	bufferevent_ratelim.c	/^_bev_group_unsuspend_reading(struct bufferevent_rate_limit_group *g)$/;"	f	file:	signature:(struct bufferevent_rate_limit_group *g)
_bev_group_unsuspend_reading	bufferevent_ratelim.c	/^static void _bev_group_unsuspend_reading(struct bufferevent_rate_limit_group *g);$/;"	p	file:	signature:(struct bufferevent_rate_limit_group *g)
_bev_group_unsuspend_writing	bufferevent_ratelim.c	/^_bev_group_unsuspend_writing(struct bufferevent_rate_limit_group *g)$/;"	f	file:	signature:(struct bufferevent_rate_limit_group *g)
_bev_group_unsuspend_writing	bufferevent_ratelim.c	/^static void _bev_group_unsuspend_writing(struct bufferevent_rate_limit_group *g);$/;"	p	file:	signature:(struct bufferevent_rate_limit_group *g)
_bev_refill_callback	bufferevent_ratelim.c	/^_bev_refill_callback(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
_bufferevent_add_event	bufferevent-internal.h	/^int _bufferevent_add_event(struct event *ev, const struct timeval *tv);$/;"	p	signature:(struct event *ev, const struct timeval *tv)
_bufferevent_add_event	bufferevent.c	/^_bufferevent_add_event(struct event *ev, const struct timeval *tv)$/;"	f	signature:(struct event *ev, const struct timeval *tv)
_bufferevent_cancel_all	bufferevent.c	/^_bufferevent_cancel_all(struct bufferevent *bev)$/;"	f	file:	signature:(struct bufferevent *bev)
_bufferevent_cancel_all	bufferevent.c	/^static void _bufferevent_cancel_all(struct bufferevent *bev);$/;"	p	file:	signature:(struct bufferevent *bev)
_bufferevent_decref_and_unlock	bufferevent-internal.h	/^int _bufferevent_decref_and_unlock(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
_bufferevent_decref_and_unlock	bufferevent.c	/^_bufferevent_decref_and_unlock(struct bufferevent *bufev)$/;"	f	signature:(struct bufferevent *bufev)
_bufferevent_decrement_read_buckets	bufferevent-internal.h	/^int _bufferevent_decrement_read_buckets(struct bufferevent_private *bev,$/;"	p	signature:(struct bufferevent_private *bev, ev_ssize_t bytes)
_bufferevent_decrement_read_buckets	bufferevent_ratelim.c	/^_bufferevent_decrement_read_buckets(struct bufferevent_private *bev, ev_ssize_t bytes)$/;"	f	signature:(struct bufferevent_private *bev, ev_ssize_t bytes)
_bufferevent_decrement_write_buckets	bufferevent-internal.h	/^int _bufferevent_decrement_write_buckets(struct bufferevent_private *bev,$/;"	p	signature:(struct bufferevent_private *bev, ev_ssize_t bytes)
_bufferevent_decrement_write_buckets	bufferevent_ratelim.c	/^_bufferevent_decrement_write_buckets(struct bufferevent_private *bev, ev_ssize_t bytes)$/;"	f	signature:(struct bufferevent_private *bev, ev_ssize_t bytes)
_bufferevent_del_generic_timeout_cbs	bufferevent-internal.h	/^int _bufferevent_del_generic_timeout_cbs(struct bufferevent *bev);$/;"	p	signature:(struct bufferevent *bev)
_bufferevent_del_generic_timeout_cbs	bufferevent.c	/^_bufferevent_del_generic_timeout_cbs(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
_bufferevent_generic_adj_timeouts	bufferevent-internal.h	/^int _bufferevent_generic_adj_timeouts(struct bufferevent *bev);$/;"	p	signature:(struct bufferevent *bev)
_bufferevent_generic_adj_timeouts	bufferevent.c	/^_bufferevent_generic_adj_timeouts(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
_bufferevent_get_read_max	bufferevent-internal.h	/^ev_ssize_t _bufferevent_get_read_max(struct bufferevent_private *bev);$/;"	p	signature:(struct bufferevent_private *bev)
_bufferevent_get_read_max	bufferevent_ratelim.c	/^_bufferevent_get_read_max(struct bufferevent_private *bev)$/;"	f	signature:(struct bufferevent_private *bev)
_bufferevent_get_rlim_max	bufferevent_ratelim.c	/^_bufferevent_get_rlim_max(struct bufferevent_private *bev, int is_write)$/;"	f	file:	signature:(struct bufferevent_private *bev, int is_write)
_bufferevent_get_write_max	bufferevent-internal.h	/^ev_ssize_t _bufferevent_get_write_max(struct bufferevent_private *bev);$/;"	p	signature:(struct bufferevent_private *bev)
_bufferevent_get_write_max	bufferevent_ratelim.c	/^_bufferevent_get_write_max(struct bufferevent_private *bev)$/;"	f	signature:(struct bufferevent_private *bev)
_bufferevent_incref_and_lock	bufferevent-internal.h	/^void _bufferevent_incref_and_lock(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
_bufferevent_incref_and_lock	bufferevent.c	/^_bufferevent_incref_and_lock(struct bufferevent *bufev)$/;"	f	signature:(struct bufferevent *bufev)
_bufferevent_init_generic_timeout_cbs	bufferevent-internal.h	/^void _bufferevent_init_generic_timeout_cbs(struct bufferevent *bev);$/;"	p	signature:(struct bufferevent *bev)
_bufferevent_init_generic_timeout_cbs	bufferevent.c	/^_bufferevent_init_generic_timeout_cbs(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
_bufferevent_run_eventcb	bufferevent-internal.h	/^void _bufferevent_run_eventcb(struct bufferevent *bufev, short what);$/;"	p	signature:(struct bufferevent *bufev, short what)
_bufferevent_run_eventcb	bufferevent.c	/^_bufferevent_run_eventcb(struct bufferevent *bufev, short what)$/;"	f	signature:(struct bufferevent *bufev, short what)
_bufferevent_run_readcb	bufferevent-internal.h	/^void _bufferevent_run_readcb(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
_bufferevent_run_readcb	bufferevent.c	/^_bufferevent_run_readcb(struct bufferevent *bufev)$/;"	f	signature:(struct bufferevent *bufev)
_bufferevent_run_writecb	bufferevent-internal.h	/^void _bufferevent_run_writecb(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
_bufferevent_run_writecb	bufferevent.c	/^_bufferevent_run_writecb(struct bufferevent *bufev)$/;"	f	signature:(struct bufferevent *bufev)
_ev	include/event2/event_struct.h	/^	} _ev;$/;"	m	struct:event	typeref:union:event::__anon3	access:public
_evbuffer_chain_pin	buffer.c	/^_evbuffer_chain_pin(struct evbuffer_chain *chain, unsigned flag)$/;"	f	signature:(struct evbuffer_chain *chain, unsigned flag)
_evbuffer_chain_pin	evbuffer-internal.h	/^void _evbuffer_chain_pin(struct evbuffer_chain *chain, unsigned flag);$/;"	p	signature:(struct evbuffer_chain *chain, unsigned flag)
_evbuffer_chain_unpin	buffer.c	/^_evbuffer_chain_unpin(struct evbuffer_chain *chain, unsigned flag)$/;"	f	signature:(struct evbuffer_chain *chain, unsigned flag)
_evbuffer_chain_unpin	evbuffer-internal.h	/^void _evbuffer_chain_unpin(struct evbuffer_chain *chain, unsigned flag);$/;"	p	signature:(struct evbuffer_chain *chain, unsigned flag)
_evbuffer_decref_and_unlock	buffer.c	/^_evbuffer_decref_and_unlock(struct evbuffer *buffer)$/;"	f	signature:(struct evbuffer *buffer)
_evbuffer_decref_and_unlock	evbuffer-internal.h	/^void _evbuffer_decref_and_unlock(struct evbuffer *buffer);$/;"	p	signature:(struct evbuffer *buffer)
_evbuffer_expand_fast	buffer.c	/^_evbuffer_expand_fast(struct evbuffer *buf, size_t datlen, int n)$/;"	f	signature:(struct evbuffer *buf, size_t datlen, int n)
_evbuffer_expand_fast	evbuffer-internal.h	/^int _evbuffer_expand_fast(struct evbuffer *, size_t, int);$/;"	p	signature:(struct evbuffer *, size_t, int)
_evbuffer_incref	buffer.c	/^_evbuffer_incref(struct evbuffer *buf)$/;"	f	signature:(struct evbuffer *buf)
_evbuffer_incref	evbuffer-internal.h	/^void _evbuffer_incref(struct evbuffer *buf);$/;"	p	signature:(struct evbuffer *buf)
_evbuffer_incref_and_lock	buffer.c	/^_evbuffer_incref_and_lock(struct evbuffer *buf)$/;"	f	signature:(struct evbuffer *buf)
_evbuffer_incref_and_lock	evbuffer-internal.h	/^void _evbuffer_incref_and_lock(struct evbuffer *buf);$/;"	p	signature:(struct evbuffer *buf)
_evbuffer_overlapped_get_fd	buffer_iocp.c	/^_evbuffer_overlapped_get_fd(struct evbuffer *buf)$/;"	f	signature:(struct evbuffer *buf)
_evbuffer_overlapped_get_fd	iocp-internal.h	/^evutil_socket_t _evbuffer_overlapped_get_fd(struct evbuffer *buf);$/;"	p	signature:(struct evbuffer *buf)
_evbuffer_overlapped_set_fd	buffer_iocp.c	/^_evbuffer_overlapped_set_fd(struct evbuffer *buf, evutil_socket_t fd)$/;"	f	signature:(struct evbuffer *buf, evutil_socket_t fd)
_evbuffer_overlapped_set_fd	iocp-internal.h	/^void _evbuffer_overlapped_set_fd(struct evbuffer *buf, evutil_socket_t fd);$/;"	p	signature:(struct evbuffer *buf, evutil_socket_t fd)
_evbuffer_read_setup_vecs	buffer.c	/^_evbuffer_read_setup_vecs(struct evbuffer *buf, ev_ssize_t howmuch,$/;"	f	signature:(struct evbuffer *buf, ev_ssize_t howmuch, struct evbuffer_iovec *vecs, int n_vecs_avail, struct evbuffer_chain ***chainp, int exact)
_evbuffer_read_setup_vecs	evbuffer-internal.h	/^int _evbuffer_read_setup_vecs(struct evbuffer *buf, ev_ssize_t howmuch,$/;"	p	signature:(struct evbuffer *buf, ev_ssize_t howmuch, struct evbuffer_iovec *vecs, int n_vecs, struct evbuffer_chain ***chainp, int exact)
_evbuffer_testing_use_linear_file_access	buffer.c	/^_evbuffer_testing_use_linear_file_access(void)$/;"	f	signature:(void)
_evbuffer_testing_use_linear_file_access	buffer.c	/^int _evbuffer_testing_use_linear_file_access(void);$/;"	p	file:	signature:(void)
_evbuffer_testing_use_linear_file_access	test/regress_buffer.c	/^int _evbuffer_testing_use_linear_file_access(void);$/;"	p	file:	signature:(void)
_evbuffer_testing_use_mmap	buffer.c	/^_evbuffer_testing_use_mmap(void)$/;"	f	signature:(void)
_evbuffer_testing_use_mmap	buffer.c	/^int _evbuffer_testing_use_mmap(void);$/;"	p	file:	signature:(void)
_evbuffer_testing_use_mmap	test/regress_buffer.c	/^int _evbuffer_testing_use_mmap(void);$/;"	p	file:	signature:(void)
_evbuffer_testing_use_sendfile	buffer.c	/^_evbuffer_testing_use_sendfile(void)$/;"	f	signature:(void)
_evbuffer_testing_use_sendfile	buffer.c	/^int _evbuffer_testing_use_sendfile(void);$/;"	p	file:	signature:(void)
_evbuffer_testing_use_sendfile	test/regress_buffer.c	/^int _evbuffer_testing_use_sendfile(void);$/;"	p	file:	signature:(void)
_evbuffer_validate	test/regress_buffer.c	/^_evbuffer_validate(struct evbuffer *buf)$/;"	f	file:	signature:(struct evbuffer *buf)
_evdns_log	evdns.c	/^_evdns_log(int warn, const char *fmt, ...)$/;"	f	file:	signature:(int warn, const char *fmt, ...)
_evdns_nameserver_add_impl	evdns.c	/^_evdns_nameserver_add_impl(struct evdns_base *base, const struct sockaddr *address, int addrlen) {$/;"	f	file:	signature:(struct evdns_base *base, const struct sockaddr *address, int addrlen)
_event_debug_assert_is_setup	event.c	274;"	d	file:
_event_debug_assert_not_added	event.c	293;"	d	file:
_event_debug_map_lock	event.c	/^static void *_event_debug_map_lock = NULL;$/;"	v	file:
_event_debug_mode_on	event.c	/^int _event_debug_mode_on = 0;$/;"	v
_event_debug_note_add	event.c	232;"	d	file:
_event_debug_note_del	event.c	253;"	d	file:
_event_debug_note_setup	event.c	197;"	d	file:
_event_debug_note_teardown	event.c	219;"	d	file:
_event_debugx	log.c	/^_event_debugx(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
_event_iocp_port_unlock_and_free	event_iocp.c	/^_event_iocp_port_unlock_and_free(struct event_iocp_port *port)$/;"	f	file:	signature:(struct event_iocp_port *port)
_event_strlcpy	strlcpy-internal.h	/^size_t _event_strlcpy(char *dst, const char *src, size_t siz);$/;"	p	signature:(char *dst, const char *src, size_t siz)
_event_strlcpy	strlcpy.c	/^_event_strlcpy(dst, src, siz)$/;"	f
_evrpc_hooks	evrpc-internal.h	/^struct _evrpc_hooks {$/;"	s
_evrpc_hooks::in_hooks	evrpc-internal.h	/^	struct evrpc_hook_list in_hooks;$/;"	m	struct:_evrpc_hooks	typeref:struct:_evrpc_hooks::evrpc_hook_list	access:public
_evrpc_hooks::out_hooks	evrpc-internal.h	/^	struct evrpc_hook_list out_hooks;$/;"	m	struct:_evrpc_hooks	typeref:struct:_evrpc_hooks::evrpc_hook_list	access:public
_evrpc_hooks::pause_requests	evrpc-internal.h	/^	struct evrpc_pause_list pause_requests;$/;"	m	struct:_evrpc_hooks	typeref:struct:_evrpc_hooks::evrpc_pause_list	access:public
_evsig_restore_handler	event-internal.h	/^int _evsig_restore_handler(struct event_base *base, int evsignal);$/;"	p	signature:(struct event_base *base, int evsignal)
_evsig_restore_handler	signal.c	/^_evsig_restore_handler(struct event_base *base, int evsignal)$/;"	f	signature:(struct event_base *base, int evsignal)
_evsig_set_handler	event-internal.h	/^int _evsig_set_handler(struct event_base *base, int evsignal,$/;"	p	signature:(struct event_base *base, int evsignal, void (*fn)(int))
_evsig_set_handler	signal.c	/^_evsig_set_handler(struct event_base *base,$/;"	f	signature:(struct event_base *base, int evsignal, void (__cdecl *handler)(int))
_evthread_cond_fns	evthread.c	/^GLOBAL struct evthread_condition_callbacks _evthread_cond_fns = {$/;"	v	typeref:struct:evthread_condition_callbacks
_evthread_debug_get_real_lock	evthread-internal.h	/^void *_evthread_debug_get_real_lock(void *lock);$/;"	p	signature:(void *lock)
_evthread_debug_get_real_lock	evthread.c	/^_evthread_debug_get_real_lock(void *lock_)$/;"	f	signature:(void *lock_)
_evthread_id_fn	evthread.c	/^GLOBAL unsigned long (*_evthread_id_fn)(void) = NULL;$/;"	v
_evthread_is_debug_lock_held	evthread-internal.h	/^int _evthread_is_debug_lock_held(void *lock);$/;"	p	signature:(void *lock)
_evthread_is_debug_lock_held	evthread.c	/^_evthread_is_debug_lock_held(void *lock_)$/;"	f	signature:(void *lock_)
_evthread_lock_debugging_enabled	evthread.c	/^GLOBAL int _evthread_lock_debugging_enabled = 0;$/;"	v
_evthread_lock_fns	evthread.c	/^GLOBAL struct evthread_lock_callbacks _evthread_lock_fns = {$/;"	v	typeref:struct:evthread_lock_callbacks
_evthreadimpl_cond_alloc	evthread-internal.h	/^void *_evthreadimpl_cond_alloc(unsigned condtype);$/;"	p	signature:(unsigned condtype)
_evthreadimpl_cond_alloc	evthread.c	/^_evthreadimpl_cond_alloc(unsigned condtype)$/;"	f	signature:(unsigned condtype)
_evthreadimpl_cond_free	evthread-internal.h	/^void _evthreadimpl_cond_free(void *cond);$/;"	p	signature:(void *cond)
_evthreadimpl_cond_free	evthread.c	/^_evthreadimpl_cond_free(void *cond)$/;"	f	signature:(void *cond)
_evthreadimpl_cond_signal	evthread-internal.h	/^int _evthreadimpl_cond_signal(void *cond, int broadcast);$/;"	p	signature:(void *cond, int broadcast)
_evthreadimpl_cond_signal	evthread.c	/^_evthreadimpl_cond_signal(void *cond, int broadcast)$/;"	f	signature:(void *cond, int broadcast)
_evthreadimpl_cond_wait	evthread-internal.h	/^int _evthreadimpl_cond_wait(void *cond, void *lock, const struct timeval *tv);$/;"	p	signature:(void *cond, void *lock, const struct timeval *tv)
_evthreadimpl_cond_wait	evthread.c	/^_evthreadimpl_cond_wait(void *cond, void *lock, const struct timeval *tv)$/;"	f	signature:(void *cond, void *lock, const struct timeval *tv)
_evthreadimpl_get_id	evthread-internal.h	/^unsigned long _evthreadimpl_get_id(void);$/;"	p	signature:(void)
_evthreadimpl_get_id	evthread.c	/^_evthreadimpl_get_id()$/;"	f
_evthreadimpl_is_lock_debugging_enabled	evthread-internal.h	/^int _evthreadimpl_is_lock_debugging_enabled(void);$/;"	p	signature:(void)
_evthreadimpl_is_lock_debugging_enabled	evthread.c	/^_evthreadimpl_is_lock_debugging_enabled(void)$/;"	f	signature:(void)
_evthreadimpl_lock_alloc	evthread-internal.h	/^void *_evthreadimpl_lock_alloc(unsigned locktype);$/;"	p	signature:(unsigned locktype)
_evthreadimpl_lock_alloc	evthread.c	/^_evthreadimpl_lock_alloc(unsigned locktype)$/;"	f	signature:(unsigned locktype)
_evthreadimpl_lock_free	evthread-internal.h	/^void _evthreadimpl_lock_free(void *lock, unsigned locktype);$/;"	p	signature:(void *lock, unsigned locktype)
_evthreadimpl_lock_free	evthread.c	/^_evthreadimpl_lock_free(void *lock, unsigned locktype)$/;"	f	signature:(void *lock, unsigned locktype)
_evthreadimpl_lock_lock	evthread-internal.h	/^int _evthreadimpl_lock_lock(unsigned mode, void *lock);$/;"	p	signature:(unsigned mode, void *lock)
_evthreadimpl_lock_lock	evthread.c	/^_evthreadimpl_lock_lock(unsigned mode, void *lock)$/;"	f	signature:(unsigned mode, void *lock)
_evthreadimpl_lock_unlock	evthread-internal.h	/^int _evthreadimpl_lock_unlock(unsigned mode, void *lock);$/;"	p	signature:(unsigned mode, void *lock)
_evthreadimpl_lock_unlock	evthread.c	/^_evthreadimpl_lock_unlock(unsigned mode, void *lock)$/;"	f	signature:(unsigned mode, void *lock)
_evthreadimpl_locking_enabled	evthread-internal.h	/^int _evthreadimpl_locking_enabled(void);$/;"	p	signature:(void)
_evthreadimpl_locking_enabled	evthread.c	/^_evthreadimpl_locking_enabled(void)$/;"	f	signature:(void)
_evutil_weakrand	evutil.c	/^_evutil_weakrand(void)$/;"	f	signature:(void)
_evutil_weakrand	util-internal.h	/^long _evutil_weakrand(void);$/;"	p	signature:(void)
_http_close_detection	test/regress_http.c	/^_http_close_detection(struct basic_test_data *data, int with_delay)$/;"	f	file:	signature:(struct basic_test_data *data, int with_delay)
_http_connection_test	test/regress_http.c	/^_http_connection_test(struct basic_test_data *data, int persistent)$/;"	f	file:	signature:(struct basic_test_data *data, int persistent)
_http_incomplete_test	test/regress_http.c	/^_http_incomplete_test(struct basic_test_data *data, int use_timeout)$/;"	f	file:	signature:(struct basic_test_data *data, int use_timeout)
_http_stream_in_test	test/regress_http.c	/^_http_stream_in_test(struct basic_test_data *data, char const *url,$/;"	f	file:	signature:(struct basic_test_data *data, char const *url, size_t expected_len, char const *expected)
_internal	include/event2/buffer.h	/^	} _internal;$/;"	m	struct:evbuffer_ptr	typeref:struct:evbuffer_ptr::__anon1	access:public
_mm_free_fn	event.c	/^static void (*_mm_free_fn)(void *p) = NULL;$/;"	v	file:
_mm_malloc_fn	event.c	/^static void *(*_mm_malloc_fn)(size_t sz) = NULL;$/;"	v	file:
_mm_realloc_fn	event.c	/^static void *(*_mm_realloc_fn)(void *p, size_t sz) = NULL;$/;"	v	file:
_original_cond_fns	evthread.c	/^static struct evthread_condition_callbacks _original_cond_fns = {$/;"	v	typeref:struct:evthread_condition_callbacks	file:
_original_lock_fns	evthread.c	/^static struct evthread_lock_callbacks _original_lock_fns = {$/;"	v	typeref:struct:evthread_lock_callbacks	file:
_rpc_hook_ctx	test/regress_rpc.c	/^struct _rpc_hook_ctx {$/;"	s	file:
_rpc_hook_ctx::ctx	test/regress_rpc.c	/^	void *ctx;$/;"	m	struct:_rpc_hook_ctx	file:	access:public
_rpc_hook_ctx::vbase	test/regress_rpc.c	/^	void *vbase;$/;"	m	struct:_rpc_hook_ctx	file:	access:public
_test_ai_eq	test/regress.h	/^int _test_ai_eq(const struct evutil_addrinfo *ai, const char *sockaddr_port,$/;"	p	signature:(const struct evutil_addrinfo *ai, const char *sockaddr_port, int socktype, int protocol, int line)
_test_ai_eq	test/regress_util.c	/^_test_ai_eq(const struct evutil_addrinfo *ai, const char *sockaddr_port,$/;"	f	signature:(const struct evutil_addrinfo *ai, const char *sockaddr_port, int socktype, int protocol, int line)
_testcase_run_bare	test/tinytest.c	/^_testcase_run_bare(const struct testcase_t *testcase)$/;"	f	file:	signature:(const struct testcase_t *testcase)
_testcase_run_forked	test/tinytest.c	/^_testcase_run_forked(const struct testgroup_t *group,$/;"	f	file:	signature:(const struct testgroup_t *group, const struct testcase_t *testcase)
_tinytest_get_verbosity	test/tinytest.c	/^_tinytest_get_verbosity(void)$/;"	f	signature:(void)
_tinytest_get_verbosity	test/tinytest.h	/^int _tinytest_get_verbosity(void);$/;"	p	signature:(void)
_tinytest_set_flag	test/tinytest.c	/^_tinytest_set_flag(struct testgroup_t *groups, const char *arg, unsigned long flag)$/;"	f	signature:(struct testgroup_t *groups, const char *arg, unsigned long flag)
_tinytest_set_flag	test/tinytest.h	/^int _tinytest_set_flag(struct testgroup_t *, const char *, unsigned long);$/;"	p	signature:(struct testgroup_t *, const char *, unsigned long)
_tinytest_set_test_failed	test/tinytest.c	/^_tinytest_set_test_failed(void)$/;"	f	signature:(void)
_tinytest_set_test_failed	test/tinytest.h	/^void _tinytest_set_test_failed(void);$/;"	p	signature:(void)
_tinytest_set_test_skipped	test/tinytest.c	/^_tinytest_set_test_skipped(void)$/;"	f	signature:(void)
_tinytest_set_test_skipped	test/tinytest.h	/^void _tinytest_set_test_skipped(void);$/;"	p	signature:(void)
_tt_want	test/tinytest_macros.h	89;"	d
_warn_helper	log.c	/^_warn_helper(int severity, const char *errstr, const char *fmt, va_list ap)$/;"	f	file:	signature:(int severity, const char *errstr, const char *fmt, va_list ap)
_warn_helper	log.c	/^static void _warn_helper(int severity, const char *errstr, const char *fmt,$/;"	p	file:	signature:(int severity, const char *errstr, const char *fmt, va_list ap)
a	evdns.c	/^		} a;$/;"	m	union:reply::__anon8	typeref:struct:reply::__anon8::__anon9	file:	access:public
a	minheap-internal.h	/^	unsigned n, a;$/;"	m	struct:min_heap	access:public
a	test/regress_util.c	/^	const char *a;$/;"	m	struct:example_struct	file:	access:public
aaaa	evdns.c	/^		} aaaa;$/;"	m	union:reply::__anon8	typeref:struct:reply::__anon8::__anon10	file:	access:public
abs_builddir	Makefile	/^abs_builddir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent$/;"	m
abs_builddir	include/Makefile	/^abs_builddir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/include$/;"	m
abs_builddir	sample/Makefile	/^abs_builddir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/sample$/;"	m
abs_builddir	test/Makefile	/^abs_builddir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/test$/;"	m
abs_srcdir	Makefile	/^abs_srcdir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent$/;"	m
abs_srcdir	include/Makefile	/^abs_srcdir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/include$/;"	m
abs_srcdir	sample/Makefile	/^abs_srcdir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/sample$/;"	m
abs_srcdir	test/Makefile	/^abs_srcdir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/test$/;"	m
abs_top_builddir	Makefile	/^abs_top_builddir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent$/;"	m
abs_top_builddir	include/Makefile	/^abs_top_builddir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent$/;"	m
abs_top_builddir	sample/Makefile	/^abs_top_builddir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent$/;"	m
abs_top_builddir	test/Makefile	/^abs_top_builddir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent$/;"	m
abs_top_srcdir	Makefile	/^abs_top_srcdir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent$/;"	m
abs_top_srcdir	include/Makefile	/^abs_top_srcdir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent$/;"	m
abs_top_srcdir	sample/Makefile	/^abs_top_srcdir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent$/;"	m
abs_top_srcdir	test/Makefile	/^abs_top_srcdir = \/home\/lhh\/workspace\/lhh\/3rd\/libevent$/;"	m
ac_ct_AR	Makefile	/^ac_ct_AR = ar$/;"	m
ac_ct_AR	include/Makefile	/^ac_ct_AR = ar$/;"	m
ac_ct_AR	sample/Makefile	/^ac_ct_AR = ar$/;"	m
ac_ct_AR	test/Makefile	/^ac_ct_AR = ar$/;"	m
ac_ct_CC	Makefile	/^ac_ct_CC = gcc$/;"	m
ac_ct_CC	include/Makefile	/^ac_ct_CC = gcc$/;"	m
ac_ct_CC	sample/Makefile	/^ac_ct_CC = gcc$/;"	m
ac_ct_CC	test/Makefile	/^ac_ct_CC = gcc$/;"	m
ac_ct_DUMPBIN	Makefile	/^ac_ct_DUMPBIN = $/;"	m
ac_ct_DUMPBIN	include/Makefile	/^ac_ct_DUMPBIN = $/;"	m
ac_ct_DUMPBIN	sample/Makefile	/^ac_ct_DUMPBIN = $/;"	m
ac_ct_DUMPBIN	test/Makefile	/^ac_ct_DUMPBIN = $/;"	m
ac_fn_c_check_decl	configure	/^ac_fn_c_check_decl ()$/;"	f
ac_fn_c_check_func	configure	/^ac_fn_c_check_func ()$/;"	f
ac_fn_c_check_header_compile	configure	/^ac_fn_c_check_header_compile ()$/;"	f
ac_fn_c_check_header_mongrel	configure	/^ac_fn_c_check_header_mongrel ()$/;"	f
ac_fn_c_check_member	configure	/^ac_fn_c_check_member ()$/;"	f
ac_fn_c_check_type	configure	/^ac_fn_c_check_type ()$/;"	f
ac_fn_c_compute_int	configure	/^ac_fn_c_compute_int ()$/;"	f
ac_fn_c_try_compile	configure	/^ac_fn_c_try_compile ()$/;"	f
ac_fn_c_try_cpp	configure	/^ac_fn_c_try_cpp ()$/;"	f
ac_fn_c_try_link	configure	/^ac_fn_c_try_link ()$/;"	f
ac_fn_c_try_run	configure	/^ac_fn_c_try_run ()$/;"	f
accept_cb	sample/le-proxy.c	/^accept_cb(struct evconnlistener *listener, evutil_socket_t fd,$/;"	f	file:	signature:(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *a, int slen, void *p)
accept_socket_cb	http.c	/^accept_socket_cb(struct evconnlistener *listener, evutil_socket_t nfd, struct sockaddr *peer_sa, int peer_socklen, void *arg)$/;"	f	file:	signature:(struct evconnlistener *listener, evutil_socket_t nfd, struct sockaddr *peer_sa, int peer_socklen, void *arg)
acceptcb	test/regress_listener.c	/^acceptcb(struct evconnlistener *listener, evutil_socket_t fd,$/;"	f	file:	signature:(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *addr, int socklen, void *arg)
acceptcb	test/regress_ssl.c	/^acceptcb(struct evconnlistener *listener, evutil_socket_t fd,$/;"	f	file:	signature:(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *addr, int socklen, void *arg)
accepted_socket_cb	listener.c	/^accepted_socket_cb(struct event_overlapped *o, ev_uintptr_t key, ev_ssize_t n, int ok)$/;"	f	file:	signature:(struct event_overlapped *o, ev_uintptr_t key, ev_ssize_t n, int ok)
accepted_socket_cb	listener.c	/^static void accepted_socket_cb(struct event_overlapped *o, ev_uintptr_t key,$/;"	p	file:	signature:(struct event_overlapped *o, ev_uintptr_t key, ev_ssize_t n, int ok)
accepted_socket_invoke_user_cb	listener.c	/^accepted_socket_invoke_user_cb(struct deferred_cb *dcb, void *arg)$/;"	f	file:	signature:(struct deferred_cb *dcb, void *arg)
accepted_socket_invoke_user_cb	listener.c	/^static void accepted_socket_invoke_user_cb(struct deferred_cb *cb, void *arg);$/;"	p	file:	signature:(struct deferred_cb *cb, void *arg)
accepting	listener.c	/^	struct accepting_socket **accepting;$/;"	m	struct:evconnlistener_iocp	typeref:struct:evconnlistener_iocp::accepting_socket	file:	access:public
accepting_socket	listener.c	/^struct accepting_socket {$/;"	s	file:
accepting_socket::addrbuf	listener.c	/^	char addrbuf[1];$/;"	m	struct:accepting_socket	file:	access:public
accepting_socket::buflen	listener.c	/^	ev_uint8_t buflen;$/;"	m	struct:accepting_socket	file:	access:public
accepting_socket::deferred	listener.c	/^	struct deferred_cb deferred;$/;"	m	struct:accepting_socket	typeref:struct:accepting_socket::deferred_cb	file:	access:public
accepting_socket::error	listener.c	/^	int error;$/;"	m	struct:accepting_socket	file:	access:public
accepting_socket::family	listener.c	/^	ev_uint8_t family;$/;"	m	struct:accepting_socket	file:	access:public
accepting_socket::free_on_cb	listener.c	/^	unsigned free_on_cb:1;$/;"	m	struct:accepting_socket	file:	access:public
accepting_socket::lev	listener.c	/^	struct evconnlistener_iocp *lev;$/;"	m	struct:accepting_socket	typeref:struct:accepting_socket::evconnlistener_iocp	file:	access:public
accepting_socket::lock	listener.c	/^	CRITICAL_SECTION lock;$/;"	m	struct:accepting_socket	file:	access:public
accepting_socket::overlapped	listener.c	/^	struct event_overlapped overlapped;$/;"	m	struct:accepting_socket	typeref:struct:accepting_socket::event_overlapped	file:	access:public
accepting_socket::s	listener.c	/^	SOCKET s;$/;"	m	struct:accepting_socket	file:	access:public
activate_cb	test/regress.c	/^activate_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
active_count	defer-internal.h	/^	int active_count;$/;"	m	struct:deferred_cb_queue	access:public
activequeues	event-internal.h	/^	struct event_list *activequeues;$/;"	m	struct:event_base	typeref:struct:event_base::event_list	access:public
acx_pthread_config	Makefile	/^acx_pthread_config = $/;"	m
acx_pthread_config	include/Makefile	/^acx_pthread_config = $/;"	m
acx_pthread_config	sample/Makefile	/^acx_pthread_config = $/;"	m
acx_pthread_config	test/Makefile	/^acx_pthread_config = $/;"	m
add	event-internal.h	/^	int (*add)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);$/;"	m	struct:eventop	access:public
add_cname_to_reply	evdns.c	/^add_cname_to_reply(struct evdns_getaddrinfo_request *data,$/;"	f	file:	signature:(struct evdns_getaddrinfo_request *data, struct evutil_addrinfo *ai)
added	event.c	/^	unsigned added : 1;$/;"	m	struct:event_debug_entry	file:	access:public
additional	evdns.c	/^	struct server_reply_item *additional; \/* linked list of additional RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:	access:public
addr	evdns.c	/^	struct sockaddr_storage addr; \/* Where to send the response *\/$/;"	m	struct:server_request	typeref:struct:server_request::sockaddr_storage	file:	access:public
addr	evdns.c	/^	} addr;$/;"	m	struct:hosts_entry	typeref:union:hosts_entry::__anon12	file:	access:public
addr	test/regress_util.c	/^	const char *addr;$/;"	m	struct:ipv4_entry	file:	access:public
addr	test/regress_util.c	/^	const char *addr;$/;"	m	struct:ipv6_entry	file:	access:public
addr	test/regress_util.c	/^	const char *addr;$/;"	m	struct:sa_port_ent	file:	access:public
addrbuf	listener.c	/^	char addrbuf[1];$/;"	m	struct:accepting_socket	file:	access:public
addrcount	evdns.c	/^			u32 addrcount;$/;"	m	struct:reply::__anon8::__anon10	file:	access:public
addrcount	evdns.c	/^			u32 addrcount;$/;"	m	struct:reply::__anon8::__anon9	file:	access:public
address	evdns.c	/^	struct sockaddr_storage address;$/;"	m	struct:nameserver	typeref:struct:nameserver::sockaddr_storage	file:	access:public
address	http-internal.h	/^	char *address;			\/* address to connect to *\/$/;"	m	struct:evhttp_connection	access:public
addresses	evdns.c	/^			struct in6_addr addresses[MAX_V6_ADDRS];$/;"	m	struct:reply::__anon8::__anon10	typeref:struct:reply::__anon8::__anon10::in6_addr	file:	access:public
addresses	evdns.c	/^			u32 addresses[MAX_V4_ADDRS];$/;"	m	struct:reply::__anon8::__anon9	file:	access:public
addrinfo_from_hostent	evutil.c	/^addrinfo_from_hostent(const struct hostent *ent,$/;"	f	file:	signature:(const struct hostent *ent, int port, const struct evutil_addrinfo *hints)
addrlen	evdns.c	/^	ev_socklen_t addrlen; \/* length of addr *\/$/;"	m	struct:server_request	file:	access:public
addrlen	evdns.c	/^	ev_socklen_t addrlen;$/;"	m	struct:nameserver	file:	access:public
addrlen	evdns.c	/^	int addrlen;$/;"	m	struct:hosts_entry	file:	access:public
addrs	test/regress_dns.c	/^	void *addrs;$/;"	m	struct:generic_dns_callback_result	file:	access:public
addrs_buf	test/regress_dns.c	/^	char addrs_buf[256];$/;"	m	struct:generic_dns_callback_result	file:	access:public
addrs_len	test/regress_dns.c	/^	size_t addrs_len;$/;"	m	struct:generic_dns_callback_result	file:	access:public
adj_timeouts	bufferevent-internal.h	/^	int (*adj_timeouts)(struct bufferevent *);$/;"	m	struct:bufferevent_ops	access:public
advance_last_with_data	buffer.c	/^advance_last_with_data(struct evbuffer *buf)$/;"	f	file:	signature:(struct evbuffer *buf)
ai	test/regress_dns.c	/^	struct evutil_addrinfo *ai;$/;"	m	struct:gai_outcome	typeref:struct:gai_outcome::evutil_addrinfo	file:	access:public
ai_addr	include/event2/util.h	/^	struct sockaddr  *ai_addr; \/* binary address *\/$/;"	m	struct:evutil_addrinfo	typeref:struct:evutil_addrinfo::sockaddr	access:public
ai_addrlen	include/event2/util.h	/^	size_t  ai_addrlen;   \/* length of ai_addr *\/$/;"	m	struct:evutil_addrinfo	access:public
ai_canonname	include/event2/util.h	/^	char   *ai_canonname; \/* canonical name for nodename *\/$/;"	m	struct:evutil_addrinfo	access:public
ai_family	include/event2/util.h	/^	int     ai_family;    \/* PF_xxx *\/$/;"	m	struct:evutil_addrinfo	access:public
ai_find_by_family	test/regress.h	/^struct evutil_addrinfo *ai_find_by_family(struct evutil_addrinfo *ai, int f);$/;"	p	signature:(struct evutil_addrinfo *ai, int f)
ai_find_by_family	test/regress_util.c	/^ai_find_by_family(struct evutil_addrinfo *ai, int family)$/;"	f	signature:(struct evutil_addrinfo *ai, int family)
ai_find_by_protocol	test/regress.h	/^struct evutil_addrinfo *ai_find_by_protocol(struct evutil_addrinfo *ai, int p);$/;"	p	signature:(struct evutil_addrinfo *ai, int p)
ai_find_by_protocol	test/regress_util.c	/^ai_find_by_protocol(struct evutil_addrinfo *ai, int protocol)$/;"	f	signature:(struct evutil_addrinfo *ai, int protocol)
ai_flags	include/event2/util.h	/^	int     ai_flags;     \/* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST *\/$/;"	m	struct:evutil_addrinfo	access:public
ai_next	include/event2/util.h	/^	struct evutil_addrinfo  *ai_next; \/* next structure in linked list *\/$/;"	m	struct:evutil_addrinfo	typeref:struct:evutil_addrinfo::evutil_addrinfo	access:public
ai_protocol	include/event2/util.h	/^	int     ai_protocol;  \/* 0 or IPPROTO_xxx for IPv4 and IPv6 *\/$/;"	m	struct:evutil_addrinfo	access:public
ai_socktype	include/event2/util.h	/^	int     ai_socktype;  \/* SOCK_xxx *\/$/;"	m	struct:evutil_addrinfo	access:public
alerted_at	test/regress_thread.c	/^	struct timeval alerted_at;$/;"	m	struct:alerted_record	typeref:struct:alerted_record::timeval	file:	access:public
alerted_record	test/regress_thread.c	/^struct alerted_record {$/;"	s	file:
alerted_record::alerted_at	test/regress_thread.c	/^	struct timeval alerted_at;$/;"	m	struct:alerted_record	typeref:struct:alerted_record::timeval	file:	access:public
alerted_record::cond	test/regress_thread.c	/^	struct cond_wait *cond;$/;"	m	struct:alerted_record	typeref:struct:alerted_record::cond_wait	file:	access:public
alerted_record::delay	test/regress_thread.c	/^	struct timeval delay;$/;"	m	struct:alerted_record	typeref:struct:alerted_record::timeval	file:	access:public
alerted_record::timed_out	test/regress_thread.c	/^	int timed_out;$/;"	m	struct:alerted_record	file:	access:public
alias	http-internal.h	/^	char *alias; \/* the server alias. *\/$/;"	m	struct:evhttp_server_alias	access:public
aliases	http-internal.h	/^	TAILQ_HEAD(aliasq, evhttp_server_alias) aliases;$/;"	m	struct:evhttp	access:public
alloc	include/event2/thread.h	/^	void *(*alloc)(unsigned locktype);$/;"	m	struct:evthread_lock_callbacks	access:public
alloc_condition	include/event2/thread.h	/^	void *(*alloc_condition)(unsigned condtype);$/;"	m	struct:evthread_condition_callbacks	access:public
allocated_chunks	test/regress_dns.c	/^static int allocated_chunks = 0;$/;"	v	file:
allow_dirty_shutdown	bufferevent_openssl.c	/^	unsigned allow_dirty_shutdown : 1;$/;"	m	struct:bufferevent_openssl	file:	access:public
allowed_methods	http-internal.h	/^	ev_uint16_t allowed_methods;$/;"	m	struct:evhttp	access:public
am__CONFIG_DISTCLEAN_FILES	Makefile	/^am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\$/;"	m
am__DEPENDENCIES_1	Makefile	/^am__DEPENDENCIES_1 =$/;"	m
am__DEPENDENCIES_1	sample/Makefile	/^am__DEPENDENCIES_1 =$/;"	m
am__DEPENDENCIES_1	test/Makefile	/^am__DEPENDENCIES_1 =$/;"	m
am__DEPENDENCIES_2	sample/Makefile	/^am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1) ..\/libevent.la$/;"	m
am__DEPENDENCIES_2	test/Makefile	/^am__DEPENDENCIES_2 = $(am__append_3)$/;"	m
am__EXEEXT_1	test/Makefile	/^am__EXEEXT_1 = regress$(EXEEXT)$/;"	m
am__aclocal_m4_deps	Makefile	/^am__aclocal_m4_deps = $(top_srcdir)\/m4\/ac_backport_259_ssizet.m4 \\$/;"	m
am__aclocal_m4_deps	include/Makefile	/^am__aclocal_m4_deps = $(top_srcdir)\/m4\/ac_backport_259_ssizet.m4 \\$/;"	m
am__aclocal_m4_deps	sample/Makefile	/^am__aclocal_m4_deps = $(top_srcdir)\/m4\/ac_backport_259_ssizet.m4 \\$/;"	m
am__aclocal_m4_deps	test/Makefile	/^am__aclocal_m4_deps = $(top_srcdir)\/m4\/ac_backport_259_ssizet.m4 \\$/;"	m
am__append_1	Makefile	/^am__append_1 = libevent_pthreads.la$/;"	m
am__append_1	test/Makefile	/^am__append_1 = regress$/;"	m
am__append_11	Makefile	/^am__append_11 = signal.c$/;"	m
am__append_2	Makefile	/^am__append_2 = libevent_pthreads.pc$/;"	m
am__append_2	test/Makefile	/^am__append_2 = regress.gen.c regress.gen.h$/;"	m
am__append_3	test/Makefile	/^am__append_3 = ..\/libevent_pthreads.la$/;"	m
am__append_5	Makefile	/^am__append_5 = select.c$/;"	m
am__append_6	Makefile	/^am__append_6 = poll.c$/;"	m
am__append_9	Makefile	/^am__append_9 = epoll.c$/;"	m
am__base_list	Makefile	/^am__base_list = \\$/;"	m
am__base_list	include/Makefile	/^am__base_list = \\$/;"	m
am__can_run_installinfo	Makefile	/^am__can_run_installinfo = \\$/;"	m
am__can_run_installinfo	include/Makefile	/^am__can_run_installinfo = \\$/;"	m
am__can_run_installinfo	sample/Makefile	/^am__can_run_installinfo = \\$/;"	m
am__can_run_installinfo	test/Makefile	/^am__can_run_installinfo = \\$/;"	m
am__cd	Makefile	/^am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd$/;"	m
am__cd	include/Makefile	/^am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd$/;"	m
am__cd	sample/Makefile	/^am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd$/;"	m
am__cd	test/Makefile	/^am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd$/;"	m
am__configure_deps	Makefile	/^am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\$/;"	m
am__configure_deps	include/Makefile	/^am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\$/;"	m
am__configure_deps	sample/Makefile	/^am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\$/;"	m
am__configure_deps	test/Makefile	/^am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\$/;"	m
am__depfiles_maybe	Makefile	/^am__depfiles_maybe = depfiles$/;"	m
am__depfiles_maybe	sample/Makefile	/^am__depfiles_maybe =$/;"	m
am__depfiles_maybe	test/Makefile	/^am__depfiles_maybe = depfiles$/;"	m
am__dist_bin_SCRIPTS_DIST	Makefile	/^am__dist_bin_SCRIPTS_DIST = event_rpcgen.py$/;"	m
am__distuninstallcheck_listfiles	Makefile	/^am__distuninstallcheck_listfiles = $(distuninstallcheck_listfiles) \\$/;"	m
am__include	Makefile	/^am__include = include$/;"	m
am__include	include/Makefile	/^am__include = include$/;"	m
am__include	sample/Makefile	/^am__include = include$/;"	m
am__include	test/Makefile	/^am__include = include$/;"	m
am__include_HEADERS_DIST	Makefile	/^am__include_HEADERS_DIST = event.h evhttp.h evdns.h evrpc.h evutil.h$/;"	m
am__install_max	Makefile	/^am__install_max = 40$/;"	m
am__install_max	include/Makefile	/^am__install_max = 40$/;"	m
am__installdirs	Makefile	/^am__installdirs = "$(DESTDIR)$(libdir)" "$(DESTDIR)$(bindir)" \\$/;"	m
am__installdirs	include/Makefile	/^am__installdirs = "$(DESTDIR)$(includedir)" "$(DESTDIR)$(includedir)"$/;"	m
am__le_proxy_SOURCES_DIST	sample/Makefile	/^am__le_proxy_SOURCES_DIST = le-proxy.c$/;"	m
am__leading_dot	Makefile	/^am__leading_dot = .$/;"	m
am__leading_dot	include/Makefile	/^am__leading_dot = .$/;"	m
am__leading_dot	sample/Makefile	/^am__leading_dot = .$/;"	m
am__leading_dot	test/Makefile	/^am__leading_dot = .$/;"	m
am__libevent_core_la_SOURCES_DIST	Makefile	/^am__libevent_core_la_SOURCES_DIST = event.c evthread.c buffer.c \\$/;"	m
am__libevent_la_SOURCES_DIST	Makefile	/^am__libevent_la_SOURCES_DIST = event.c evthread.c buffer.c \\$/;"	m
am__libevent_openssl_la_SOURCES_DIST	Makefile	/^am__libevent_openssl_la_SOURCES_DIST = bufferevent_openssl.c$/;"	m
am__libevent_pthreads_la_SOURCES_DIST	Makefile	/^am__libevent_pthreads_la_SOURCES_DIST = evthread_pthread.c$/;"	m
am__make_dryrun	Makefile	/^am__make_dryrun = \\$/;"	m
am__make_dryrun	include/Makefile	/^am__make_dryrun = \\$/;"	m
am__make_dryrun	sample/Makefile	/^am__make_dryrun = \\$/;"	m
am__make_dryrun	test/Makefile	/^am__make_dryrun = \\$/;"	m
am__mv	Makefile	/^am__mv = mv -f$/;"	m
am__mv	test/Makefile	/^am__mv = mv -f$/;"	m
am__nobase_include_HEADERS_DIST	include/Makefile	/^am__nobase_include_HEADERS_DIST = event2\/buffer.h \\$/;"	m
am__nobase_list	Makefile	/^am__nobase_list = $(am__nobase_strip_setup); \\$/;"	m
am__nobase_list	include/Makefile	/^am__nobase_list = $(am__nobase_strip_setup); \\$/;"	m
am__nobase_strip	Makefile	/^am__nobase_strip = \\$/;"	m
am__nobase_strip	include/Makefile	/^am__nobase_strip = \\$/;"	m
am__nobase_strip_setup	Makefile	/^am__nobase_strip_setup = \\$/;"	m
am__nobase_strip_setup	include/Makefile	/^am__nobase_strip_setup = \\$/;"	m
am__noinst_HEADERS_DIST	Makefile	/^am__noinst_HEADERS_DIST = util-internal.h mm-internal.h \\$/;"	m
am__noinst_HEADERS_DIST	include/Makefile	/^am__noinst_HEADERS_DIST = event2\/buffer.h event2\/buffer_compat.h \\$/;"	m
am__objects_1	Makefile	/^am__objects_1 = select.lo$/;"	m
am__objects_1	test/Makefile	/^am__objects_1 = regress-regress_thread.$(OBJEXT)$/;"	m
am__objects_10	Makefile	/^am__objects_10 = event_tagging.lo http.lo evdns.lo evrpc.lo$/;"	m
am__objects_2	Makefile	/^am__objects_2 = poll.lo$/;"	m
am__objects_5	Makefile	/^am__objects_5 = epoll.lo$/;"	m
am__objects_7	Makefile	/^am__objects_7 = signal.lo$/;"	m
am__objects_8	Makefile	/^am__objects_8 = $(am__objects_1) $(am__objects_2) \\$/;"	m
am__objects_9	Makefile	/^am__objects_9 = event.lo evthread.lo buffer.lo bufferevent.lo \\$/;"	m
am__post_remove_distdir	Makefile	/^am__post_remove_distdir = $(am__remove_distdir)$/;"	m
am__quote	Makefile	/^am__quote = $/;"	m
am__quote	include/Makefile	/^am__quote = $/;"	m
am__quote	sample/Makefile	/^am__quote = $/;"	m
am__quote	test/Makefile	/^am__quote = $/;"	m
am__regress_SOURCES_DIST	test/Makefile	/^am__regress_SOURCES_DIST = regress.c regress_buffer.c regress_http.c \\$/;"	m
am__relativize	Makefile	/^am__relativize = \\$/;"	m
am__remove_distdir	Makefile	/^am__remove_distdir = \\$/;"	m
am__strip_dir	Makefile	/^am__strip_dir = f=`echo $$p | sed -e 's|^.*\/||'`;$/;"	m
am__strip_dir	include/Makefile	/^am__strip_dir = f=`echo $$p | sed -e 's|^.*\/||'`;$/;"	m
am__tar	Makefile	/^am__tar = $${TAR-tar} chof - "$$tardir"$/;"	m
am__tar	include/Makefile	/^am__tar = $${TAR-tar} chof - "$$tardir"$/;"	m
am__tar	sample/Makefile	/^am__tar = $${TAR-tar} chof - "$$tardir"$/;"	m
am__tar	test/Makefile	/^am__tar = $${TAR-tar} chof - "$$tardir"$/;"	m
am__tty_colors	test/Makefile	/^am__tty_colors = $(am__tty_colors_dummy)$/;"	m
am__tty_colors_dummy	test/Makefile	/^am__tty_colors_dummy = \\$/;"	m
am__uninstall_files_from_dir	Makefile	/^am__uninstall_files_from_dir = { \\$/;"	m
am__uninstall_files_from_dir	include/Makefile	/^am__uninstall_files_from_dir = { \\$/;"	m
am__untar	Makefile	/^am__untar = $${TAR-tar} xf -$/;"	m
am__untar	include/Makefile	/^am__untar = $${TAR-tar} xf -$/;"	m
am__untar	sample/Makefile	/^am__untar = $${TAR-tar} xf -$/;"	m
am__untar	test/Makefile	/^am__untar = $${TAR-tar} xf -$/;"	m
am__vpath_adj	Makefile	/^am__vpath_adj = case $$p in \\$/;"	m
am__vpath_adj	include/Makefile	/^am__vpath_adj = case $$p in \\$/;"	m
am__vpath_adj_setup	Makefile	/^am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;$/;"	m
am__vpath_adj_setup	include/Makefile	/^am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;$/;"	m
am_bench_OBJECTS	test/Makefile	/^am_bench_OBJECTS = bench.$(OBJEXT)$/;"	m
am_bench_cascade_OBJECTS	test/Makefile	/^am_bench_cascade_OBJECTS = bench_cascade.$(OBJEXT)$/;"	m
am_bench_http_OBJECTS	test/Makefile	/^am_bench_http_OBJECTS = bench_http.$(OBJEXT)$/;"	m
am_bench_httpclient_OBJECTS	test/Makefile	/^am_bench_httpclient_OBJECTS = bench_httpclient.$(OBJEXT)$/;"	m
am_dns_example_OBJECTS	sample/Makefile	/^am_dns_example_OBJECTS = dns-example.$(OBJEXT)$/;"	m
am_event_test_OBJECTS	sample/Makefile	/^am_event_test_OBJECTS = event-test.$(OBJEXT)$/;"	m
am_hello_world_OBJECTS	sample/Makefile	/^am_hello_world_OBJECTS = hello-world.$(OBJEXT)$/;"	m
am_http_server_OBJECTS	sample/Makefile	/^am_http_server_OBJECTS = http-server.$(OBJEXT)$/;"	m
am_libevent_core_la_OBJECTS	Makefile	/^am_libevent_core_la_OBJECTS = $(am__objects_9)$/;"	m
am_libevent_core_la_rpath	Makefile	/^am_libevent_core_la_rpath = -rpath $(libdir)$/;"	m
am_libevent_extra_la_OBJECTS	Makefile	/^am_libevent_extra_la_OBJECTS = $(am__objects_10)$/;"	m
am_libevent_extra_la_rpath	Makefile	/^am_libevent_extra_la_rpath = -rpath $(libdir)$/;"	m
am_libevent_la_OBJECTS	Makefile	/^am_libevent_la_OBJECTS = $(am__objects_9) $(am__objects_10)$/;"	m
am_libevent_la_rpath	Makefile	/^am_libevent_la_rpath = -rpath $(libdir)$/;"	m
am_libevent_pthreads_la_OBJECTS	Makefile	/^am_libevent_pthreads_la_OBJECTS = evthread_pthread.lo$/;"	m
am_libevent_pthreads_la_rpath	Makefile	/^am_libevent_pthreads_la_rpath =  \\$/;"	m
am_regress_OBJECTS	test/Makefile	/^am_regress_OBJECTS = regress-regress.$(OBJEXT) \\$/;"	m
am_signal_test_OBJECTS	sample/Makefile	/^am_signal_test_OBJECTS = signal-test.$(OBJEXT)$/;"	m
am_test_changelist_OBJECTS	test/Makefile	/^am_test_changelist_OBJECTS = test-changelist.$(OBJEXT)$/;"	m
am_test_eof_OBJECTS	test/Makefile	/^am_test_eof_OBJECTS = test-eof.$(OBJEXT)$/;"	m
am_test_init_OBJECTS	test/Makefile	/^am_test_init_OBJECTS = test-init.$(OBJEXT)$/;"	m
am_test_ratelim_OBJECTS	test/Makefile	/^am_test_ratelim_OBJECTS = test-ratelim.$(OBJEXT)$/;"	m
am_test_time_OBJECTS	test/Makefile	/^am_test_time_OBJECTS = test-time.$(OBJEXT)$/;"	m
am_test_weof_OBJECTS	test/Makefile	/^am_test_weof_OBJECTS = test-weof.$(OBJEXT)$/;"	m
am_time_test_OBJECTS	sample/Makefile	/^am_time_test_OBJECTS = time-test.$(OBJEXT)$/;"	m
announce	test/test.sh	/^announce () {$/;"	f
announce_n	test/test.sh	/^announce_n () {$/;"	f
ans	test/regress_testutils.h	/^	const char *ans;$/;"	m	struct:regress_dns_server_table	access:public
anstype	test/regress_testutils.h	/^	const char *anstype;$/;"	m	struct:regress_dns_server_table	access:public
answer	evdns.c	/^	struct server_reply_item *answer; \/* linked list of answer RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:	access:public
apply_numeric_port_hack	evutil.c	/^apply_numeric_port_hack(int port, struct evutil_addrinfo **ai)$/;"	f	file:	signature:(int port, struct evutil_addrinfo **ai)
apply_socktype_protocol_hack	evutil.c	/^apply_socktype_protocol_hack(struct evutil_addrinfo *ai)$/;"	f	file:	signature:(struct evutil_addrinfo *ai)
arc4_addrandom	arc4random.c	/^arc4_addrandom(const unsigned char *dat, int datlen)$/;"	f	file:	signature:(const unsigned char *dat, int datlen)
arc4_count	arc4random.c	/^static int arc4_count;$/;"	v	file:
arc4_getbyte	arc4random.c	/^arc4_getbyte(void)$/;"	f	file:	signature:(void)
arc4_getbyte	arc4random.c	/^static inline unsigned char arc4_getbyte(void);$/;"	p	file:	signature:(void)
arc4_getword	arc4random.c	/^arc4_getword(void)$/;"	f	file:	signature:(void)
arc4_init	arc4random.c	/^arc4_init(void)$/;"	f	file:	signature:(void)
arc4_seed	arc4random.c	/^arc4_seed(void)$/;"	f	file:	signature:(void)
arc4_seed_proc_sys_kernel_random_uuid	arc4random.c	/^arc4_seed_proc_sys_kernel_random_uuid(void)$/;"	f	file:	signature:(void)
arc4_seed_sysctl_bsd	arc4random.c	/^arc4_seed_sysctl_bsd(void)$/;"	f	file:	signature:(void)
arc4_seed_sysctl_linux	arc4random.c	/^arc4_seed_sysctl_linux(void)$/;"	f	file:	signature:(void)
arc4_seed_urandom	arc4random.c	/^arc4_seed_urandom(void)$/;"	f	file:	signature:(void)
arc4_seed_urandom_helper_	arc4random.c	/^static int arc4_seed_urandom_helper_(const char *fname)$/;"	f	file:	signature:(const char *fname)
arc4_seed_win32	arc4random.c	/^arc4_seed_win32(void)$/;"	f	file:	signature:(void)
arc4_seeded_ok	arc4random.c	/^static int arc4_seeded_ok;$/;"	v	file:
arc4_stir	arc4random.c	/^arc4_stir(void)$/;"	f	file:	signature:(void)
arc4_stir_if_needed	arc4random.c	/^arc4_stir_if_needed(void)$/;"	f	file:	signature:(void)
arc4_stir_pid	arc4random.c	/^static pid_t arc4_stir_pid;$/;"	v	file:
arc4_stream	arc4random.c	/^struct arc4_stream {$/;"	s	file:
arc4_stream::i	arc4random.c	/^	unsigned char i;$/;"	m	struct:arc4_stream	file:	access:public
arc4_stream::j	arc4random.c	/^	unsigned char j;$/;"	m	struct:arc4_stream	file:	access:public
arc4_stream::s	arc4random.c	/^	unsigned char s[256];$/;"	m	struct:arc4_stream	file:	access:public
arc4rand_lock	evutil_rand.c	/^static void *arc4rand_lock;$/;"	v	file:
arc4random	arc4random.c	/^arc4random(void)$/;"	f	signature:(void)
arc4random_addrandom	arc4random.c	/^arc4random_addrandom(const unsigned char *dat, int datlen)$/;"	f	signature:(const unsigned char *dat, int datlen)
arc4random_buf	arc4random.c	/^arc4random_buf(void *_buf, size_t n)$/;"	f	signature:(void *_buf, size_t n)
arc4random_stir	arc4random.c	/^arc4random_stir(void)$/;"	f	signature:(void)
arc4random_uniform	arc4random.c	/^arc4random_uniform(unsigned int upper_bound)$/;"	f	signature:(unsigned int upper_bound)
arc4random_urandom_filename	arc4random.c	/^static char *arc4random_urandom_filename = NULL;$/;"	v	file:
arg	defer-internal.h	/^	void *arg;$/;"	m	struct:deferred_cb	access:public
arg	event.c	/^	void *arg;$/;"	m	struct:event_once	file:	access:public
as_fn_append	config.status	/^  as_fn_append ()$/;"	f
as_fn_append	configure	/^  as_fn_append ()$/;"	f
as_fn_arith	config.status	/^  as_fn_arith ()$/;"	f
as_fn_arith	configure	/^  as_fn_arith ()$/;"	f
as_fn_error	config.status	/^as_fn_error ()$/;"	f
as_fn_error	configure	/^as_fn_error ()$/;"	f
as_fn_executable_p	config.status	/^as_fn_executable_p ()$/;"	f
as_fn_executable_p	configure	/^as_fn_executable_p ()$/;"	f
as_fn_exit	config.status	/^as_fn_exit ()$/;"	f
as_fn_exit	configure	/^as_fn_exit ()$/;"	f
as_fn_failure	configure	/^as_fn_failure () { as_fn_return 1; }$/;"	f
as_fn_mkdir_p	config.status	/^as_fn_mkdir_p ()$/;"	f
as_fn_mkdir_p	configure	/^as_fn_mkdir_p ()$/;"	f
as_fn_ret_failure	configure	/^as_fn_ret_failure () { return 1; }$/;"	f
as_fn_ret_success	configure	/^as_fn_ret_success () { return 0; }$/;"	f
as_fn_set_status	config.status	/^as_fn_set_status ()$/;"	f
as_fn_set_status	configure	/^as_fn_set_status ()$/;"	f
as_fn_success	configure	/^as_fn_success () { as_fn_return 0; }$/;"	f
as_fn_unset	config.status	/^as_fn_unset ()$/;"	f
as_fn_unset	configure	/^as_fn_unset ()$/;"	f
async_readcb	test/regress_iocp.c	/^async_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
attr_recursive	evthread_pthread.c	/^static pthread_mutexattr_t attr_recursive;$/;"	v	file:
authority	evdns.c	/^	struct server_reply_item *authority; \/* linked list of authority RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:	access:public
avoid_method	event-internal.h	/^	const char *avoid_method;$/;"	m	struct:event_config_entry	access:public
b	test/regress_util.c	/^	const char *b;$/;"	m	struct:example_struct	file:	access:public
bad_reentrant_run_loop_cb	test/regress.c	/^bad_reentrant_run_loop_cb(evutil_socket_t fd, short what, void *ptr)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *ptr)
base	evdns.c	/^	struct evdns_base *base;$/;"	m	struct:evdns_request	typeref:struct:evdns_request::evdns_base	file:	access:public
base	evdns.c	/^	struct evdns_base *base;$/;"	m	struct:nameserver	typeref:struct:nameserver::evdns_base	file:	access:public
base	evdns.c	/^	struct evdns_base *base;$/;"	m	struct:request	typeref:struct:request::evdns_base	file:	access:public
base	evdns.c	/^	struct evdns_server_request base;$/;"	m	struct:server_request	typeref:struct:server_request::evdns_server_request	file:	access:public
base	event-internal.h	/^	struct event_base *base;$/;"	m	struct:common_timeout_list	typeref:struct:common_timeout_list::event_base	access:public
base	evrpc-internal.h	/^	struct event_base *base;$/;"	m	struct:evrpc_pool	typeref:struct:evrpc_pool::event_base	access:public
base	http-internal.h	/^	struct event_base *base;$/;"	m	struct:evhttp	typeref:struct:evhttp::event_base	access:public
base	http-internal.h	/^	struct event_base *base;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::event_base	access:public
base	include/event2/rpc_struct.h	/^	struct evrpc_base *base;$/;"	m	struct:evrpc	typeref:struct:evrpc::evrpc_base	access:public
base	listener.c	/^	struct evconnlistener base;$/;"	m	struct:evconnlistener_event	typeref:struct:evconnlistener_event::evconnlistener	file:	access:public
base	listener.c	/^	struct evconnlistener base;$/;"	m	struct:evconnlistener_iocp	typeref:struct:evconnlistener_iocp::evconnlistener	file:	access:public
base	sample/le-proxy.c	/^static struct event_base *base;$/;"	v	typeref:struct:event_base	file:
base	test/bench_httpclient.c	/^struct event_base *base = NULL;$/;"	v	typeref:struct:event_base
base	test/regress.h	/^	struct event_base *base;$/;"	m	struct:basic_test_data	typeref:struct:basic_test_data::event_base	access:public
base	test/regress_dns.c	/^	struct event_base *base;$/;"	m	struct:gaic_request_status	typeref:struct:gaic_request_status::event_base	file:	access:public
base	test/regress_dns.c	/^	struct event_base *base;$/;"	m	struct:testleak_env_t	typeref:struct:testleak_env_t::event_base	file:	access:public
base	test/regress_http.c	/^	struct event_base *base;$/;"	m	struct:chunk_req_state	typeref:struct:chunk_req_state::event_base	file:	access:public
base	test/regress_http.c	/^	struct event_base *base;$/;"	m	struct:terminate_state	typeref:struct:terminate_state::event_base	file:	access:public
basic_cb_args	test/regress.c	/^struct basic_cb_args$/;"	s	file:
basic_cb_args::callcount	test/regress.c	/^	unsigned int callcount;$/;"	m	struct:basic_cb_args	file:	access:public
basic_cb_args::eb	test/regress.c	/^	struct event_base *eb;$/;"	m	struct:basic_cb_args	typeref:struct:basic_cb_args::event_base	file:	access:public
basic_cb_args::ev	test/regress.c	/^	struct event *ev;$/;"	m	struct:basic_cb_args	typeref:struct:basic_cb_args::event	file:	access:public
basic_read_cb	test/regress.c	/^basic_read_cb(evutil_socket_t fd, short event, void *data)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *data)
basic_setup	test/regress_main.c	/^const struct testcase_setup_t basic_setup = {$/;"	v	typeref:struct:testcase_setup_t
basic_test_cleanup	test/regress_main.c	/^basic_test_cleanup(const struct testcase_t *testcase, void *ptr)$/;"	f	file:	signature:(const struct testcase_t *testcase, void *ptr)
basic_test_data	test/regress.h	/^struct basic_test_data {$/;"	s
basic_test_data::base	test/regress.h	/^	struct event_base *base;$/;"	m	struct:basic_test_data	typeref:struct:basic_test_data::event_base	access:public
basic_test_data::legacy_test_fn	test/regress.h	/^	void (*legacy_test_fn)(void);$/;"	m	struct:basic_test_data	access:public
basic_test_data::pair	test/regress.h	/^	evutil_socket_t pair[2];$/;"	m	struct:basic_test_data	access:public
basic_test_data::setup_data	test/regress.h	/^	void *setup_data;$/;"	m	struct:basic_test_data	access:public
basic_test_setup	test/regress_main.c	/^basic_test_setup(const struct testcase_t *testcase)$/;"	f	file:	signature:(const struct testcase_t *testcase)
basic_thread	test/regress_thread.c	/^basic_thread(void *arg)$/;"	f	file:	signature:(void *arg)
be_async_ctrl	bufferevent_async.c	/^be_async_ctrl(struct bufferevent *bev, enum bufferevent_ctrl_op op,$/;"	f	file:	signature:(struct bufferevent *bev, enum bufferevent_ctrl_op op, union bufferevent_ctrl_data *data)
be_async_ctrl	bufferevent_async.c	/^static int be_async_ctrl(struct bufferevent *, enum bufferevent_ctrl_op, union bufferevent_ctrl_data *);$/;"	p	file:	signature:(struct bufferevent *, enum bufferevent_ctrl_op, union bufferevent_ctrl_data *)
be_async_destruct	bufferevent_async.c	/^be_async_destruct(struct bufferevent *bev)$/;"	f	file:	signature:(struct bufferevent *bev)
be_async_destruct	bufferevent_async.c	/^static void be_async_destruct(struct bufferevent *);$/;"	p	file:	signature:(struct bufferevent *)
be_async_disable	bufferevent_async.c	/^be_async_disable(struct bufferevent *bev, short what)$/;"	f	file:	signature:(struct bufferevent *bev, short what)
be_async_disable	bufferevent_async.c	/^static int be_async_disable(struct bufferevent *, short);$/;"	p	file:	signature:(struct bufferevent *, short)
be_async_enable	bufferevent_async.c	/^be_async_enable(struct bufferevent *buf, short what)$/;"	f	file:	signature:(struct bufferevent *buf, short what)
be_async_enable	bufferevent_async.c	/^static int be_async_enable(struct bufferevent *, short);$/;"	p	file:	signature:(struct bufferevent *, short)
be_async_flush	bufferevent_async.c	/^be_async_flush(struct bufferevent *bev, short what,$/;"	f	file:	signature:(struct bufferevent *bev, short what, enum bufferevent_flush_mode mode)
be_async_flush	bufferevent_async.c	/^static int be_async_flush(struct bufferevent *, short, enum bufferevent_flush_mode);$/;"	p	file:	signature:(struct bufferevent *, short, enum bufferevent_flush_mode)
be_async_inbuf_callback	bufferevent_async.c	/^be_async_inbuf_callback(struct evbuffer *buf,$/;"	f	file:	signature:(struct evbuffer *buf, const struct evbuffer_cb_info *cbinfo, void *arg)
be_async_outbuf_callback	bufferevent_async.c	/^be_async_outbuf_callback(struct evbuffer *buf,$/;"	f	file:	signature:(struct evbuffer *buf, const struct evbuffer_cb_info *cbinfo, void *arg)
be_conn_hostname_result	test/regress_dns.c	/^struct be_conn_hostname_result {$/;"	s	file:
be_conn_hostname_result::dnserr	test/regress_dns.c	/^	int dnserr;$/;"	m	struct:be_conn_hostname_result	file:	access:public
be_conn_hostname_result::what	test/regress_dns.c	/^	int what;$/;"	m	struct:be_conn_hostname_result	file:	access:public
be_connect_hostname_base	test/regress_dns.c	/^static struct event_base *be_connect_hostname_base = NULL;$/;"	v	typeref:struct:event_base	file:
be_connect_hostname_event_cb	test/regress_dns.c	/^be_connect_hostname_event_cb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *ctx)
be_filter_ctrl	bufferevent_filter.c	/^be_filter_ctrl(struct bufferevent *bev, enum bufferevent_ctrl_op op,$/;"	f	file:	signature:(struct bufferevent *bev, enum bufferevent_ctrl_op op, union bufferevent_ctrl_data *data)
be_filter_ctrl	bufferevent_filter.c	/^static int be_filter_ctrl(struct bufferevent *, enum bufferevent_ctrl_op, union bufferevent_ctrl_data *);$/;"	p	file:	signature:(struct bufferevent *, enum bufferevent_ctrl_op, union bufferevent_ctrl_data *)
be_filter_destruct	bufferevent_filter.c	/^be_filter_destruct(struct bufferevent *bev)$/;"	f	file:	signature:(struct bufferevent *bev)
be_filter_destruct	bufferevent_filter.c	/^static void be_filter_destruct(struct bufferevent *);$/;"	p	file:	signature:(struct bufferevent *)
be_filter_disable	bufferevent_filter.c	/^be_filter_disable(struct bufferevent *bev, short event)$/;"	f	file:	signature:(struct bufferevent *bev, short event)
be_filter_disable	bufferevent_filter.c	/^static int be_filter_disable(struct bufferevent *, short);$/;"	p	file:	signature:(struct bufferevent *, short)
be_filter_enable	bufferevent_filter.c	/^be_filter_enable(struct bufferevent *bev, short event)$/;"	f	file:	signature:(struct bufferevent *bev, short event)
be_filter_enable	bufferevent_filter.c	/^static int be_filter_enable(struct bufferevent *, short);$/;"	p	file:	signature:(struct bufferevent *, short)
be_filter_eventcb	bufferevent_filter.c	/^be_filter_eventcb(struct bufferevent *underlying, short what, void *_me)$/;"	f	file:	signature:(struct bufferevent *underlying, short what, void *_me)
be_filter_eventcb	bufferevent_filter.c	/^static void be_filter_eventcb(struct bufferevent *, short, void *);$/;"	p	file:	signature:(struct bufferevent *, short, void *)
be_filter_flush	bufferevent_filter.c	/^be_filter_flush(struct bufferevent *bufev,$/;"	f	file:	signature:(struct bufferevent *bufev, short iotype, enum bufferevent_flush_mode mode)
be_filter_flush	bufferevent_filter.c	/^static int be_filter_flush(struct bufferevent *bufev,$/;"	p	file:	signature:(struct bufferevent *bufev, short iotype, enum bufferevent_flush_mode mode)
be_filter_process_input	bufferevent_filter.c	/^be_filter_process_input(struct bufferevent_filtered *bevf,$/;"	f	file:	signature:(struct bufferevent_filtered *bevf, enum bufferevent_flush_mode state, int *processed_out)
be_filter_process_output	bufferevent_filter.c	/^be_filter_process_output(struct bufferevent_filtered *bevf,$/;"	f	file:	signature:(struct bufferevent_filtered *bevf, enum bufferevent_flush_mode state, int *processed_out)
be_filter_readcb	bufferevent_filter.c	/^be_filter_readcb(struct bufferevent *underlying, void *_me)$/;"	f	file:	signature:(struct bufferevent *underlying, void *_me)
be_filter_readcb	bufferevent_filter.c	/^static void be_filter_readcb(struct bufferevent *, void *);$/;"	p	file:	signature:(struct bufferevent *, void *)
be_filter_writecb	bufferevent_filter.c	/^be_filter_writecb(struct bufferevent *underlying, void *_me)$/;"	f	file:	signature:(struct bufferevent *underlying, void *_me)
be_filter_writecb	bufferevent_filter.c	/^static void be_filter_writecb(struct bufferevent *, void *);$/;"	p	file:	signature:(struct bufferevent *, void *)
be_getaddrinfo_server_cb	test/regress_dns.c	/^be_getaddrinfo_server_cb(struct evdns_server_request *req, void *data)$/;"	f	file:	signature:(struct evdns_server_request *req, void *data)
be_null_filter	bufferevent_filter.c	/^be_null_filter(struct evbuffer *src, struct evbuffer *dst, ev_ssize_t lim,$/;"	f	file:	signature:(struct evbuffer *src, struct evbuffer *dst, ev_ssize_t lim, enum bufferevent_flush_mode state, void *ctx)
be_openssl_adj_timeouts	bufferevent_openssl.c	/^be_openssl_adj_timeouts(struct bufferevent *bev)$/;"	f	file:	signature:(struct bufferevent *bev)
be_openssl_adj_timeouts	bufferevent_openssl.c	/^static int be_openssl_adj_timeouts(struct bufferevent *);$/;"	p	file:	signature:(struct bufferevent *)
be_openssl_ctrl	bufferevent_openssl.c	/^be_openssl_ctrl(struct bufferevent *bev,$/;"	f	file:	signature:(struct bufferevent *bev, enum bufferevent_ctrl_op op, union bufferevent_ctrl_data *data)
be_openssl_ctrl	bufferevent_openssl.c	/^static int be_openssl_ctrl(struct bufferevent *, enum bufferevent_ctrl_op, union bufferevent_ctrl_data *);$/;"	p	file:	signature:(struct bufferevent *, enum bufferevent_ctrl_op, union bufferevent_ctrl_data *)
be_openssl_destruct	bufferevent_openssl.c	/^be_openssl_destruct(struct bufferevent *bev)$/;"	f	file:	signature:(struct bufferevent *bev)
be_openssl_destruct	bufferevent_openssl.c	/^static void be_openssl_destruct(struct bufferevent *);$/;"	p	file:	signature:(struct bufferevent *)
be_openssl_disable	bufferevent_openssl.c	/^be_openssl_disable(struct bufferevent *bev, short events)$/;"	f	file:	signature:(struct bufferevent *bev, short events)
be_openssl_disable	bufferevent_openssl.c	/^static int be_openssl_disable(struct bufferevent *, short);$/;"	p	file:	signature:(struct bufferevent *, short)
be_openssl_enable	bufferevent_openssl.c	/^be_openssl_enable(struct bufferevent *bev, short events)$/;"	f	file:	signature:(struct bufferevent *bev, short events)
be_openssl_enable	bufferevent_openssl.c	/^static int be_openssl_enable(struct bufferevent *, short);$/;"	p	file:	signature:(struct bufferevent *, short)
be_openssl_eventcb	bufferevent_openssl.c	/^be_openssl_eventcb(struct bufferevent *bev_base, short what, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev_base, short what, void *ctx)
be_openssl_flush	bufferevent_openssl.c	/^be_openssl_flush(struct bufferevent *bufev,$/;"	f	file:	signature:(struct bufferevent *bufev, short iotype, enum bufferevent_flush_mode mode)
be_openssl_flush	bufferevent_openssl.c	/^static int be_openssl_flush(struct bufferevent *bufev,$/;"	p	file:	signature:(struct bufferevent *bufev, short iotype, enum bufferevent_flush_mode mode)
be_openssl_handshakecb	bufferevent_openssl.c	/^be_openssl_handshakecb(struct bufferevent *bev_base, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev_base, void *ctx)
be_openssl_handshakeeventcb	bufferevent_openssl.c	/^be_openssl_handshakeeventcb(evutil_socket_t fd, short what, void *ptr)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *ptr)
be_openssl_outbuf_cb	bufferevent_openssl.c	/^be_openssl_outbuf_cb(struct evbuffer *buf,$/;"	f	file:	signature:(struct evbuffer *buf, const struct evbuffer_cb_info *cbinfo, void *arg)
be_openssl_readcb	bufferevent_openssl.c	/^be_openssl_readcb(struct bufferevent *bev_base, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev_base, void *ctx)
be_openssl_readeventcb	bufferevent_openssl.c	/^be_openssl_readeventcb(evutil_socket_t fd, short what, void *ptr)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *ptr)
be_openssl_writecb	bufferevent_openssl.c	/^be_openssl_writecb(struct bufferevent *bev_base, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev_base, void *ctx)
be_openssl_writeeventcb	bufferevent_openssl.c	/^be_openssl_writeeventcb(evutil_socket_t fd, short what, void *ptr)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *ptr)
be_ops	include/event2/bufferevent_struct.h	/^	const struct bufferevent_ops *be_ops;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::bufferevent_ops	access:public
be_pair_destruct	bufferevent_pair.c	/^be_pair_destruct(struct bufferevent *bev)$/;"	f	file:	signature:(struct bufferevent *bev)
be_pair_disable	bufferevent_pair.c	/^be_pair_disable(struct bufferevent *bev, short events)$/;"	f	file:	signature:(struct bufferevent *bev, short events)
be_pair_enable	bufferevent_pair.c	/^be_pair_enable(struct bufferevent *bufev, short events)$/;"	f	file:	signature:(struct bufferevent *bufev, short events)
be_pair_flush	bufferevent_pair.c	/^be_pair_flush(struct bufferevent *bev, short iotype,$/;"	f	file:	signature:(struct bufferevent *bev, short iotype, enum bufferevent_flush_mode mode)
be_pair_outbuf_cb	bufferevent_pair.c	/^be_pair_outbuf_cb(struct evbuffer *outbuf,$/;"	f	file:	signature:(struct evbuffer *outbuf, const struct evbuffer_cb_info *info, void *arg)
be_pair_outbuf_cb	bufferevent_pair.c	/^static void be_pair_outbuf_cb(struct evbuffer *,$/;"	p	file:	signature:(struct evbuffer *, const struct evbuffer_cb_info *, void *)
be_pair_transfer	bufferevent_pair.c	/^be_pair_transfer(struct bufferevent *src, struct bufferevent *dst,$/;"	f	file:	signature:(struct bufferevent *src, struct bufferevent *dst, int ignore_wm)
be_pair_wants_to_talk	bufferevent_pair.c	/^be_pair_wants_to_talk(struct bufferevent_pair *src,$/;"	f	file:	signature:(struct bufferevent_pair *src, struct bufferevent_pair *dst)
be_readbuf_full	bufferevent_filter.c	/^be_readbuf_full(struct bufferevent_filtered *bevf,$/;"	f	file:	signature:(struct bufferevent_filtered *bevf, enum bufferevent_flush_mode state)
be_socket_add	bufferevent_sock.c	98;"	d	file:
be_socket_adj_timeouts	bufferevent_sock.c	/^be_socket_adj_timeouts(struct bufferevent *bufev)$/;"	f	file:	signature:(struct bufferevent *bufev)
be_socket_adj_timeouts	bufferevent_sock.c	/^static int be_socket_adj_timeouts(struct bufferevent *);$/;"	p	file:	signature:(struct bufferevent *)
be_socket_ctrl	bufferevent_sock.c	/^be_socket_ctrl(struct bufferevent *bev, enum bufferevent_ctrl_op op,$/;"	f	file:	signature:(struct bufferevent *bev, enum bufferevent_ctrl_op op, union bufferevent_ctrl_data *data)
be_socket_ctrl	bufferevent_sock.c	/^static int be_socket_ctrl(struct bufferevent *, enum bufferevent_ctrl_op, union bufferevent_ctrl_data *);$/;"	p	file:	signature:(struct bufferevent *, enum bufferevent_ctrl_op, union bufferevent_ctrl_data *)
be_socket_destruct	bufferevent_sock.c	/^be_socket_destruct(struct bufferevent *bufev)$/;"	f	file:	signature:(struct bufferevent *bufev)
be_socket_destruct	bufferevent_sock.c	/^static void be_socket_destruct(struct bufferevent *);$/;"	p	file:	signature:(struct bufferevent *)
be_socket_disable	bufferevent_sock.c	/^be_socket_disable(struct bufferevent *bufev, short event)$/;"	f	file:	signature:(struct bufferevent *bufev, short event)
be_socket_disable	bufferevent_sock.c	/^static int be_socket_disable(struct bufferevent *, short);$/;"	p	file:	signature:(struct bufferevent *, short)
be_socket_enable	bufferevent_sock.c	/^be_socket_enable(struct bufferevent *bufev, short event)$/;"	f	file:	signature:(struct bufferevent *bufev, short event)
be_socket_enable	bufferevent_sock.c	/^static int be_socket_enable(struct bufferevent *, short);$/;"	p	file:	signature:(struct bufferevent *, short)
be_socket_flush	bufferevent_sock.c	/^be_socket_flush(struct bufferevent *bev, short iotype,$/;"	f	file:	signature:(struct bufferevent *bev, short iotype, enum bufferevent_flush_mode mode)
be_socket_flush	bufferevent_sock.c	/^static int be_socket_flush(struct bufferevent *, short, enum bufferevent_flush_mode);$/;"	p	file:	signature:(struct bufferevent *, short, enum bufferevent_flush_mode)
be_socket_setfd	bufferevent_sock.c	/^be_socket_setfd(struct bufferevent *bufev, evutil_socket_t fd)$/;"	f	file:	signature:(struct bufferevent *bufev, evutil_socket_t fd)
be_socket_setfd	bufferevent_sock.c	/^static void be_socket_setfd(struct bufferevent *, evutil_socket_t);$/;"	p	file:	signature:(struct bufferevent *, evutil_socket_t)
be_underlying_writebuf_full	bufferevent_filter.c	/^be_underlying_writebuf_full(struct bufferevent_filtered *bevf,$/;"	f	file:	signature:(struct bufferevent_filtered *bevf, enum bufferevent_flush_mode state)
bench_DEPENDENCIES	test/Makefile	/^bench_DEPENDENCIES = $(am__DEPENDENCIES_1) ..\/libevent.la$/;"	m
bench_LDADD	test/Makefile	/^bench_LDADD = $(LIBEVENT_GC_SECTIONS) ..\/libevent.la$/;"	m
bench_OBJECTS	test/Makefile	/^bench_OBJECTS = $(am_bench_OBJECTS)$/;"	m
bench_SOURCES	test/Makefile	/^bench_SOURCES = bench.c$/;"	m
bench_cascade_DEPENDENCIES	test/Makefile	/^bench_cascade_DEPENDENCIES = $(am__DEPENDENCIES_1) ..\/libevent.la$/;"	m
bench_cascade_LDADD	test/Makefile	/^bench_cascade_LDADD = $(LIBEVENT_GC_SECTIONS) ..\/libevent.la$/;"	m
bench_cascade_OBJECTS	test/Makefile	/^bench_cascade_OBJECTS = $(am_bench_cascade_OBJECTS)$/;"	m
bench_cascade_SOURCES	test/Makefile	/^bench_cascade_SOURCES = bench_cascade.c$/;"	m
bench_http_DEPENDENCIES	test/Makefile	/^bench_http_DEPENDENCIES = $(am__DEPENDENCIES_1) ..\/libevent.la$/;"	m
bench_http_LDADD	test/Makefile	/^bench_http_LDADD = $(LIBEVENT_GC_SECTIONS) ..\/libevent.la$/;"	m
bench_http_OBJECTS	test/Makefile	/^bench_http_OBJECTS = $(am_bench_http_OBJECTS)$/;"	m
bench_http_SOURCES	test/Makefile	/^bench_http_SOURCES = bench_http.c$/;"	m
bench_httpclient_DEPENDENCIES	test/Makefile	/^bench_httpclient_DEPENDENCIES = $(am__DEPENDENCIES_1) \\$/;"	m
bench_httpclient_LDADD	test/Makefile	/^bench_httpclient_LDADD = $(LIBEVENT_GC_SECTIONS) ..\/libevent_core.la$/;"	m
bench_httpclient_OBJECTS	test/Makefile	/^bench_httpclient_OBJECTS = $(am_bench_httpclient_OBJECTS)$/;"	m
bench_httpclient_SOURCES	test/Makefile	/^bench_httpclient_SOURCES = bench_httpclient.c$/;"	m
bev	bufferevent-internal.h	/^	struct bufferevent bev;$/;"	m	struct:bufferevent_private	typeref:struct:bufferevent_private::bufferevent	access:public
bev	bufferevent_async.c	/^	struct bufferevent_private bev;$/;"	m	struct:bufferevent_async	typeref:struct:bufferevent_async::bufferevent_private	file:	access:public
bev	bufferevent_filter.c	/^	struct bufferevent_private bev;$/;"	m	struct:bufferevent_filtered	typeref:struct:bufferevent_filtered::bufferevent_private	file:	access:public
bev	bufferevent_openssl.c	/^	struct bufferevent_private bev;$/;"	m	struct:bufferevent_openssl	typeref:struct:bufferevent_openssl::bufferevent_private	file:	access:public
bev	bufferevent_pair.c	/^	struct bufferevent_private bev;$/;"	m	struct:bufferevent_pair	typeref:struct:bufferevent_pair::bufferevent_private	file:	access:public
bev	test/regress_http.c	/^	struct bufferevent *bev;$/;"	m	struct:terminate_state	typeref:struct:terminate_state::bufferevent	file:	access:public
bev_async_add_read	bufferevent_async.c	/^bev_async_add_read(struct bufferevent_async *beva)$/;"	f	file:	signature:(struct bufferevent_async *beva)
bev_async_add_write	bufferevent_async.c	/^bev_async_add_write(struct bufferevent_async *beva)$/;"	f	file:	signature:(struct bufferevent_async *beva)
bev_async_consider_reading	bufferevent_async.c	/^bev_async_consider_reading(struct bufferevent_async *beva)$/;"	f	file:	signature:(struct bufferevent_async *beva)
bev_async_consider_writing	bufferevent_async.c	/^bev_async_consider_writing(struct bufferevent_async *beva)$/;"	f	file:	signature:(struct bufferevent_async *beva)
bev_async_del_read	bufferevent_async.c	/^bev_async_del_read(struct bufferevent_async *beva)$/;"	f	file:	signature:(struct bufferevent_async *beva)
bev_async_del_write	bufferevent_async.c	/^bev_async_del_write(struct bufferevent_async *beva)$/;"	f	file:	signature:(struct bufferevent_async *beva)
bev_async_set_wsa_error	bufferevent_async.c	/^bev_async_set_wsa_error(struct bufferevent *bev, struct event_overlapped *eo)$/;"	f	file:	signature:(struct bufferevent *bev, struct event_overlapped *eo)
bev_timeout_event_cb	test/regress_bufferevent.c	/^bev_timeout_event_cb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *arg)
bev_timeout_write_cb	test/regress_bufferevent.c	/^bev_timeout_write_cb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
bind_address	http-internal.h	/^	char *bind_address;		\/* address to use for binding the src *\/$/;"	m	struct:evhttp_connection	access:public
bind_port	http-internal.h	/^	u_short bind_port;		\/* local port for binding the src *\/$/;"	m	struct:evhttp_connection	access:public
bind_socket	http.c	/^bind_socket(const char *address, ev_uint16_t port, int reuse)$/;"	f	file:	signature:(const char *address, ev_uint16_t port, int reuse)
bind_socket	http.c	/^static evutil_socket_t bind_socket(const char *, ev_uint16_t, int reuse);$/;"	p	file:	signature:(const char *, ev_uint16_t, int reuse)
bind_socket_ai	http.c	/^bind_socket_ai(struct evutil_addrinfo *ai, int reuse)$/;"	f	file:	signature:(struct evutil_addrinfo *ai, int reuse)
bind_socket_ai	http.c	/^static evutil_socket_t bind_socket_ai(struct evutil_addrinfo *, int reuse);$/;"	p	file:	signature:(struct evutil_addrinfo *, int reuse)
bindir	Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bindir	include/Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bindir	sample/Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bindir	test/Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bio_bufferevent_ctrl	bufferevent_openssl.c	/^bio_bufferevent_ctrl(BIO *b, int cmd, long num, void *ptr)$/;"	f	file:	signature:(BIO *b, int cmd, long num, void *ptr)
bio_bufferevent_free	bufferevent_openssl.c	/^bio_bufferevent_free(BIO *b)$/;"	f	file:	signature:(BIO *b)
bio_bufferevent_new	bufferevent_openssl.c	/^bio_bufferevent_new(BIO *b)$/;"	f	file:	signature:(BIO *b)
bio_bufferevent_puts	bufferevent_openssl.c	/^bio_bufferevent_puts(BIO *b, const char *s)$/;"	f	file:	signature:(BIO *b, const char *s)
bio_bufferevent_read	bufferevent_openssl.c	/^bio_bufferevent_read(BIO *b, char *out, int outlen)$/;"	f	file:	signature:(BIO *b, char *out, int outlen)
bio_bufferevent_write	bufferevent_openssl.c	/^bio_bufferevent_write(BIO *b, const char *in, int inlen)$/;"	f	file:	signature:(BIO *b, const char *in, int inlen)
bio_data_counts	bufferevent_openssl.c	/^struct bio_data_counts {$/;"	s	file:
bio_data_counts::n_read	bufferevent_openssl.c	/^	unsigned long n_read;$/;"	m	struct:bio_data_counts	file:	access:public
bio_data_counts::n_written	bufferevent_openssl.c	/^	unsigned long n_written;$/;"	m	struct:bio_data_counts	file:	access:public
body_size	include/event2/http_struct.h	/^	size_t body_size;$/;"	m	struct:evhttp_request	access:public
both	test/regress.c	/^struct both {$/;"	s	file:
both::ev	test/regress.c	/^	struct event ev;$/;"	m	struct:both	typeref:struct:both::event	file:	access:public
both::nread	test/regress.c	/^	int nread;$/;"	m	struct:both	file:	access:public
bracket_addr_ok	http.c	/^bracket_addr_ok(const char *s, const char *eos)$/;"	f	file:	signature:(const char *s, const char *eos)
break_cb	test/regress.c	/^break_cb(evutil_socket_t fd, short events, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short events, void *arg)
bufev	http-internal.h	/^	struct bufferevent *bufev;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::bufferevent	access:public
buffer	buffer_iocp.c	/^	struct evbuffer buffer;$/;"	m	struct:evbuffer_overlapped	typeref:struct:evbuffer_overlapped::evbuffer	file:	access:public
buffer	evbuffer-internal.h	/^	unsigned char *buffer;$/;"	m	struct:evbuffer_chain	access:public
buffer_len	evbuffer-internal.h	/^	size_t buffer_len;$/;"	m	struct:evbuffer_chain	access:public
bufferevent	include/event2/bufferevent.h	/^struct bufferevent$/;"	s
bufferevent	include/event2/bufferevent_struct.h	/^struct bufferevent {$/;"	s
bufferevent::be_ops	include/event2/bufferevent_struct.h	/^	const struct bufferevent_ops *be_ops;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::bufferevent_ops	access:public
bufferevent::cbarg	include/event2/bufferevent_struct.h	/^	void *cbarg;$/;"	m	struct:bufferevent	access:public
bufferevent::enabled	include/event2/bufferevent_struct.h	/^	short enabled;$/;"	m	struct:bufferevent	access:public
bufferevent::errorcb	include/event2/bufferevent_struct.h	/^	bufferevent_event_cb errorcb;$/;"	m	struct:bufferevent	access:public
bufferevent::ev_base	include/event2/bufferevent_struct.h	/^	struct event_base *ev_base;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_base	access:public
bufferevent::ev_read	include/event2/bufferevent_struct.h	/^	struct event ev_read;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event	access:public
bufferevent::ev_write	include/event2/bufferevent_struct.h	/^	struct event ev_write;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event	access:public
bufferevent::input	include/event2/bufferevent_struct.h	/^	struct evbuffer *input;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::evbuffer	access:public
bufferevent::output	include/event2/bufferevent_struct.h	/^	struct evbuffer *output;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::evbuffer	access:public
bufferevent::readcb	include/event2/bufferevent_struct.h	/^	bufferevent_data_cb readcb;$/;"	m	struct:bufferevent	access:public
bufferevent::timeout_read	include/event2/bufferevent_struct.h	/^	struct timeval timeout_read;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::timeval	access:public
bufferevent::timeout_write	include/event2/bufferevent_struct.h	/^	struct timeval timeout_write;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::timeval	access:public
bufferevent::wm_read	include/event2/bufferevent_struct.h	/^	struct event_watermark wm_read;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_watermark	access:public
bufferevent::wm_write	include/event2/bufferevent_struct.h	/^	struct event_watermark wm_write;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_watermark	access:public
bufferevent::writecb	include/event2/bufferevent_struct.h	/^	bufferevent_data_cb writecb;$/;"	m	struct:bufferevent	access:public
bufferevent_add_to_rate_limit_group	bufferevent_ratelim.c	/^bufferevent_add_to_rate_limit_group(struct bufferevent *bev,$/;"	f	signature:(struct bufferevent *bev, struct bufferevent_rate_limit_group *g)
bufferevent_add_to_rate_limit_group	include/event2/bufferevent.h	/^int bufferevent_add_to_rate_limit_group(struct bufferevent *bev,$/;"	p	signature:(struct bufferevent *bev, struct bufferevent_rate_limit_group *g)
bufferevent_async	bufferevent_async.c	/^struct bufferevent_async {$/;"	s	file:
bufferevent_async::bev	bufferevent_async.c	/^	struct bufferevent_private bev;$/;"	m	struct:bufferevent_async	typeref:struct:bufferevent_async::bufferevent_private	file:	access:public
bufferevent_async::connect_overlapped	bufferevent_async.c	/^	struct event_overlapped connect_overlapped;$/;"	m	struct:bufferevent_async	typeref:struct:bufferevent_async::event_overlapped	file:	access:public
bufferevent_async::ok	bufferevent_async.c	/^	unsigned ok : 1;$/;"	m	struct:bufferevent_async	file:	access:public
bufferevent_async::read_added	bufferevent_async.c	/^	unsigned read_added : 1;$/;"	m	struct:bufferevent_async	file:	access:public
bufferevent_async::read_in_progress	bufferevent_async.c	/^	size_t read_in_progress;$/;"	m	struct:bufferevent_async	file:	access:public
bufferevent_async::read_overlapped	bufferevent_async.c	/^	struct event_overlapped read_overlapped;$/;"	m	struct:bufferevent_async	typeref:struct:bufferevent_async::event_overlapped	file:	access:public
bufferevent_async::write_added	bufferevent_async.c	/^	unsigned write_added : 1;$/;"	m	struct:bufferevent_async	file:	access:public
bufferevent_async::write_in_progress	bufferevent_async.c	/^	size_t write_in_progress;$/;"	m	struct:bufferevent_async	file:	access:public
bufferevent_async::write_overlapped	bufferevent_async.c	/^	struct event_overlapped write_overlapped;$/;"	m	struct:bufferevent_async	typeref:struct:bufferevent_async::event_overlapped	file:	access:public
bufferevent_async_can_connect	bufferevent_async.c	/^bufferevent_async_can_connect(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
bufferevent_async_can_connect	iocp-internal.h	/^int bufferevent_async_can_connect(struct bufferevent *bev);$/;"	p	signature:(struct bufferevent *bev)
bufferevent_async_connect	bufferevent_async.c	/^bufferevent_async_connect(struct bufferevent *bev, evutil_socket_t fd,$/;"	f	signature:(struct bufferevent *bev, evutil_socket_t fd, const struct sockaddr *sa, int socklen)
bufferevent_async_connect	iocp-internal.h	/^int bufferevent_async_connect(struct bufferevent *bev, evutil_socket_t fd,$/;"	p	signature:(struct bufferevent *bev, evutil_socket_t fd, const struct sockaddr *sa, int socklen)
bufferevent_async_new	bufferevent_async.c	/^bufferevent_async_new(struct event_base *base,$/;"	f	signature:(struct event_base *base, evutil_socket_t fd, int options)
bufferevent_async_new	iocp-internal.h	/^struct bufferevent *bufferevent_async_new(struct event_base *base,$/;"	p	signature:(struct event_base *base, evutil_socket_t fd, int options)
bufferevent_async_set_connected	bufferevent_async.c	/^bufferevent_async_set_connected(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
bufferevent_async_set_connected	iocp-internal.h	/^void bufferevent_async_set_connected(struct bufferevent *bev);$/;"	p	signature:(struct bufferevent *bev)
bufferevent_base_set	bufferevent_sock.c	/^bufferevent_base_set(struct event_base *base, struct bufferevent *bufev)$/;"	f	signature:(struct event_base *base, struct bufferevent *bufev)
bufferevent_base_set	include/event2/bufferevent.h	/^int bufferevent_base_set(struct event_base *base, struct bufferevent *bufev);$/;"	p	signature:(struct event_base *base, struct bufferevent *bufev)
bufferevent_connect_getaddrinfo_cb	bufferevent_sock.c	/^bufferevent_connect_getaddrinfo_cb(int result, struct evutil_addrinfo *ai,$/;"	f	file:	signature:(int result, struct evutil_addrinfo *ai, void *arg)
bufferevent_connect_test_flags	test/regress_bufferevent.c	/^static int bufferevent_connect_test_flags = 0;$/;"	v	file:
bufferevent_ctrl_data	bufferevent-internal.h	/^union bufferevent_ctrl_data {$/;"	u
bufferevent_ctrl_data::fd	bufferevent-internal.h	/^	evutil_socket_t fd;$/;"	m	union:bufferevent_ctrl_data	access:public
bufferevent_ctrl_data::ptr	bufferevent-internal.h	/^	void *ptr;$/;"	m	union:bufferevent_ctrl_data	access:public
bufferevent_ctrl_op	bufferevent-internal.h	/^enum bufferevent_ctrl_op {$/;"	g
bufferevent_data_cb	include/event2/bufferevent.h	/^typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);$/;"	t
bufferevent_decref	bufferevent-internal.h	/^int bufferevent_decref(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
bufferevent_decref	bufferevent.c	/^bufferevent_decref(struct bufferevent *bufev)$/;"	f	signature:(struct bufferevent *bufev)
bufferevent_decrement_read_limit	bufferevent_ratelim.c	/^bufferevent_decrement_read_limit(struct bufferevent *bev, ev_ssize_t decr)$/;"	f	signature:(struct bufferevent *bev, ev_ssize_t decr)
bufferevent_decrement_read_limit	include/event2/bufferevent.h	/^int bufferevent_decrement_read_limit(struct bufferevent *bev, ev_ssize_t decr);$/;"	p	signature:(struct bufferevent *bev, ev_ssize_t decr)
bufferevent_decrement_write_limit	bufferevent_ratelim.c	/^bufferevent_decrement_write_limit(struct bufferevent *bev, ev_ssize_t decr)$/;"	f	signature:(struct bufferevent *bev, ev_ssize_t decr)
bufferevent_decrement_write_limit	include/event2/bufferevent.h	/^int bufferevent_decrement_write_limit(struct bufferevent *bev, ev_ssize_t decr);$/;"	p	signature:(struct bufferevent *bev, ev_ssize_t decr)
bufferevent_disable	bufferevent.c	/^bufferevent_disable(struct bufferevent *bufev, short event)$/;"	f	signature:(struct bufferevent *bufev, short event)
bufferevent_disable	include/event2/bufferevent.h	/^int bufferevent_disable(struct bufferevent *bufev, short event);$/;"	p	signature:(struct bufferevent *bufev, short event)
bufferevent_disable_hard	bufferevent-internal.h	/^int bufferevent_disable_hard(struct bufferevent *bufev, short event);$/;"	p	signature:(struct bufferevent *bufev, short event)
bufferevent_disable_hard	bufferevent.c	/^bufferevent_disable_hard(struct bufferevent *bufev, short event)$/;"	f	signature:(struct bufferevent *bufev, short event)
bufferevent_enable	bufferevent.c	/^bufferevent_enable(struct bufferevent *bufev, short event)$/;"	f	signature:(struct bufferevent *bufev, short event)
bufferevent_enable	include/event2/bufferevent.h	/^int bufferevent_enable(struct bufferevent *bufev, short event);$/;"	p	signature:(struct bufferevent *bufev, short event)
bufferevent_enable_locking	bufferevent-internal.h	/^int bufferevent_enable_locking(struct bufferevent *bufev, void *lock);$/;"	p	signature:(struct bufferevent *bufev, void *lock)
bufferevent_enable_locking	bufferevent.c	/^bufferevent_enable_locking(struct bufferevent *bufev, void *lock)$/;"	f	signature:(struct bufferevent *bufev, void *lock)
bufferevent_event_cb	include/event2/bufferevent.h	/^typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short what, void *ctx);$/;"	t
bufferevent_filter_cb	include/event2/bufferevent.h	/^typedef enum bufferevent_filter_result (*bufferevent_filter_cb)($/;"	t	typeref:enum:bufferevent_filter_cb
bufferevent_filter_new	bufferevent_filter.c	/^bufferevent_filter_new(struct bufferevent *underlying,$/;"	f	signature:(struct bufferevent *underlying, bufferevent_filter_cb input_filter, bufferevent_filter_cb output_filter, int options, void (*free_context)(void *), void *ctx)
bufferevent_filter_new	include/event2/bufferevent.h	/^bufferevent_filter_new(struct bufferevent *underlying,$/;"	p	signature:(struct bufferevent *underlying, bufferevent_filter_cb input_filter, bufferevent_filter_cb output_filter, int options, void (*free_context)(void *), void *ctx)
bufferevent_filter_result	include/event2/bufferevent.h	/^enum bufferevent_filter_result {$/;"	g
bufferevent_filtered	bufferevent_filter.c	/^struct bufferevent_filtered {$/;"	s	file:
bufferevent_filtered::bev	bufferevent_filter.c	/^	struct bufferevent_private bev;$/;"	m	struct:bufferevent_filtered	typeref:struct:bufferevent_filtered::bufferevent_private	file:	access:public
bufferevent_filtered::context	bufferevent_filter.c	/^	void *context;$/;"	m	struct:bufferevent_filtered	file:	access:public
bufferevent_filtered::free_context	bufferevent_filter.c	/^	void (*free_context)(void *);$/;"	m	struct:bufferevent_filtered	file:	access:public
bufferevent_filtered::got_eof	bufferevent_filter.c	/^	unsigned got_eof;$/;"	m	struct:bufferevent_filtered	file:	access:public
bufferevent_filtered::outbuf_cb	bufferevent_filter.c	/^	struct evbuffer_cb_entry *outbuf_cb;$/;"	m	struct:bufferevent_filtered	typeref:struct:bufferevent_filtered::evbuffer_cb_entry	file:	access:public
bufferevent_filtered::process_in	bufferevent_filter.c	/^	bufferevent_filter_cb process_in;$/;"	m	struct:bufferevent_filtered	file:	access:public
bufferevent_filtered::process_out	bufferevent_filter.c	/^	bufferevent_filter_cb process_out;$/;"	m	struct:bufferevent_filtered	file:	access:public
bufferevent_filtered::underlying	bufferevent_filter.c	/^	struct bufferevent *underlying;$/;"	m	struct:bufferevent_filtered	typeref:struct:bufferevent_filtered::bufferevent	file:	access:public
bufferevent_filtered_outbuf_cb	bufferevent_filter.c	/^bufferevent_filtered_outbuf_cb(struct evbuffer *buf,$/;"	f	file:	signature:(struct evbuffer *buf, const struct evbuffer_cb_info *cbinfo, void *arg)
bufferevent_filtered_outbuf_cb	bufferevent_filter.c	/^static void bufferevent_filtered_outbuf_cb(struct evbuffer *buf,$/;"	p	file:	signature:(struct evbuffer *buf, const struct evbuffer_cb_info *info, void *arg)
bufferevent_flush	bufferevent.c	/^bufferevent_flush(struct bufferevent *bufev,$/;"	f	signature:(struct bufferevent *bufev, short iotype, enum bufferevent_flush_mode mode)
bufferevent_flush	include/event2/bufferevent.h	/^int bufferevent_flush(struct bufferevent *bufev,$/;"	p	signature:(struct bufferevent *bufev, short iotype, enum bufferevent_flush_mode mode)
bufferevent_flush_mode	include/event2/bufferevent.h	/^enum bufferevent_flush_mode {$/;"	g
bufferevent_free	bufferevent.c	/^bufferevent_free(struct bufferevent *bufev)$/;"	f	signature:(struct bufferevent *bufev)
bufferevent_free	include/event2/bufferevent.h	/^void bufferevent_free(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
bufferevent_generic_read_timeout_cb	bufferevent.c	/^bufferevent_generic_read_timeout_cb(evutil_socket_t fd, short event, void *ctx)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *ctx)
bufferevent_generic_write_timeout_cb	bufferevent.c	/^bufferevent_generic_write_timeout_cb(evutil_socket_t fd, short event, void *ctx)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *ctx)
bufferevent_get_base	bufferevent.c	/^bufferevent_get_base(struct bufferevent *bufev)$/;"	f	signature:(struct bufferevent *bufev)
bufferevent_get_base	include/event2/bufferevent.h	/^struct event_base *bufferevent_get_base(struct bufferevent *bev);$/;"	p	signature:(struct bufferevent *bev)
bufferevent_get_enabled	bufferevent.c	/^bufferevent_get_enabled(struct bufferevent *bufev)$/;"	f	signature:(struct bufferevent *bufev)
bufferevent_get_enabled	include/event2/bufferevent.h	/^short bufferevent_get_enabled(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
bufferevent_get_input	bufferevent.c	/^bufferevent_get_input(struct bufferevent *bufev)$/;"	f	signature:(struct bufferevent *bufev)
bufferevent_get_input	include/event2/bufferevent.h	/^struct evbuffer *bufferevent_get_input(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
bufferevent_get_max_to_read	bufferevent_ratelim.c	/^bufferevent_get_max_to_read(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
bufferevent_get_max_to_read	include/event2/bufferevent.h	/^ev_ssize_t bufferevent_get_max_to_read(struct bufferevent *bev);$/;"	p	signature:(struct bufferevent *bev)
bufferevent_get_max_to_write	bufferevent_ratelim.c	/^bufferevent_get_max_to_write(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
bufferevent_get_max_to_write	include/event2/bufferevent.h	/^ev_ssize_t bufferevent_get_max_to_write(struct bufferevent *bev);$/;"	p	signature:(struct bufferevent *bev)
bufferevent_get_openssl_error	bufferevent_openssl.c	/^bufferevent_get_openssl_error(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
bufferevent_get_openssl_error	include/event2/bufferevent_ssl.h	/^unsigned long bufferevent_get_openssl_error(struct bufferevent *bev);$/;"	p	signature:(struct bufferevent *bev)
bufferevent_get_output	bufferevent.c	/^bufferevent_get_output(struct bufferevent *bufev)$/;"	f	signature:(struct bufferevent *bufev)
bufferevent_get_output	include/event2/bufferevent.h	/^struct evbuffer *bufferevent_get_output(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
bufferevent_get_read_limit	bufferevent_ratelim.c	/^bufferevent_get_read_limit(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
bufferevent_get_read_limit	include/event2/bufferevent.h	/^ev_ssize_t bufferevent_get_read_limit(struct bufferevent *bev);$/;"	p	signature:(struct bufferevent *bev)
bufferevent_get_underlying	bufferevent.c	/^bufferevent_get_underlying(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
bufferevent_get_underlying	include/event2/bufferevent.h	/^struct bufferevent *bufferevent_get_underlying(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
bufferevent_get_write_limit	bufferevent_ratelim.c	/^bufferevent_get_write_limit(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
bufferevent_get_write_limit	include/event2/bufferevent.h	/^ev_ssize_t bufferevent_get_write_limit(struct bufferevent *bev);$/;"	p	signature:(struct bufferevent *bev)
bufferevent_getfd	bufferevent.c	/^bufferevent_getfd(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
bufferevent_getfd	include/event2/bufferevent.h	/^evutil_socket_t bufferevent_getfd(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
bufferevent_inbuf_wm_cb	bufferevent.c	/^bufferevent_inbuf_wm_cb(struct evbuffer *buf,$/;"	f	file:	signature:(struct evbuffer *buf, const struct evbuffer_cb_info *cbinfo, void *arg)
bufferevent_incref	bufferevent-internal.h	/^void bufferevent_incref(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
bufferevent_incref	bufferevent.c	/^bufferevent_incref(struct bufferevent *bufev)$/;"	f	signature:(struct bufferevent *bufev)
bufferevent_init_common	bufferevent-internal.h	/^int bufferevent_init_common(struct bufferevent_private *, struct event_base *, const struct bufferevent_ops *, enum bufferevent_options options);$/;"	p	signature:(struct bufferevent_private *, struct event_base *, const struct bufferevent_ops *, enum bufferevent_options options)
bufferevent_init_common	bufferevent.c	/^bufferevent_init_common(struct bufferevent_private *bufev_private,$/;"	f	signature:(struct bufferevent_private *bufev_private, struct event_base *base, const struct bufferevent_ops *ops, enum bufferevent_options options)
bufferevent_input_filter	test/regress_bufferevent.c	/^bufferevent_input_filter(struct evbuffer *src, struct evbuffer *dst,$/;"	f	file:	signature:(struct evbuffer *src, struct evbuffer *dst, ev_ssize_t lim, enum bufferevent_flush_mode state, void *ctx)
bufferevent_iocp_testcases	test/regress_bufferevent.c	/^struct testcase_t bufferevent_iocp_testcases[] = {$/;"	v	typeref:struct:testcase_t
bufferevent_lock	bufferevent.c	/^bufferevent_lock(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
bufferevent_lock	include/event2/bufferevent.h	/^void bufferevent_lock(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
bufferevent_new	bufferevent_sock.c	/^bufferevent_new(evutil_socket_t fd,$/;"	f	signature:(evutil_socket_t fd, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, void *cbarg)
bufferevent_new	include/event2/bufferevent_compat.h	/^struct bufferevent *bufferevent_new(evutil_socket_t fd,$/;"	p	signature:(evutil_socket_t fd, evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg)
bufferevent_openssl	bufferevent_openssl.c	/^struct bufferevent_openssl {$/;"	s	file:
bufferevent_openssl::allow_dirty_shutdown	bufferevent_openssl.c	/^	unsigned allow_dirty_shutdown : 1;$/;"	m	struct:bufferevent_openssl	file:	access:public
bufferevent_openssl::bev	bufferevent_openssl.c	/^	struct bufferevent_private bev;$/;"	m	struct:bufferevent_openssl	typeref:struct:bufferevent_openssl::bufferevent_private	file:	access:public
bufferevent_openssl::counts	bufferevent_openssl.c	/^	struct bio_data_counts counts;$/;"	m	struct:bufferevent_openssl	typeref:struct:bufferevent_openssl::bio_data_counts	file:	access:public
bufferevent_openssl::errors	bufferevent_openssl.c	/^	ev_uint32_t errors[NUM_ERRORS];$/;"	m	struct:bufferevent_openssl	file:	access:public
bufferevent_openssl::fd_is_set	bufferevent_openssl.c	/^	unsigned fd_is_set : 1;$/;"	m	struct:bufferevent_openssl	file:	access:public
bufferevent_openssl::last_write	bufferevent_openssl.c	/^	ev_ssize_t last_write;$/;"	m	struct:bufferevent_openssl	file:	access:public
bufferevent_openssl::n_errors	bufferevent_openssl.c	/^	unsigned n_errors : 2;$/;"	m	struct:bufferevent_openssl	file:	access:public
bufferevent_openssl::outbuf_cb	bufferevent_openssl.c	/^	struct evbuffer_cb_entry *outbuf_cb;$/;"	m	struct:bufferevent_openssl	typeref:struct:bufferevent_openssl::evbuffer_cb_entry	file:	access:public
bufferevent_openssl::read_blocked_on_write	bufferevent_openssl.c	/^	unsigned read_blocked_on_write : 1;$/;"	m	struct:bufferevent_openssl	file:	access:public
bufferevent_openssl::ssl	bufferevent_openssl.c	/^	SSL *ssl;$/;"	m	struct:bufferevent_openssl	file:	access:public
bufferevent_openssl::state	bufferevent_openssl.c	/^	unsigned state : 2;$/;"	m	struct:bufferevent_openssl	file:	access:public
bufferevent_openssl::underlying	bufferevent_openssl.c	/^	struct bufferevent *underlying;$/;"	m	struct:bufferevent_openssl	typeref:struct:bufferevent_openssl::bufferevent	file:	access:public
bufferevent_openssl::write_blocked_on_read	bufferevent_openssl.c	/^	unsigned write_blocked_on_read : 1;$/;"	m	struct:bufferevent_openssl	file:	access:public
bufferevent_openssl_filter_new	bufferevent_openssl.c	/^bufferevent_openssl_filter_new(struct event_base *base,$/;"	f	signature:(struct event_base *base, struct bufferevent *underlying, SSL *ssl, enum bufferevent_ssl_state state, int options)
bufferevent_openssl_filter_new	include/event2/bufferevent_ssl.h	/^bufferevent_openssl_filter_new(struct event_base *base,$/;"	p	signature:(struct event_base *base, struct bufferevent *underlying, struct ssl_st *ssl, enum bufferevent_ssl_state state, int options)
bufferevent_openssl_get_ssl	bufferevent_openssl.c	/^bufferevent_openssl_get_ssl(struct bufferevent *bufev)$/;"	f	signature:(struct bufferevent *bufev)
bufferevent_openssl_get_ssl	include/event2/bufferevent_ssl.h	/^bufferevent_openssl_get_ssl(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
bufferevent_openssl_new_impl	bufferevent_openssl.c	/^bufferevent_openssl_new_impl(struct event_base *base,$/;"	f	file:	signature:(struct event_base *base, struct bufferevent *underlying, evutil_socket_t fd, SSL *ssl, enum bufferevent_ssl_state state, int options)
bufferevent_openssl_socket_new	bufferevent_openssl.c	/^bufferevent_openssl_socket_new(struct event_base *base,$/;"	f	signature:(struct event_base *base, evutil_socket_t fd, SSL *ssl, enum bufferevent_ssl_state state, int options)
bufferevent_openssl_socket_new	include/event2/bufferevent_ssl.h	/^bufferevent_openssl_socket_new(struct event_base *base,$/;"	p	signature:(struct event_base *base, evutil_socket_t fd, struct ssl_st *ssl, enum bufferevent_ssl_state state, int options)
bufferevent_ops	bufferevent-internal.h	/^struct bufferevent_ops {$/;"	s
bufferevent_ops::adj_timeouts	bufferevent-internal.h	/^	int (*adj_timeouts)(struct bufferevent *);$/;"	m	struct:bufferevent_ops	access:public
bufferevent_ops::ctrl	bufferevent-internal.h	/^	int (*ctrl)(struct bufferevent *, enum bufferevent_ctrl_op, union bufferevent_ctrl_data *);$/;"	m	struct:bufferevent_ops	access:public
bufferevent_ops::destruct	bufferevent-internal.h	/^	void (*destruct)(struct bufferevent *);$/;"	m	struct:bufferevent_ops	access:public
bufferevent_ops::disable	bufferevent-internal.h	/^	int (*disable)(struct bufferevent *, short);$/;"	m	struct:bufferevent_ops	access:public
bufferevent_ops::enable	bufferevent-internal.h	/^	int (*enable)(struct bufferevent *, short);$/;"	m	struct:bufferevent_ops	access:public
bufferevent_ops::flush	bufferevent-internal.h	/^	int (*flush)(struct bufferevent *, short, enum bufferevent_flush_mode);$/;"	m	struct:bufferevent_ops	access:public
bufferevent_ops::mem_offset	bufferevent-internal.h	/^	off_t mem_offset;$/;"	m	struct:bufferevent_ops	access:public
bufferevent_ops::type	bufferevent-internal.h	/^	const char *type;$/;"	m	struct:bufferevent_ops	access:public
bufferevent_ops_async	bufferevent_async.c	/^const struct bufferevent_ops bufferevent_ops_async = {$/;"	v	typeref:struct:bufferevent_ops
bufferevent_ops_filter	bufferevent_filter.c	/^const struct bufferevent_ops bufferevent_ops_filter = {$/;"	v	typeref:struct:bufferevent_ops
bufferevent_ops_openssl	bufferevent_openssl.c	/^const struct bufferevent_ops bufferevent_ops_openssl = {$/;"	v	typeref:struct:bufferevent_ops
bufferevent_ops_pair	bufferevent_pair.c	/^const struct bufferevent_ops bufferevent_ops_pair = {$/;"	v	typeref:struct:bufferevent_ops
bufferevent_ops_socket	bufferevent_sock.c	/^const struct bufferevent_ops bufferevent_ops_socket = {$/;"	v	typeref:struct:bufferevent_ops
bufferevent_options	include/event2/bufferevent.h	/^enum bufferevent_options {$/;"	g
bufferevent_output_filter	test/regress_bufferevent.c	/^bufferevent_output_filter(struct evbuffer *src, struct evbuffer *dst,$/;"	f	file:	signature:(struct evbuffer *src, struct evbuffer *dst, ev_ssize_t lim, enum bufferevent_flush_mode state, void *ctx)
bufferevent_pair	bufferevent_pair.c	/^struct bufferevent_pair {$/;"	s	file:
bufferevent_pair::bev	bufferevent_pair.c	/^	struct bufferevent_private bev;$/;"	m	struct:bufferevent_pair	typeref:struct:bufferevent_pair::bufferevent_private	file:	access:public
bufferevent_pair::partner	bufferevent_pair.c	/^	struct bufferevent_pair *partner;$/;"	m	struct:bufferevent_pair	typeref:struct:bufferevent_pair::bufferevent_pair	file:	access:public
bufferevent_pair_elt_new	bufferevent_pair.c	/^bufferevent_pair_elt_new(struct event_base *base,$/;"	f	file:	signature:(struct event_base *base, int options)
bufferevent_pair_get_partner	bufferevent_pair.c	/^bufferevent_pair_get_partner(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
bufferevent_pair_get_partner	include/event2/bufferevent.h	/^struct bufferevent *bufferevent_pair_get_partner(struct bufferevent *bev);$/;"	p	signature:(struct bufferevent *bev)
bufferevent_pair_new	bufferevent_pair.c	/^bufferevent_pair_new(struct event_base *base, int options,$/;"	f	signature:(struct event_base *base, int options, struct bufferevent *pair[2])
bufferevent_pair_new	include/event2/bufferevent.h	/^int bufferevent_pair_new(struct event_base *base, int options,$/;"	p	signature:(struct event_base *base, int options, struct bufferevent *pair[2])
bufferevent_priority_set	bufferevent_sock.c	/^bufferevent_priority_set(struct bufferevent *bufev, int priority)$/;"	f	signature:(struct bufferevent *bufev, int priority)
bufferevent_priority_set	include/event2/bufferevent.h	/^int bufferevent_priority_set(struct bufferevent *bufev, int pri);$/;"	p	signature:(struct bufferevent *bufev, int pri)
bufferevent_private	bufferevent-internal.h	/^struct bufferevent_private {$/;"	s
bufferevent_private::bev	bufferevent-internal.h	/^	struct bufferevent bev;$/;"	m	struct:bufferevent_private	typeref:struct:bufferevent_private::bufferevent	access:public
bufferevent_private::connecting	bufferevent-internal.h	/^	unsigned connecting : 1;$/;"	m	struct:bufferevent_private	access:public
bufferevent_private::connection_refused	bufferevent-internal.h	/^	unsigned connection_refused : 1;$/;"	m	struct:bufferevent_private	access:public
bufferevent_private::deferred	bufferevent-internal.h	/^	struct deferred_cb deferred;$/;"	m	struct:bufferevent_private	typeref:struct:bufferevent_private::deferred_cb	access:public
bufferevent_private::dns_error	bufferevent-internal.h	/^	int dns_error;$/;"	m	struct:bufferevent_private	access:public
bufferevent_private::errno_pending	bufferevent-internal.h	/^	int errno_pending;$/;"	m	struct:bufferevent_private	access:public
bufferevent_private::eventcb_pending	bufferevent-internal.h	/^	short eventcb_pending;$/;"	m	struct:bufferevent_private	access:public
bufferevent_private::lock	bufferevent-internal.h	/^	void *lock;$/;"	m	struct:bufferevent_private	access:public
bufferevent_private::options	bufferevent-internal.h	/^	enum bufferevent_options options;$/;"	m	struct:bufferevent_private	typeref:enum:bufferevent_private::bufferevent_options	access:public
bufferevent_private::own_lock	bufferevent-internal.h	/^	unsigned own_lock : 1;$/;"	m	struct:bufferevent_private	access:public
bufferevent_private::rate_limiting	bufferevent-internal.h	/^	struct bufferevent_rate_limit *rate_limiting;$/;"	m	struct:bufferevent_private	typeref:struct:bufferevent_private::bufferevent_rate_limit	access:public
bufferevent_private::read_suspended	bufferevent-internal.h	/^	bufferevent_suspend_flags read_suspended;$/;"	m	struct:bufferevent_private	access:public
bufferevent_private::read_watermarks_cb	bufferevent-internal.h	/^	struct evbuffer_cb_entry *read_watermarks_cb;$/;"	m	struct:bufferevent_private	typeref:struct:bufferevent_private::evbuffer_cb_entry	access:public
bufferevent_private::readcb_pending	bufferevent-internal.h	/^	unsigned readcb_pending : 1;$/;"	m	struct:bufferevent_private	access:public
bufferevent_private::refcnt	bufferevent-internal.h	/^	int refcnt;$/;"	m	struct:bufferevent_private	access:public
bufferevent_private::write_suspended	bufferevent-internal.h	/^	bufferevent_suspend_flags write_suspended;$/;"	m	struct:bufferevent_private	access:public
bufferevent_private::writecb_pending	bufferevent-internal.h	/^	unsigned writecb_pending : 1;$/;"	m	struct:bufferevent_private	access:public
bufferevent_rate_limit	bufferevent-internal.h	/^struct bufferevent_rate_limit {$/;"	s
bufferevent_rate_limit::cfg	bufferevent-internal.h	/^	struct ev_token_bucket_cfg *cfg;$/;"	m	struct:bufferevent_rate_limit	typeref:struct:bufferevent_rate_limit::ev_token_bucket_cfg	access:public
bufferevent_rate_limit::group	bufferevent-internal.h	/^	struct bufferevent_rate_limit_group *group;$/;"	m	struct:bufferevent_rate_limit	typeref:struct:bufferevent_rate_limit::bufferevent_rate_limit_group	access:public
bufferevent_rate_limit::limit	bufferevent-internal.h	/^	struct ev_token_bucket limit;$/;"	m	struct:bufferevent_rate_limit	typeref:struct:bufferevent_rate_limit::ev_token_bucket	access:public
bufferevent_rate_limit::next_in_group	bufferevent-internal.h	/^	TAILQ_ENTRY(bufferevent_private) next_in_group;$/;"	m	struct:bufferevent_rate_limit	access:public
bufferevent_rate_limit::refill_bucket_event	bufferevent-internal.h	/^	struct event refill_bucket_event;$/;"	m	struct:bufferevent_rate_limit	typeref:struct:bufferevent_rate_limit::event	access:public
bufferevent_rate_limit_group	bufferevent-internal.h	/^struct bufferevent_rate_limit_group {$/;"	s
bufferevent_rate_limit_group::configured_min_share	bufferevent-internal.h	/^	ev_ssize_t configured_min_share;$/;"	m	struct:bufferevent_rate_limit_group	access:public
bufferevent_rate_limit_group::lock	bufferevent-internal.h	/^	void *lock;$/;"	m	struct:bufferevent_rate_limit_group	access:public
bufferevent_rate_limit_group::master_refill_event	bufferevent-internal.h	/^	struct event master_refill_event;$/;"	m	struct:bufferevent_rate_limit_group	typeref:struct:bufferevent_rate_limit_group::event	access:public
bufferevent_rate_limit_group::members	bufferevent-internal.h	/^	TAILQ_HEAD(rlim_group_member_list, bufferevent_private) members;$/;"	m	struct:bufferevent_rate_limit_group	access:public
bufferevent_rate_limit_group::min_share	bufferevent-internal.h	/^	ev_ssize_t min_share;$/;"	m	struct:bufferevent_rate_limit_group	access:public
bufferevent_rate_limit_group::n_members	bufferevent-internal.h	/^	int n_members;$/;"	m	struct:bufferevent_rate_limit_group	access:public
bufferevent_rate_limit_group::pending_unsuspend_read	bufferevent-internal.h	/^	unsigned pending_unsuspend_read : 1;$/;"	m	struct:bufferevent_rate_limit_group	access:public
bufferevent_rate_limit_group::pending_unsuspend_write	bufferevent-internal.h	/^	unsigned pending_unsuspend_write : 1;$/;"	m	struct:bufferevent_rate_limit_group	access:public
bufferevent_rate_limit_group::rate_limit	bufferevent-internal.h	/^	struct ev_token_bucket rate_limit;$/;"	m	struct:bufferevent_rate_limit_group	typeref:struct:bufferevent_rate_limit_group::ev_token_bucket	access:public
bufferevent_rate_limit_group::rate_limit_cfg	bufferevent-internal.h	/^	struct ev_token_bucket_cfg rate_limit_cfg;$/;"	m	struct:bufferevent_rate_limit_group	typeref:struct:bufferevent_rate_limit_group::ev_token_bucket_cfg	access:public
bufferevent_rate_limit_group::read_suspended	bufferevent-internal.h	/^	unsigned read_suspended : 1;$/;"	m	struct:bufferevent_rate_limit_group	access:public
bufferevent_rate_limit_group::total_read	bufferevent-internal.h	/^	ev_uint64_t total_read;$/;"	m	struct:bufferevent_rate_limit_group	access:public
bufferevent_rate_limit_group::total_written	bufferevent-internal.h	/^	ev_uint64_t total_written;$/;"	m	struct:bufferevent_rate_limit_group	access:public
bufferevent_rate_limit_group::write_suspended	bufferevent-internal.h	/^	unsigned write_suspended : 1;$/;"	m	struct:bufferevent_rate_limit_group	access:public
bufferevent_rate_limit_group_decrement_read	bufferevent_ratelim.c	/^bufferevent_rate_limit_group_decrement_read($/;"	f	signature:( struct bufferevent_rate_limit_group *grp, ev_ssize_t decr)
bufferevent_rate_limit_group_decrement_read	include/event2/bufferevent.h	/^int bufferevent_rate_limit_group_decrement_read($/;"	p	signature:( struct bufferevent_rate_limit_group *, ev_ssize_t)
bufferevent_rate_limit_group_decrement_write	bufferevent_ratelim.c	/^bufferevent_rate_limit_group_decrement_write($/;"	f	signature:( struct bufferevent_rate_limit_group *grp, ev_ssize_t decr)
bufferevent_rate_limit_group_decrement_write	include/event2/bufferevent.h	/^int bufferevent_rate_limit_group_decrement_write($/;"	p	signature:( struct bufferevent_rate_limit_group *, ev_ssize_t)
bufferevent_rate_limit_group_free	bufferevent_ratelim.c	/^bufferevent_rate_limit_group_free(struct bufferevent_rate_limit_group *g)$/;"	f	signature:(struct bufferevent_rate_limit_group *g)
bufferevent_rate_limit_group_free	include/event2/bufferevent.h	/^void bufferevent_rate_limit_group_free(struct bufferevent_rate_limit_group *);$/;"	p	signature:(struct bufferevent_rate_limit_group *)
bufferevent_rate_limit_group_get_read_limit	bufferevent_ratelim.c	/^bufferevent_rate_limit_group_get_read_limit($/;"	f	signature:( struct bufferevent_rate_limit_group *grp)
bufferevent_rate_limit_group_get_read_limit	include/event2/bufferevent.h	/^ev_ssize_t bufferevent_rate_limit_group_get_read_limit($/;"	p	signature:( struct bufferevent_rate_limit_group *)
bufferevent_rate_limit_group_get_totals	bufferevent_ratelim.c	/^bufferevent_rate_limit_group_get_totals(struct bufferevent_rate_limit_group *grp,$/;"	f	signature:(struct bufferevent_rate_limit_group *grp, ev_uint64_t *total_read_out, ev_uint64_t *total_written_out)
bufferevent_rate_limit_group_get_totals	include/event2/bufferevent.h	/^void bufferevent_rate_limit_group_get_totals($/;"	p	signature:( struct bufferevent_rate_limit_group *grp, ev_uint64_t *total_read_out, ev_uint64_t *total_written_out)
bufferevent_rate_limit_group_get_write_limit	bufferevent_ratelim.c	/^bufferevent_rate_limit_group_get_write_limit($/;"	f	signature:( struct bufferevent_rate_limit_group *grp)
bufferevent_rate_limit_group_get_write_limit	include/event2/bufferevent.h	/^ev_ssize_t bufferevent_rate_limit_group_get_write_limit($/;"	p	signature:( struct bufferevent_rate_limit_group *)
bufferevent_rate_limit_group_new	bufferevent_ratelim.c	/^bufferevent_rate_limit_group_new(struct event_base *base,$/;"	f	signature:(struct event_base *base, const struct ev_token_bucket_cfg *cfg)
bufferevent_rate_limit_group_new	include/event2/bufferevent.h	/^struct bufferevent_rate_limit_group *bufferevent_rate_limit_group_new($/;"	p	signature:( struct event_base *base, const struct ev_token_bucket_cfg *cfg)
bufferevent_rate_limit_group_reset_totals	bufferevent_ratelim.c	/^bufferevent_rate_limit_group_reset_totals(struct bufferevent_rate_limit_group *grp)$/;"	f	signature:(struct bufferevent_rate_limit_group *grp)
bufferevent_rate_limit_group_reset_totals	include/event2/bufferevent.h	/^bufferevent_rate_limit_group_reset_totals($/;"	p	signature:( struct bufferevent_rate_limit_group *grp)
bufferevent_rate_limit_group_set_cfg	bufferevent_ratelim.c	/^bufferevent_rate_limit_group_set_cfg($/;"	f	signature:( struct bufferevent_rate_limit_group *g, const struct ev_token_bucket_cfg *cfg)
bufferevent_rate_limit_group_set_cfg	include/event2/bufferevent.h	/^int bufferevent_rate_limit_group_set_cfg($/;"	p	signature:( struct bufferevent_rate_limit_group *, const struct ev_token_bucket_cfg *)
bufferevent_rate_limit_group_set_min_share	bufferevent_ratelim.c	/^bufferevent_rate_limit_group_set_min_share($/;"	f	signature:( struct bufferevent_rate_limit_group *g, size_t share)
bufferevent_rate_limit_group_set_min_share	include/event2/bufferevent.h	/^int bufferevent_rate_limit_group_set_min_share($/;"	p	signature:( struct bufferevent_rate_limit_group *, size_t)
bufferevent_read	bufferevent.c	/^bufferevent_read(struct bufferevent *bufev, void *data, size_t size)$/;"	f	signature:(struct bufferevent *bufev, void *data, size_t size)
bufferevent_read	include/event2/bufferevent.h	/^size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);$/;"	p	signature:(struct bufferevent *bufev, void *data, size_t size)
bufferevent_read_buffer	bufferevent.c	/^bufferevent_read_buffer(struct bufferevent *bufev, struct evbuffer *buf)$/;"	f	signature:(struct bufferevent *bufev, struct evbuffer *buf)
bufferevent_read_buffer	include/event2/bufferevent.h	/^int bufferevent_read_buffer(struct bufferevent *bufev, struct evbuffer *buf);$/;"	p	signature:(struct bufferevent *bufev, struct evbuffer *buf)
bufferevent_readcb	bufferevent_sock.c	/^bufferevent_readcb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
bufferevent_remove_from_rate_limit_group	bufferevent_ratelim.c	/^bufferevent_remove_from_rate_limit_group(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
bufferevent_remove_from_rate_limit_group	include/event2/bufferevent.h	/^int bufferevent_remove_from_rate_limit_group(struct bufferevent *bev);$/;"	p	signature:(struct bufferevent *bev)
bufferevent_remove_from_rate_limit_group_internal	bufferevent_ratelim.c	/^bufferevent_remove_from_rate_limit_group_internal(struct bufferevent *bev,$/;"	f	signature:(struct bufferevent *bev, int unsuspend)
bufferevent_remove_from_rate_limit_group_internal	ratelim-internal.h	/^int bufferevent_remove_from_rate_limit_group_internal(struct bufferevent *bev,$/;"	p	signature:(struct bufferevent *bev, int unsuspend)
bufferevent_run_deferred_callbacks_locked	bufferevent.c	/^bufferevent_run_deferred_callbacks_locked(struct deferred_cb *_, void *arg)$/;"	f	file:	signature:(struct deferred_cb *_, void *arg)
bufferevent_run_deferred_callbacks_unlocked	bufferevent.c	/^bufferevent_run_deferred_callbacks_unlocked(struct deferred_cb *_, void *arg)$/;"	f	file:	signature:(struct deferred_cb *_, void *arg)
bufferevent_set_rate_limit	bufferevent_ratelim.c	/^bufferevent_set_rate_limit(struct bufferevent *bev,$/;"	f	signature:(struct bufferevent *bev, struct ev_token_bucket_cfg *cfg)
bufferevent_set_rate_limit	include/event2/bufferevent.h	/^int bufferevent_set_rate_limit(struct bufferevent *bev,$/;"	p	signature:(struct bufferevent *bev, struct ev_token_bucket_cfg *cfg)
bufferevent_set_timeouts	bufferevent.c	/^bufferevent_set_timeouts(struct bufferevent *bufev,$/;"	f	signature:(struct bufferevent *bufev, const struct timeval *tv_read, const struct timeval *tv_write)
bufferevent_set_timeouts	include/event2/bufferevent.h	/^int bufferevent_set_timeouts(struct bufferevent *bufev,$/;"	p	signature:(struct bufferevent *bufev, const struct timeval *timeout_read, const struct timeval *timeout_write)
bufferevent_setcb	bufferevent.c	/^bufferevent_setcb(struct bufferevent *bufev,$/;"	f	signature:(struct bufferevent *bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, void *cbarg)
bufferevent_setcb	include/event2/bufferevent.h	/^void bufferevent_setcb(struct bufferevent *bufev,$/;"	p	signature:(struct bufferevent *bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, void *cbarg)
bufferevent_setfd	bufferevent.c	/^bufferevent_setfd(struct bufferevent *bev, evutil_socket_t fd)$/;"	f	signature:(struct bufferevent *bev, evutil_socket_t fd)
bufferevent_setfd	include/event2/bufferevent.h	/^int bufferevent_setfd(struct bufferevent *bufev, evutil_socket_t fd);$/;"	p	signature:(struct bufferevent *bufev, evutil_socket_t fd)
bufferevent_settimeout	bufferevent.c	/^bufferevent_settimeout(struct bufferevent *bufev,$/;"	f	signature:(struct bufferevent *bufev, int timeout_read, int timeout_write)
bufferevent_settimeout	include/event2/bufferevent_compat.h	/^void bufferevent_settimeout(struct bufferevent *bufev,$/;"	p	signature:(struct bufferevent *bufev, int timeout_read, int timeout_write)
bufferevent_setwatermark	bufferevent.c	/^bufferevent_setwatermark(struct bufferevent *bufev, short events,$/;"	f	signature:(struct bufferevent *bufev, short events, size_t lowmark, size_t highmark)
bufferevent_setwatermark	include/event2/bufferevent.h	/^void bufferevent_setwatermark(struct bufferevent *bufev, short events,$/;"	p	signature:(struct bufferevent *bufev, short events, size_t lowmark, size_t highmark)
bufferevent_socket_connect	bufferevent_sock.c	/^bufferevent_socket_connect(struct bufferevent *bev,$/;"	f	signature:(struct bufferevent *bev, struct sockaddr *sa, int socklen)
bufferevent_socket_connect	include/event2/bufferevent.h	/^int bufferevent_socket_connect(struct bufferevent *, struct sockaddr *, int);$/;"	p	signature:(struct bufferevent *, struct sockaddr *, int)
bufferevent_socket_connect_hostname	bufferevent_sock.c	/^bufferevent_socket_connect_hostname(struct bufferevent *bev,$/;"	f	signature:(struct bufferevent *bev, struct evdns_base *evdns_base, int family, const char *hostname, int port)
bufferevent_socket_connect_hostname	include/event2/bufferevent.h	/^int bufferevent_socket_connect_hostname(struct bufferevent *,$/;"	p	signature:(struct bufferevent *, struct evdns_base *, int, const char *, int)
bufferevent_socket_get_dns_error	bufferevent_sock.c	/^bufferevent_socket_get_dns_error(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
bufferevent_socket_get_dns_error	include/event2/bufferevent.h	/^int bufferevent_socket_get_dns_error(struct bufferevent *bev);$/;"	p	signature:(struct bufferevent *bev)
bufferevent_socket_new	bufferevent_sock.c	/^bufferevent_socket_new(struct event_base *base, evutil_socket_t fd,$/;"	f	signature:(struct event_base *base, evutil_socket_t fd, int options)
bufferevent_socket_new	include/event2/bufferevent.h	/^struct bufferevent *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, int options);$/;"	p	signature:(struct event_base *base, evutil_socket_t fd, int options)
bufferevent_socket_outbuf_cb	bufferevent_sock.c	/^bufferevent_socket_outbuf_cb(struct evbuffer *buf,$/;"	f	file:	signature:(struct evbuffer *buf, const struct evbuffer_cb_info *cbinfo, void *arg)
bufferevent_ssl_renegotiate	bufferevent_openssl.c	/^bufferevent_ssl_renegotiate(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
bufferevent_ssl_renegotiate	include/event2/bufferevent_ssl.h	/^int bufferevent_ssl_renegotiate(struct bufferevent *bev);$/;"	p	signature:(struct bufferevent *bev)
bufferevent_ssl_state	include/event2/bufferevent_ssl.h	/^enum bufferevent_ssl_state {$/;"	g
bufferevent_suspend_flags	bufferevent-internal.h	/^typedef ev_uint16_t bufferevent_suspend_flags;$/;"	t
bufferevent_suspend_read	bufferevent-internal.h	/^void bufferevent_suspend_read(struct bufferevent *bufev, bufferevent_suspend_flags what);$/;"	p	signature:(struct bufferevent *bufev, bufferevent_suspend_flags what)
bufferevent_suspend_read	bufferevent.c	/^bufferevent_suspend_read(struct bufferevent *bufev, bufferevent_suspend_flags what)$/;"	f	signature:(struct bufferevent *bufev, bufferevent_suspend_flags what)
bufferevent_suspend_write	bufferevent-internal.h	/^void bufferevent_suspend_write(struct bufferevent *bufev, bufferevent_suspend_flags what);$/;"	p	signature:(struct bufferevent *bufev, bufferevent_suspend_flags what)
bufferevent_suspend_write	bufferevent.c	/^bufferevent_suspend_write(struct bufferevent *bufev, bufferevent_suspend_flags what)$/;"	f	signature:(struct bufferevent *bufev, bufferevent_suspend_flags what)
bufferevent_testcases	test/regress_bufferevent.c	/^struct testcase_t bufferevent_testcases[] = {$/;"	v	typeref:struct:testcase_t
bufferevent_unlock	bufferevent.c	/^bufferevent_unlock(struct bufferevent *bev)$/;"	f	signature:(struct bufferevent *bev)
bufferevent_unlock	include/event2/bufferevent.h	/^void bufferevent_unlock(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
bufferevent_unsuspend_read	bufferevent-internal.h	/^void bufferevent_unsuspend_read(struct bufferevent *bufev, bufferevent_suspend_flags what);$/;"	p	signature:(struct bufferevent *bufev, bufferevent_suspend_flags what)
bufferevent_unsuspend_read	bufferevent.c	/^bufferevent_unsuspend_read(struct bufferevent *bufev, bufferevent_suspend_flags what)$/;"	f	signature:(struct bufferevent *bufev, bufferevent_suspend_flags what)
bufferevent_unsuspend_write	bufferevent-internal.h	/^void bufferevent_unsuspend_write(struct bufferevent *bufev, bufferevent_suspend_flags what);$/;"	p	signature:(struct bufferevent *bufev, bufferevent_suspend_flags what)
bufferevent_unsuspend_write	bufferevent.c	/^bufferevent_unsuspend_write(struct bufferevent *bufev, bufferevent_suspend_flags what)$/;"	f	signature:(struct bufferevent *bufev, bufferevent_suspend_flags what)
bufferevent_update_buckets	bufferevent_ratelim.c	/^bufferevent_update_buckets(struct bufferevent_private *bev)$/;"	f	file:	signature:(struct bufferevent_private *bev)
bufferevent_wm_suspend_read	bufferevent-internal.h	289;"	d
bufferevent_wm_unsuspend_read	bufferevent-internal.h	291;"	d
bufferevent_write	bufferevent.c	/^bufferevent_write(struct bufferevent *bufev, const void *data, size_t size)$/;"	f	signature:(struct bufferevent *bufev, const void *data, size_t size)
bufferevent_write	include/event2/bufferevent.h	/^int bufferevent_write(struct bufferevent *bufev,$/;"	p	signature:(struct bufferevent *bufev, const void *data, size_t size)
bufferevent_write_buffer	bufferevent.c	/^bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *buf)$/;"	f	signature:(struct bufferevent *bufev, struct evbuffer *buf)
bufferevent_write_buffer	include/event2/bufferevent.h	/^int bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *buf);$/;"	p	signature:(struct bufferevent *bufev, struct evbuffer *buf)
bufferevent_writecb	bufferevent_sock.c	/^bufferevent_writecb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
buffers	buffer_iocp.c	/^	WSABUF buffers[MAX_WSABUFS];$/;"	m	struct:evbuffer_overlapped	file:	access:public
buflen	listener.c	/^	ev_uint8_t buflen;$/;"	m	struct:accepting_socket	file:	access:public
build	Makefile	/^build = i686-pc-linux-gnu$/;"	m
build	include/Makefile	/^build = i686-pc-linux-gnu$/;"	m
build	sample/Makefile	/^build = i686-pc-linux-gnu$/;"	m
build	test/Makefile	/^build = i686-pc-linux-gnu$/;"	m
build_alias	Makefile	/^build_alias = $/;"	m
build_alias	include/Makefile	/^build_alias = $/;"	m
build_alias	sample/Makefile	/^build_alias = $/;"	m
build_alias	test/Makefile	/^build_alias = $/;"	m
build_cpu	Makefile	/^build_cpu = i686$/;"	m
build_cpu	include/Makefile	/^build_cpu = i686$/;"	m
build_cpu	sample/Makefile	/^build_cpu = i686$/;"	m
build_cpu	test/Makefile	/^build_cpu = i686$/;"	m
build_os	Makefile	/^build_os = linux-gnu$/;"	m
build_os	include/Makefile	/^build_os = linux-gnu$/;"	m
build_os	sample/Makefile	/^build_os = linux-gnu$/;"	m
build_os	test/Makefile	/^build_os = linux-gnu$/;"	m
build_triplet	Makefile	/^build_triplet = i686-pc-linux-gnu$/;"	m
build_triplet	include/Makefile	/^build_triplet = i686-pc-linux-gnu$/;"	m
build_triplet	sample/Makefile	/^build_triplet = i686-pc-linux-gnu$/;"	m
build_triplet	test/Makefile	/^build_triplet = i686-pc-linux-gnu$/;"	m
build_vendor	Makefile	/^build_vendor = pc$/;"	m
build_vendor	include/Makefile	/^build_vendor = pc$/;"	m
build_vendor	sample/Makefile	/^build_vendor = pc$/;"	m
build_vendor	test/Makefile	/^build_vendor = pc$/;"	m
builddir	Makefile	/^builddir = .$/;"	m
builddir	include/Makefile	/^builddir = .$/;"	m
builddir	sample/Makefile	/^builddir = .$/;"	m
builddir	test/Makefile	/^builddir = .$/;"	m
bytes_to_read	bufferevent_openssl.c	/^bytes_to_read(struct bufferevent_openssl *bev)$/;"	f	file:	signature:(struct bufferevent_openssl *bev)
c	test/regress_util.c	/^	long c;$/;"	m	struct:example_struct	file:	access:public
call_count	test/regress_iocp.c	/^	int call_count;$/;"	m	struct:dummy_overlapped	file:	access:public
callback_count	test/regress_thread.c	/^static unsigned callback_count = 0;$/;"	v	file:
callbacks	evbuffer-internal.h	/^	TAILQ_HEAD(evbuffer_cb_queue, evbuffer_cb_entry) callbacks;$/;"	m	struct:evbuffer	access:public
callbacks	http-internal.h	/^	TAILQ_HEAD(httpcbq, evhttp_cb) callbacks;$/;"	m	struct:evhttp	access:public
callcount	test/regress.c	/^	unsigned int callcount;$/;"	m	struct:basic_cb_args	file:	access:public
called	sample/signal-test.c	/^int called = 0;$/;"	v
called	test/regress.c	/^int called;$/;"	v
called	test/test-eof.c	/^int called = 0;$/;"	v
called	test/test-time.c	/^int called = 0;$/;"	v
called	test/test-weof.c	/^int called = 0;$/;"	v
called_at	test/regress.c	/^	struct timeval called_at;$/;"	m	struct:common_timeout_info	typeref:struct:common_timeout_info::timeval	file:	access:public
cancel_event	test/regress_dns.c	/^	struct event cancel_event;$/;"	m	struct:gaic_request_status	typeref:struct:gaic_request_status::event	file:	access:public
cancel_gai_cb	test/regress_dns.c	/^cancel_gai_cb(evutil_socket_t fd, short what, void *ptr)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *ptr)
canceled	test/regress_dns.c	/^	int canceled;$/;"	m	struct:gaic_request_status	file:	access:public
cases	test/tinytest.h	/^	struct testcase_t *cases; \/** Array, ending with END_OF_TESTCASES *\/$/;"	m	struct:testgroup_t	typeref:struct:testgroup_t::testcase_t	access:public
cb	defer-internal.h	/^	deferred_cb_fn cb;$/;"	m	struct:deferred_cb	access:public
cb	evbuffer-internal.h	/^	} cb;$/;"	m	struct:evbuffer_cb_entry	typeref:union:evbuffer_cb_entry::__anon13	access:public
cb	event.c	/^	void (*cb)(evutil_socket_t, short, void *);$/;"	m	struct:event_once	file:	access:public
cb	evrpc-internal.h	/^	void (*cb)(struct evrpc_status*, void *request, void *reply, void *arg);$/;"	m	struct:evrpc_request_wrapper	access:public
cb	evrpc-internal.h	/^	void (*cb)(void *, enum EVRPC_HOOK_RESULT);$/;"	m	struct:evrpc_hook_ctx	access:public
cb	http-internal.h	/^	void (*cb)(struct evhttp_connection *, void *);$/;"	m	struct:evhttp_connection	access:public
cb	http-internal.h	/^	void (*cb)(struct evhttp_request *req, void *);$/;"	m	struct:evhttp_cb	access:public
cb	include/event2/http_struct.h	/^	void (*cb)(struct evhttp_request *, void *);$/;"	m	struct:evhttp_request	access:public
cb	include/event2/rpc_struct.h	/^	void (*cb)(struct evrpc_req_generic *, void *);$/;"	m	struct:evrpc	access:public
cb	iocp-internal.h	/^	iocp_callback cb;$/;"	m	struct:event_overlapped	access:public
cb	listener.c	/^	evconnlistener_cb cb;$/;"	m	struct:evconnlistener	file:	access:public
cb_arg	evrpc-internal.h	/^	void *cb_arg;$/;"	m	struct:evrpc_request_wrapper	access:public
cb_arg	http-internal.h	/^	void *cb_arg;$/;"	m	struct:evhttp_connection	access:public
cb_arg	include/event2/http_struct.h	/^	void *cb_arg;$/;"	m	struct:evhttp_request	access:public
cb_arg	include/event2/rpc_struct.h	/^	void *cb_arg;$/;"	m	struct:evrpc	access:public
cb_func	evbuffer-internal.h	/^		evbuffer_cb_func cb_func;$/;"	m	union:evbuffer_cb_entry::__anon13	access:public
cb_next	defer-internal.h	/^	TAILQ_ENTRY (deferred_cb) cb_next;$/;"	m	struct:deferred_cb	access:public
cb_obsolete	evbuffer-internal.h	/^		evbuffer_cb cb_obsolete;$/;"	m	union:evbuffer_cb_entry::__anon13	access:public
cb_queue	evbuffer-internal.h	/^	struct deferred_cb_queue *cb_queue;$/;"	m	struct:evbuffer	typeref:struct:evbuffer::deferred_cb_queue	access:public
cbarg	evbuffer-internal.h	/^	void *cbarg;$/;"	m	struct:evbuffer_cb_entry	access:public
cbarg	http-internal.h	/^	void *cbarg;$/;"	m	struct:evhttp_cb	access:public
cbarg	include/event2/bufferevent_struct.h	/^	void *cbarg;$/;"	m	struct:bufferevent	access:public
cbs	test/regress_thread.c	/^	struct deferred_cb cbs[CB_COUNT];$/;"	m	struct:deferred_test_data	typeref:struct:deferred_test_data::deferred_cb	file:	access:public
cfg	bufferevent-internal.h	/^	struct ev_token_bucket_cfg *cfg;$/;"	m	struct:bufferevent_rate_limit	typeref:struct:bufferevent_rate_limit::ev_token_bucket_cfg	access:public
cfg_connlimit	test/test-ratelim.c	/^static int cfg_connlimit = 0;$/;"	v	file:
cfg_connlimit_tolerance	test/test-ratelim.c	/^static int cfg_connlimit_tolerance = -1;$/;"	v	file:
cfg_duration	test/test-ratelim.c	/^static int cfg_duration = 5;$/;"	v	file:
cfg_enable_iocp	test/test-ratelim.c	/^static int cfg_enable_iocp = 0;$/;"	v	file:
cfg_grouplimit	test/test-ratelim.c	/^static int cfg_grouplimit = 0;$/;"	v	file:
cfg_grouplimit_tolerance	test/test-ratelim.c	/^static int cfg_grouplimit_tolerance = -1;$/;"	v	file:
cfg_help	test/test-ratelim.c	/^static int cfg_help = 0;$/;"	v	file:
cfg_min_share	test/test-ratelim.c	/^static int cfg_min_share = -1;$/;"	v	file:
cfg_n_connections	test/test-ratelim.c	/^static int cfg_n_connections = 30;$/;"	v	file:
cfg_stddev_tolerance	test/test-ratelim.c	/^static int cfg_stddev_tolerance = -1;$/;"	v	file:
cfg_tick	test/test-ratelim.c	/^static struct timeval cfg_tick = { 0, 500*1000 };$/;"	v	typeref:struct:timeval	file:
cfg_tick_msec	test/test-ratelim.c	/^static int cfg_tick_msec = 1000;$/;"	v	file:
cfg_verbose	test/test-ratelim.c	/^static int cfg_verbose = 0;$/;"	v	file:
chain	include/event2/buffer.h	/^		void *chain;$/;"	m	struct:evbuffer_ptr::__anon1	access:public
change_to_string	epoll.c	/^change_to_string(int change)$/;"	f	file:	signature:(int change)
changelist	event-internal.h	/^	struct event_changelist changelist;$/;"	m	struct:event_base	typeref:struct:event_base::event_changelist	access:public
changes	devpoll.c	/^	struct pollfd *changes;$/;"	m	struct:devpollop	typeref:struct:devpollop::pollfd	file:	access:public
changes	event-internal.h	/^	struct event_change *changes;$/;"	m	struct:event_changelist	typeref:struct:event_changelist::event_change	access:public
changes	kqueue.c	/^	struct kevent *changes;$/;"	m	struct:kqop	typeref:struct:kqop::kevent	file:	access:public
changes_size	event-internal.h	/^	int changes_size;$/;"	m	struct:event_changelist	access:public
changes_size	kqueue.c	/^	int changes_size;$/;"	m	struct:kqop	file:	access:public
check_dummy_mem_ok	test/regress.c	/^check_dummy_mem_ok(void *_mem)$/;"	f	file:	signature:(void *_mem)
check_error_logging	test/regress_util.c	/^check_error_logging(void (*fn)(void), int wantexitcode,$/;"	f	file:	signature:(void (*fn)(void), int wantexitcode, int wantseverity, const char *wantmsg)
check_event	evport.c	/^check_event(port_event_t* pevt)$/;"	f	file:	signature:(port_event_t* pevt)
check_event	evport.c	204;"	d	file:
check_evportop	evport.c	/^check_evportop(struct evport_data *evpd)$/;"	f	file:	signature:(struct evport_data *evpd)
check_evportop	evport.c	203;"	d	file:
check_heap	test/regress_minheap.c	/^check_heap(struct min_heap *heap)$/;"	f	file:	signature:(struct min_heap *heap)
check_selectop	select.c	/^check_selectop(struct selectop *sop)$/;"	f	file:	signature:(struct selectop *sop)
check_selectop	select.c	125;"	d	file:
child_signal_cb	test/regress.c	/^child_signal_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
choked	evdns.c	/^	char choked;  \/* true if we have an EAGAIN from this server's socket *\/$/;"	m	struct:nameserver	file:	access:public
choked	evdns.c	/^	char choked; \/* Are we currently blocked from writing? *\/$/;"	m	struct:evdns_server_port	file:	access:public
chunk_cb	include/event2/http_struct.h	/^	void (*chunk_cb)(struct evhttp_request *, void *);$/;"	m	struct:evhttp_request	access:public
chunk_req_state	test/regress_http.c	/^struct chunk_req_state {$/;"	s	file:
chunk_req_state::base	test/regress_http.c	/^	struct event_base *base;$/;"	m	struct:chunk_req_state	typeref:struct:chunk_req_state::event_base	file:	access:public
chunk_req_state::i	test/regress_http.c	/^	int i;$/;"	m	struct:chunk_req_state	file:	access:public
chunk_req_state::req	test/regress_http.c	/^	struct evhttp_request *req;$/;"	m	struct:chunk_req_state	typeref:struct:chunk_req_state::evhttp_request	file:	access:public
chunked	include/event2/http_struct.h	/^	unsigned chunked:1,		\/* a chunked request *\/$/;"	m	struct:evhttp_request	access:public
class	evdns.c	/^	u16 class; \/* The RR class (usually CLASS_INET) *\/$/;"	m	struct:server_reply_item	file:	access:public
cleanup_fn	test/tinytest.h	/^	int (*cleanup_fn)(const struct testcase_t *, void *);$/;"	m	struct:testcase_setup_t	access:public
cleanup_passthrough	test/regress_buffer.c	/^cleanup_passthrough(const struct testcase_t *testcase, void *ptr)$/;"	f	file:	signature:(const struct testcase_t *testcase, void *ptr)
cleanup_test	test/regress.c	309;"	d	file:
cleanupfn	evbuffer-internal.h	/^	evbuffer_ref_cleanup_cb cleanupfn;$/;"	m	struct:evbuffer_chain_reference	access:public
clear_rbow	bufferevent_openssl.c	/^clear_rbow(struct bufferevent_openssl *bev_ssl)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl)
clear_time_cache	event.c	/^clear_time_cache(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
clear_wbor	bufferevent_openssl.c	/^clear_wbor(struct bufferevent_openssl *bev_ssl)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl)
client_error_phrases	http.c	/^static const char *client_error_phrases[] = {$/;"	v	file:
client_state	test/test-ratelim.c	/^struct client_state {$/;"	s	file:
client_state::queued	test/test-ratelim.c	/^	size_t queued;$/;"	m	struct:client_state	file:	access:public
client_state::received	test/test-ratelim.c	/^	ev_uint64_t received;$/;"	m	struct:client_state	file:	access:public
close	buffer.c	2928;"	d	file:
close	evutil.c	85;"	d	file:
close	sample/http-server.c	54;"	d	file:
close_detect_cb	test/regress_http.c	/^close_detect_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
close_detect_done	test/regress_http.c	/^close_detect_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
close_detect_launch	test/regress_http.c	/^close_detect_launch(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
close_on_finished_writecb	sample/le-proxy.c	/^close_on_finished_writecb(struct bufferevent *bev, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, void *ctx)
close_socket_cb	test/regress_bufferevent.c	/^close_socket_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
closecb	http-internal.h	/^	void (*closecb)(struct evhttp_connection *, void *);$/;"	m	struct:evhttp_connection	access:public
closecb_arg	http-internal.h	/^	void *closecb_arg;$/;"	m	struct:evhttp_connection	access:public
closing	evdns.c	/^	char closing; \/* Are we trying to close this port, pending writes? *\/$/;"	m	struct:evdns_server_port	file:	access:public
cname_result	evdns.c	/^	char *cname_result;$/;"	m	struct:evdns_getaddrinfo_request	file:	access:public
cnt_free	test/regress_dns.c	/^cnt_free(void *ptr)$/;"	f	file:	signature:(void *ptr)
cnt_malloc	test/regress_dns.c	/^cnt_malloc(size_t sz)$/;"	f	file:	signature:(size_t sz)
cnt_realloc	test/regress_dns.c	/^cnt_realloc(void *old, size_t sz)$/;"	f	file:	signature:(void *old, size_t sz)
code	evutil.c	/^static struct { int code; const char *msg; } windows_socket_errors[] = {$/;"	m	struct:__anon14	file:	access:public
combined_read_cb	test/regress.c	/^combined_read_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
combined_write_cb	test/regress.c	/^combined_write_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
commandname	test/tinytest.c	/^static char commandname[MAX_PATH+1];$/;"	v	file:
common	evrpc-internal.h	/^	struct _evrpc_hooks common;$/;"	m	struct:evrpc_base	typeref:struct:evrpc_base::_evrpc_hooks	access:public
common	evrpc-internal.h	/^	struct _evrpc_hooks common;$/;"	m	struct:evrpc_pool	typeref:struct:evrpc_pool::_evrpc_hooks	access:public
common_timeout_callback	event.c	/^common_timeout_callback(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
common_timeout_cb	test/regress.c	/^common_timeout_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
common_timeout_info	test/regress.c	/^struct common_timeout_info {$/;"	s	file:
common_timeout_info::called_at	test/regress.c	/^	struct timeval called_at;$/;"	m	struct:common_timeout_info	typeref:struct:common_timeout_info::timeval	file:	access:public
common_timeout_info::count	test/regress.c	/^	int count;$/;"	m	struct:common_timeout_info	file:	access:public
common_timeout_info::ev	test/regress.c	/^	struct event ev;$/;"	m	struct:common_timeout_info	typeref:struct:common_timeout_info::event	file:	access:public
common_timeout_info::which	test/regress.c	/^	int which;$/;"	m	struct:common_timeout_info	file:	access:public
common_timeout_list	event-internal.h	/^struct common_timeout_list {$/;"	s
common_timeout_list::base	event-internal.h	/^	struct event_base *base;$/;"	m	struct:common_timeout_list	typeref:struct:common_timeout_list::event_base	access:public
common_timeout_list::duration	event-internal.h	/^	struct timeval duration;$/;"	m	struct:common_timeout_list	typeref:struct:common_timeout_list::timeval	access:public
common_timeout_list::events	event-internal.h	/^	struct event_list events;$/;"	m	struct:common_timeout_list	typeref:struct:common_timeout_list::event_list	access:public
common_timeout_list::timeout_event	event-internal.h	/^	struct event timeout_event;$/;"	m	struct:common_timeout_list	typeref:struct:common_timeout_list::event	access:public
common_timeout_queues	event-internal.h	/^	struct common_timeout_list **common_timeout_queues;$/;"	m	struct:event_base	typeref:struct:event_base::common_timeout_list	access:public
common_timeout_schedule	event.c	/^common_timeout_schedule(struct common_timeout_list *ctl,$/;"	f	file:	signature:(struct common_timeout_list *ctl, const struct timeval *now, struct event *head)
cond	test/regress_thread.c	/^	struct cond_wait *cond;$/;"	m	struct:alerted_record	typeref:struct:alerted_record::cond_wait	file:	access:public
cond	test/regress_thread.c	/^	void *cond;$/;"	m	struct:cond_wait	file:	access:public
cond_wait	test/regress_thread.c	/^struct cond_wait {$/;"	s	file:
cond_wait::cond	test/regress_thread.c	/^	void *cond;$/;"	m	struct:cond_wait	file:	access:public
cond_wait::lock	test/regress_thread.c	/^	void *lock;$/;"	m	struct:cond_wait	file:	access:public
condition_api_version	include/event2/thread.h	/^	int condition_api_version;$/;"	m	struct:evthread_condition_callbacks	access:public
config_nameserver_from_reg_key	evdns.c	/^config_nameserver_from_reg_key(struct evdns_base *base, HKEY key, const TCHAR *subkey)$/;"	f	file:	signature:(struct evdns_base *base, HKEY key, const TCHAR *subkey)
configured_min_share	bufferevent-internal.h	/^	ev_ssize_t configured_min_share;$/;"	m	struct:bufferevent_rate_limit_group	access:public
conn_bucket_cfg	test/test-ratelim.c	/^static struct ev_token_bucket_cfg *conn_bucket_cfg = NULL;$/;"	v	typeref:struct:ev_token_bucket_cfg	file:
conn_closed	bufferevent_openssl.c	/^conn_closed(struct bufferevent_openssl *bev_ssl, int errcode, int ret)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl, int errcode, int ret)
conn_eventcb	sample/hello-world.c	/^conn_eventcb(struct bufferevent *bev, short events, void *user_data)$/;"	f	file:	signature:(struct bufferevent *bev, short events, void *user_data)
conn_eventcb	sample/hello-world.c	/^static void conn_eventcb(struct bufferevent *, short, void *);$/;"	p	file:	signature:(struct bufferevent *, short, void *)
conn_writecb	sample/hello-world.c	/^conn_writecb(struct bufferevent *bev, void *user_data)$/;"	f	file:	signature:(struct bufferevent *bev, void *user_data)
conn_writecb	sample/hello-world.c	/^static void conn_writecb(struct bufferevent *, void *);$/;"	p	file:	signature:(struct bufferevent *, void *)
connect_complete	bufferevent_async.c	/^connect_complete(struct event_overlapped *eo, ev_uintptr_t key,$/;"	f	file:	signature:(struct event_overlapped *eo, ev_uintptr_t key, ev_ssize_t nbytes, int ok)
connect_overlapped	bufferevent_async.c	/^	struct event_overlapped connect_overlapped;$/;"	m	struct:bufferevent_async	typeref:struct:bufferevent_async::event_overlapped	file:	access:public
connect_to_addr	sample/le-proxy.c	/^static struct sockaddr_storage connect_to_addr;$/;"	v	typeref:struct:sockaddr_storage	file:
connect_to_addrlen	sample/le-proxy.c	/^static int connect_to_addrlen;$/;"	v	file:
connecting	bufferevent-internal.h	/^	unsigned connecting : 1;$/;"	m	struct:bufferevent_private	access:public
connection_refused	bufferevent-internal.h	/^	unsigned connection_refused : 1;$/;"	m	struct:bufferevent_private	access:public
connections	evrpc-internal.h	/^	struct evconq connections;$/;"	m	struct:evrpc_pool	typeref:struct:evrpc_pool::evconq	access:public
connections	http-internal.h	/^	struct evconq connections;$/;"	m	struct:evhttp	typeref:struct:evhttp::evconq	access:public
consider_reading	bufferevent_openssl.c	/^consider_reading(struct bufferevent_openssl *bev_ssl)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl)
consider_writing	bufferevent_openssl.c	/^consider_writing(struct bufferevent_openssl *bev_ssl)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl)
content	test/bench_http.c	/^static char *content;$/;"	v	file:
content_len	test/bench_http.c	/^static size_t content_len = 0;$/;"	v	file:
content_type	sample/http-server.c	/^	const char *content_type;$/;"	m	struct:table_entry	file:	access:public
content_type_table	sample/http-server.c	/^} content_type_table[] = {$/;"	v	typeref:struct:table_entry	file:
context	bufferevent_filter.c	/^	void *context;$/;"	m	struct:bufferevent_filtered	file:	access:public
count	evthread.c	/^	int count;$/;"	m	struct:debug_lock	file:	access:public
count	test/bench.c	/^static int count, writes, fired;$/;"	v	file:
count	test/regress.c	/^	int count;$/;"	m	struct:common_timeout_info	file:	access:public
count	test/regress.c	/^	int count;$/;"	m	struct:test_pri_event	file:	access:public
count	test/regress_dns.c	/^	int count;$/;"	m	struct:generic_dns_callback_result	file:	access:public
count	test/regress_iocp.c	/^static int count = 0;$/;"	v	file:
count	test/regress_thread.c	/^static int count;$/;"	v	file:
count_cond	test/regress_iocp.c	/^static void *count_lock = NULL, *count_cond = NULL;$/;"	v	file:
count_free	test/regress_iocp.c	/^count_free(void)$/;"	f	file:	signature:(void)
count_incr	test/regress_iocp.c	/^count_incr(void)$/;"	f	file:	signature:(void)
count_init	test/regress_iocp.c	/^count_init(void)$/;"	f	file:	signature:(void)
count_lock	test/regress_iocp.c	/^static void *count_lock = NULL, *count_cond = NULL;$/;"	v	file:
count_lock	test/regress_thread.c	/^void *count_lock;$/;"	v
count_wait_for	test/regress_iocp.c	/^count_wait_for(int i, int ms)$/;"	f	file:	signature:(int i, int ms)
counts	bufferevent_openssl.c	/^	struct bio_data_counts counts;$/;"	m	struct:bufferevent_openssl	typeref:struct:bufferevent_openssl::bio_data_counts	file:	access:public
cppcomment	event_rpcgen.py	/^cppcomment = re.compile(r'\\\/\\\/.*$')$/;"	v
cppdirect	event_rpcgen.py	/^cppdirect = []$/;"	v
cpu_usage_timer	test/test-changelist.c	/^struct cpu_usage_timer {$/;"	s	file:
cpu_usage_timer::kerneltimeBegin	test/test-changelist.c	/^	FILETIME kerneltimeBegin;$/;"	m	struct:cpu_usage_timer	file:	access:public
cpu_usage_timer::thread	test/test-changelist.c	/^	HANDLE thread;$/;"	m	struct:cpu_usage_timer	file:	access:public
cpu_usage_timer::timeBegin	test/test-changelist.c	/^	struct timeval timeBegin;$/;"	m	struct:cpu_usage_timer	typeref:struct:cpu_usage_timer::timeval	file:	access:public
cpu_usage_timer::usertimeBegin	test/test-changelist.c	/^	FILETIME usertimeBegin;$/;"	m	struct:cpu_usage_timer	file:	access:public
ctrl	bufferevent-internal.h	/^	int (*ctrl)(struct bufferevent *, enum bufferevent_ctrl_op, union bufferevent_ctrl_data *);$/;"	m	struct:bufferevent_ops	access:public
ctx	evrpc-internal.h	/^	void *ctx;$/;"	m	struct:evrpc_hook_ctx	access:public
ctx	test/regress_rpc.c	/^	void *ctx;$/;"	m	struct:_rpc_hook_ctx	file:	access:public
cur_test_name	test/tinytest.c	/^const char *cur_test_name = NULL;$/;"	v
cur_test_outcome	test/tinytest.c	/^static enum outcome cur_test_outcome = 0;$/;"	v	typeref:enum:outcome	file:
cur_test_prefix	test/tinytest.c	/^const char *cur_test_prefix = NULL; \/**< prefix of the current test group *\/$/;"	v
current_base	evdns.c	/^static struct evdns_base *current_base = NULL;$/;"	v	typeref:struct:evdns_base	file:
current_base	event.c	122;"	d	file:
current_base	test/regress.c	817;"	d	file:
current_event	event-internal.h	/^	struct event *current_event;$/;"	m	struct:event_base	typeref:struct:event_base::event	access:public
current_event_cond	event-internal.h	/^	void *current_event_cond;$/;"	m	struct:event_base	access:public
current_event_waiters	event-internal.h	/^	int current_event_waiters;$/;"	m	struct:event_base	access:public
current_req	evdns.c	/^	struct request *current_req;$/;"	m	struct:evdns_request	typeref:struct:evdns_request::request	file:	access:public
current_req	test/regress_dns.c	/^static struct evdns_request *current_req = NULL;$/;"	v	typeref:struct:evdns_request	file:
data	evdns.c	/^	void *data; \/* The contents of the RR *\/$/;"	m	struct:server_reply_item	file:	access:public
data	evdns.c	/^	} data;$/;"	m	struct:reply	typeref:union:reply::__anon8	file:	access:public
data	evrpc-internal.h	/^	void *data;$/;"	m	struct:evrpc_meta	access:public
data_size	evrpc-internal.h	/^	size_t data_size;$/;"	m	struct:evrpc_meta	access:public
datadir	Makefile	/^datadir = ${datarootdir}$/;"	m
datadir	include/Makefile	/^datadir = ${datarootdir}$/;"	m
datadir	sample/Makefile	/^datadir = ${datarootdir}$/;"	m
datadir	test/Makefile	/^datadir = ${datarootdir}$/;"	m
datalen	evdns.c	/^	u16 datalen; \/* Length of data; -1 if data is a label *\/$/;"	m	struct:server_reply_item	file:	access:public
datarootdir	Makefile	/^datarootdir = ${prefix}\/share$/;"	m
datarootdir	include/Makefile	/^datarootdir = ${prefix}\/share$/;"	m
datarootdir	sample/Makefile	/^datarootdir = ${prefix}\/share$/;"	m
datarootdir	test/Makefile	/^datarootdir = ${prefix}\/share$/;"	m
dealloc	event-internal.h	/^	void (*dealloc)(struct event_base *);$/;"	m	struct:eventop	access:public
debug_cond_wait	evthread.c	/^debug_cond_wait(void *_cond, void *_lock, const struct timeval *tv)$/;"	f	file:	signature:(void *_cond, void *_lock, const struct timeval *tv)
debug_lock	evthread.c	/^struct debug_lock {$/;"	s	file:
debug_lock::count	evthread.c	/^	int count;$/;"	m	struct:debug_lock	file:	access:public
debug_lock::held_by	evthread.c	/^	unsigned long held_by;$/;"	m	struct:debug_lock	file:	access:public
debug_lock::lock	evthread.c	/^	void *lock;$/;"	m	struct:debug_lock	file:	access:public
debug_lock::locktype	evthread.c	/^	unsigned locktype;$/;"	m	struct:debug_lock	file:	access:public
debug_lock_alloc	evthread.c	/^debug_lock_alloc(unsigned locktype)$/;"	f	file:	signature:(unsigned locktype)
debug_lock_free	evthread.c	/^debug_lock_free(void *lock_, unsigned locktype)$/;"	f	file:	signature:(void *lock_, unsigned locktype)
debug_lock_lock	evthread.c	/^debug_lock_lock(unsigned mode, void *lock_)$/;"	f	file:	signature:(unsigned mode, void *lock_)
debug_lock_unlock	evthread.c	/^debug_lock_unlock(unsigned mode, void *lock_)$/;"	f	file:	signature:(unsigned mode, void *lock_)
debug_ntoa	sample/dns-example.c	/^debug_ntoa(u32 address)$/;"	f	file:	signature:(u32 address)
decode_int64_internal	event_tagging.c	/^decode_int64_internal(ev_uint64_t *pnumber, struct evbuffer *evbuf, int offset)$/;"	f	file:	signature:(ev_uint64_t *pnumber, struct evbuffer *evbuf, int offset)
decode_int_internal	event_tagging.c	/^decode_int_internal(ev_uint32_t *pnumber, struct evbuffer *evbuf, int offset)$/;"	f	file:	signature:(ev_uint32_t *pnumber, struct evbuffer *evbuf, int offset)
decode_tag_internal	event_tagging.c	/^decode_tag_internal(ev_uint32_t *ptag, struct evbuffer *evbuf, int dodrain)$/;"	f	file:	signature:(ev_uint32_t *ptag, struct evbuffer *evbuf, int dodrain)
decref_and_unlock	bufferevent_pair.c	/^decref_and_unlock(struct bufferevent *b)$/;"	f	file:	signature:(struct bufferevent *b)
decrement_buckets	bufferevent_openssl.c	/^decrement_buckets(struct bufferevent_openssl *bev_ssl)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl)
default_evdns_log_fn	evdns.c	/^default_evdns_log_fn(int warning, const char *buf)$/;"	f	file:	signature:(int warning, const char *buf)
default_max_body_size	http-internal.h	/^	ev_uint64_t default_max_body_size;$/;"	m	struct:evhttp	access:public
default_max_headers_size	http-internal.h	/^	size_t default_max_headers_size;$/;"	m	struct:evhttp	access:public
defer_queue	event-internal.h	/^	struct deferred_cb_queue defer_queue;$/;"	m	struct:event_base	typeref:struct:event_base::deferred_cb_queue	access:public
deferred	bufferevent-internal.h	/^	struct deferred_cb deferred;$/;"	m	struct:bufferevent_private	typeref:struct:bufferevent_private::deferred_cb	access:public
deferred	evbuffer-internal.h	/^	struct deferred_cb deferred;$/;"	m	struct:evbuffer	typeref:struct:evbuffer::deferred_cb	access:public
deferred	evdns.c	/^	struct deferred_cb deferred;$/;"	m	struct:deferred_reply_callback	typeref:struct:deferred_reply_callback::deferred_cb	file:	access:public
deferred	listener.c	/^	struct deferred_cb deferred;$/;"	m	struct:accepting_socket	typeref:struct:accepting_socket::deferred_cb	file:	access:public
deferred_callback	test/regress_thread.c	/^deferred_callback(struct deferred_cb *cb, void *arg)$/;"	f	file:	signature:(struct deferred_cb *cb, void *arg)
deferred_cb	defer-internal.h	/^struct deferred_cb {$/;"	s
deferred_cb::arg	defer-internal.h	/^	void *arg;$/;"	m	struct:deferred_cb	access:public
deferred_cb::cb	defer-internal.h	/^	deferred_cb_fn cb;$/;"	m	struct:deferred_cb	access:public
deferred_cb::cb_next	defer-internal.h	/^	TAILQ_ENTRY (deferred_cb) cb_next;$/;"	m	struct:deferred_cb	access:public
deferred_cb::queued	defer-internal.h	/^	unsigned queued : 1;$/;"	m	struct:deferred_cb	access:public
deferred_cb_fn	defer-internal.h	/^typedef void (*deferred_cb_fn)(struct deferred_cb *, void *);$/;"	t
deferred_cb_list	defer-internal.h	/^	TAILQ_HEAD (deferred_cb_list, deferred_cb) deferred_cb_list;$/;"	m	struct:deferred_cb_queue	access:public
deferred_cb_queue	defer-internal.h	/^struct deferred_cb_queue {$/;"	s
deferred_cb_queue::active_count	defer-internal.h	/^	int active_count;$/;"	m	struct:deferred_cb_queue	access:public
deferred_cb_queue::deferred_cb_list	defer-internal.h	/^	TAILQ_HEAD (deferred_cb_list, deferred_cb) deferred_cb_list;$/;"	m	struct:deferred_cb_queue	access:public
deferred_cb_queue::lock	defer-internal.h	/^	void *lock;$/;"	m	struct:deferred_cb_queue	access:public
deferred_cb_queue::notify_arg	defer-internal.h	/^	void *notify_arg;$/;"	m	struct:deferred_cb_queue	access:public
deferred_cb_queue::notify_fn	defer-internal.h	/^	void (*notify_fn)(struct deferred_cb_queue *, void *);$/;"	m	struct:deferred_cb_queue	access:public
deferred_cbs	evbuffer-internal.h	/^	unsigned deferred_cbs : 1;$/;"	m	struct:evbuffer	access:public
deferred_data	test/regress_thread.c	/^static struct deferred_test_data deferred_data[QUEUE_THREAD_COUNT];$/;"	v	typeref:struct:deferred_test_data	file:
deferred_reply_callback	evdns.c	/^struct deferred_reply_callback {$/;"	s	file:
deferred_reply_callback::deferred	evdns.c	/^	struct deferred_cb deferred;$/;"	m	struct:deferred_reply_callback	typeref:struct:deferred_reply_callback::deferred_cb	file:	access:public
deferred_reply_callback::err	evdns.c	/^	u32 err;$/;"	m	struct:deferred_reply_callback	file:	access:public
deferred_reply_callback::handle	evdns.c	/^	struct evdns_request *handle;$/;"	m	struct:deferred_reply_callback	typeref:struct:deferred_reply_callback::evdns_request	file:	access:public
deferred_reply_callback::have_reply	evdns.c	/^	u8 have_reply;$/;"	m	struct:deferred_reply_callback	file:	access:public
deferred_reply_callback::reply	evdns.c	/^	struct reply reply;$/;"	m	struct:deferred_reply_callback	typeref:struct:deferred_reply_callback::reply	file:	access:public
deferred_reply_callback::request_type	evdns.c	/^	u8 request_type;$/;"	m	struct:deferred_reply_callback	file:	access:public
deferred_reply_callback::ttl	evdns.c	/^	u32 ttl;$/;"	m	struct:deferred_reply_callback	file:	access:public
deferred_reply_callback::user_callback	evdns.c	/^	evdns_callback_type user_callback;$/;"	m	struct:deferred_reply_callback	file:	access:public
deferred_test_data	test/regress_thread.c	/^struct deferred_test_data {$/;"	s	file:
deferred_test_data::cbs	test/regress_thread.c	/^	struct deferred_cb cbs[CB_COUNT];$/;"	m	struct:deferred_test_data	typeref:struct:deferred_test_data::deferred_cb	file:	access:public
deferred_test_data::queue	test/regress_thread.c	/^	struct deferred_cb_queue *queue;$/;"	m	struct:deferred_test_data	typeref:struct:deferred_test_data::deferred_cb_queue	file:	access:public
del	event-internal.h	/^	int (*del)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);$/;"	m	struct:eventop	access:public
delay	test/regress_thread.c	/^	struct timeval delay;$/;"	m	struct:alerted_record	typeref:struct:alerted_record::timeval	file:	access:public
delayed_client	test/regress_http.c	/^static struct evhttp_connection *delayed_client;$/;"	v	typeref:struct:evhttp_connection	file:
depcomp	Makefile	/^depcomp = $(SHELL) $(top_srcdir)\/depcomp$/;"	m
depcomp	sample/Makefile	/^depcomp =$/;"	m
depcomp	test/Makefile	/^depcomp = $(SHELL) $(top_srcdir)\/depcomp$/;"	m
destroy	listener.c	/^	void (*destroy)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	file:	access:public
destruct	bufferevent-internal.h	/^	void (*destruct)(struct bufferevent *);$/;"	m	struct:bufferevent_ops	access:public
detect_monotonic	event.c	/^detect_monotonic(void)$/;"	f	file:	signature:(void)
devpoll_add	devpoll.c	/^devpoll_add(struct event_base *base, int fd, short old, short events, void *p)$/;"	f	file:	signature:(struct event_base *base, int fd, short old, short events, void *p)
devpoll_add	devpoll.c	/^static int devpoll_add(struct event_base *, int fd, short old, short events, void *);$/;"	p	file:	signature:(struct event_base *, int fd, short old, short events, void *)
devpoll_commit	devpoll.c	/^devpoll_commit(struct devpollop *devpollop)$/;"	f	file:	signature:(struct devpollop *devpollop)
devpoll_dealloc	devpoll.c	/^devpoll_dealloc(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
devpoll_dealloc	devpoll.c	/^static void devpoll_dealloc(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
devpoll_del	devpoll.c	/^devpoll_del(struct event_base *base, int fd, short old, short events, void *p)$/;"	f	file:	signature:(struct event_base *base, int fd, short old, short events, void *p)
devpoll_del	devpoll.c	/^static int devpoll_del(struct event_base *, int fd, short old, short events, void *);$/;"	p	file:	signature:(struct event_base *, int fd, short old, short events, void *)
devpoll_dispatch	devpoll.c	/^devpoll_dispatch(struct event_base *base, struct timeval *tv)$/;"	f	file:	signature:(struct event_base *base, struct timeval *tv)
devpoll_dispatch	devpoll.c	/^static int devpoll_dispatch(struct event_base *, struct timeval *);$/;"	p	file:	signature:(struct event_base *, struct timeval *)
devpoll_init	devpoll.c	/^devpoll_init(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
devpoll_init	devpoll.c	/^static void *devpoll_init(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
devpoll_queue	devpoll.c	/^devpoll_queue(struct devpollop *devpollop, int fd, int events) {$/;"	f	file:	signature:(struct devpollop *devpollop, int fd, int events)
devpollop	devpoll.c	/^struct devpollop {$/;"	s	file:
devpollop::changes	devpoll.c	/^	struct pollfd *changes;$/;"	m	struct:devpollop	typeref:struct:devpollop::pollfd	file:	access:public
devpollop::dpfd	devpoll.c	/^	int dpfd;$/;"	m	struct:devpollop	file:	access:public
devpollop::events	devpoll.c	/^	struct pollfd *events;$/;"	m	struct:devpollop	typeref:struct:devpollop::pollfd	file:	access:public
devpollop::nchanges	devpoll.c	/^	int nchanges;$/;"	m	struct:devpollop	file:	access:public
devpollop::nevents	devpoll.c	/^	int nevents;$/;"	m	struct:devpollop	file:	access:public
devpollops	devpoll.c	/^const struct eventop devpollops = {$/;"	v	typeref:struct:eventop
dfd_cb	test/regress.c	/^dfd_cb(evutil_socket_t fd, short e, void *data)$/;"	f	file:	signature:(evutil_socket_t fd, short e, void *data)
disable	bufferevent-internal.h	/^	int (*disable)(struct bufferevent *, short);$/;"	m	struct:bufferevent_ops	access:public
disable	listener.c	/^	int (*disable)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	file:	access:public
disable_tls_11_and_12	test/regress_ssl.c	/^static int disable_tls_11_and_12 = 0;$/;"	v	file:
discard_readcb	test/test-ratelim.c	/^discard_readcb(struct bufferevent *bev, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, void *ctx)
dispatch	event-internal.h	/^	int (*dispatch)(struct event_base *, struct timeval *);$/;"	m	struct:eventop	access:public
dist_bin_SCRIPTS	Makefile	/^dist_bin_SCRIPTS = event_rpcgen.py$/;"	m
distcleancheck_listfiles	Makefile	/^distcleancheck_listfiles = find . -type f -print$/;"	m
distdir	Makefile	/^distdir = $(PACKAGE)-$(VERSION)$/;"	m
distuninstallcheck_listfiles	Makefile	/^distuninstallcheck_listfiles = find . -type f -print$/;"	m
dns_base	http-internal.h	/^	struct evdns_base *dns_base;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::evdns_base	access:public
dns_base	test/regress_dns.c	/^	struct evdns_base *dns_base;$/;"	m	struct:gaic_request_status	typeref:struct:gaic_request_status::evdns_base	file:	access:public
dns_base	test/regress_dns.c	/^	struct evdns_base *dns_base;$/;"	m	struct:testleak_env_t	typeref:struct:testleak_env_t::evdns_base	file:	access:public
dns_err	test/regress_dns.c	/^static int dns_err = 0;$/;"	v	file:
dns_error	bufferevent-internal.h	/^	int dns_error;$/;"	m	struct:bufferevent_private	access:public
dns_example_DEPENDENCIES	sample/Makefile	/^dns_example_DEPENDENCIES = $(am__DEPENDENCIES_1) ..\/libevent.la$/;"	m
dns_example_LDADD	sample/Makefile	/^dns_example_LDADD = $(LDADD)$/;"	m
dns_example_OBJECTS	sample/Makefile	/^dns_example_OBJECTS = $(am_dns_example_OBJECTS)$/;"	m
dns_example_SOURCES	sample/Makefile	/^dns_example_SOURCES = dns-example.c$/;"	m
dns_gethostbyaddr	test/regress_dns.c	/^dns_gethostbyaddr(void)$/;"	f	file:	signature:(void)
dns_gethostbyname	test/regress_dns.c	/^dns_gethostbyname(void)$/;"	f	file:	signature:(void)
dns_gethostbyname6	test/regress_dns.c	/^dns_gethostbyname6(void)$/;"	f	file:	signature:(void)
dns_gethostbyname_cb	test/regress_dns.c	/^dns_gethostbyname_cb(int result, char type, int count, int ttl,$/;"	f	file:	signature:(int result, char type, int count, int ttl, void *addresses, void *arg)
dns_got_cancel	test/regress_dns.c	/^static int dns_got_cancel = 0;$/;"	v	file:
dns_inflight_test	test/regress_dns.c	/^dns_inflight_test(void *arg)$/;"	f	file:	signature:(void *arg)
dns_ok	test/regress_dns.c	/^static int dns_ok = 0;$/;"	v	file:
dns_port	test/regress_testutils.c	/^static struct evdns_server_port *dns_port;$/;"	v	typeref:struct:evdns_server_port	file:
dns_question_class	include/event2/dns_struct.h	/^	int dns_question_class;$/;"	m	struct:evdns_server_question	access:public
dns_question_class	include/event2/dns_struct.h	70;"	d
dns_reissue_test	test/regress_dns.c	/^dns_reissue_test(void *arg)$/;"	f	file:	signature:(void *arg)
dns_resolve_reverse	test/regress_dns.c	/^dns_resolve_reverse(void *ptr)$/;"	f	file:	signature:(void *ptr)
dns_retry_test	test/regress_dns.c	/^dns_retry_test(void *arg)$/;"	f	file:	signature:(void *arg)
dns_search_cancel_test	test/regress_dns.c	/^dns_search_cancel_test(void *arg)$/;"	f	file:	signature:(void *arg)
dns_search_test	test/regress_dns.c	/^dns_search_test(void *arg)$/;"	f	file:	signature:(void *arg)
dns_server	test/regress_dns.c	/^dns_server(void)$/;"	f	file:	signature:(void)
dns_server_gethostbyname_cb	test/regress_dns.c	/^dns_server_gethostbyname_cb(int result, char type, int count, int ttl,$/;"	f	file:	signature:(int result, char type, int count, int ttl, void *addresses, void *arg)
dns_server_request_cb	test/regress_dns.c	/^dns_server_request_cb(struct evdns_server_request *req, void *data)$/;"	f	file:	signature:(struct evdns_server_request *req, void *data)
dns_sock	test/regress_testutils.c	/^evutil_socket_t dns_sock = -1;$/;"	v
dns_testcases	test/regress_dns.c	/^struct testcase_t dns_testcases[] = {$/;"	v	typeref:struct:testcase_t
dnserr	test/regress_dns.c	/^	int dnserr;$/;"	m	struct:be_conn_hostname_result	file:	access:public
dnslabel_clear	evdns.c	/^dnslabel_clear(struct dnslabel_table *table)$/;"	f	file:	signature:(struct dnslabel_table *table)
dnslabel_entry	evdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	s	file:
dnslabel_entry::pos	evdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	m	struct:dnslabel_entry	file:	access:public
dnslabel_entry::v	evdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	m	struct:dnslabel_entry	file:	access:public
dnslabel_table	evdns.c	/^struct dnslabel_table {$/;"	s	file:
dnslabel_table::labels	evdns.c	/^	struct dnslabel_entry labels[MAX_LABELS];$/;"	m	struct:dnslabel_table	typeref:struct:dnslabel_table::dnslabel_entry	file:	access:public
dnslabel_table::n_labels	evdns.c	/^	int n_labels; \/* number of current entries *\/$/;"	m	struct:dnslabel_table	file:	access:public
dnslabel_table_add	evdns.c	/^dnslabel_table_add(struct dnslabel_table *table, const char *label, off_t pos)$/;"	f	file:	signature:(struct dnslabel_table *table, const char *label, off_t pos)
dnslabel_table_get_pos	evdns.c	/^dnslabel_table_get_pos(const struct dnslabel_table *table, const char *label)$/;"	f	file:	signature:(const struct dnslabel_table *table, const char *label)
dnslabel_table_init	evdns.c	/^dnslabel_table_init(struct dnslabel_table *table)$/;"	f	file:	signature:(struct dnslabel_table *table)
dnslogcb	test/regress_main.c	/^static void dnslogcb(int w, const char *m)$/;"	f	file:	signature:(int w, const char *m)
dnsname_to_labels	evdns.c	/^dnsname_to_labels(u8 *const buf, size_t buf_len, off_t j,$/;"	f	file:	signature:(u8 *const buf, size_t buf_len, off_t j, const char *name, const size_t name_len, struct dnslabel_table *table)
do_fd_clear	win32select.c	/^do_fd_clear(struct event_base *base,$/;"	f	file:	signature:(struct event_base *base, struct win32op *op, struct idx_info *ent, int read)
do_fd_set	win32select.c	/^do_fd_set(struct win32op *op, struct idx_info *ent, evutil_socket_t s, int read)$/;"	f	file:	signature:(struct win32op *op, struct idx_info *ent, evutil_socket_t s, int read)
do_handshake	bufferevent_openssl.c	/^do_handshake(struct bufferevent_openssl *bev_ssl)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl)
do_read	bufferevent_openssl.c	/^do_read(struct bufferevent_openssl *bev_ssl, int n_to_read) {$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl, int n_to_read)
do_write	bufferevent_openssl.c	/^do_write(struct bufferevent_openssl *bev_ssl, int atmost)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl, int atmost)
docdir	Makefile	/^docdir = ${datarootdir}\/doc\/${PACKAGE}$/;"	m
docdir	include/Makefile	/^docdir = ${datarootdir}\/doc\/${PACKAGE}$/;"	m
docdir	sample/Makefile	/^docdir = ${datarootdir}\/doc\/${PACKAGE}$/;"	m
docdir	test/Makefile	/^docdir = ${datarootdir}\/doc\/${PACKAGE}$/;"	m
done_writing_cb	test/regress_ssl.c	/^done_writing_cb(struct bufferevent *bev, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, void *ctx)
downcast	bufferevent_filter.c	120;"	d	file:
downcast	bufferevent_pair.c	64;"	d	file:
dpfd	devpoll.c	/^	int dpfd;$/;"	m	struct:devpollop	file:	access:public
drained_writecb	sample/le-proxy.c	/^drained_writecb(struct bufferevent *bev, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, void *ctx)
drained_writecb	sample/le-proxy.c	/^static void drained_writecb(struct bufferevent *bev, void *ctx);$/;"	p	file:	signature:(struct bufferevent *bev, void *ctx)
dummy_cb	test/regress_iocp.c	/^dummy_cb(struct event_overlapped *o, uintptr_t key, ev_ssize_t n, int ok)$/;"	f	file:	signature:(struct event_overlapped *o, uintptr_t key, ev_ssize_t n, int ok)
dummy_free	test/regress.c	/^dummy_free(void *_mem)$/;"	f	file:	signature:(void *_mem)
dummy_malloc	test/regress.c	/^dummy_malloc(size_t len)$/;"	f	file:	signature:(size_t len)
dummy_overlapped	test/regress_iocp.c	/^struct dummy_overlapped {$/;"	s	file:
dummy_overlapped::call_count	test/regress_iocp.c	/^	int call_count;$/;"	m	struct:dummy_overlapped	file:	access:public
dummy_overlapped::eo	test/regress_iocp.c	/^	struct event_overlapped eo;$/;"	m	struct:dummy_overlapped	typeref:struct:dummy_overlapped::event_overlapped	file:	access:public
dummy_overlapped::keys	test/regress_iocp.c	/^	uintptr_t keys[MAX_CALLS];$/;"	m	struct:dummy_overlapped	file:	access:public
dummy_overlapped::lock	test/regress_iocp.c	/^	void *lock;$/;"	m	struct:dummy_overlapped	file:	access:public
dummy_overlapped::sizes	test/regress_iocp.c	/^	ev_ssize_t sizes[MAX_CALLS];$/;"	m	struct:dummy_overlapped	file:	access:public
dummy_read_cb	test/regress.c	/^dummy_read_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
dummy_realloc	test/regress.c	/^dummy_realloc(void *_mem, size_t len)$/;"	f	file:	signature:(void *_mem, size_t len)
dump_request_cb	sample/http-server.c	/^dump_request_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
duration	event-internal.h	/^	struct timeval duration;$/;"	m	struct:common_timeout_list	typeref:struct:common_timeout_list::timeval	access:public
dvidir	Makefile	/^dvidir = ${docdir}$/;"	m
dvidir	include/Makefile	/^dvidir = ${docdir}$/;"	m
dvidir	sample/Makefile	/^dvidir = ${docdir}$/;"	m
dvidir	test/Makefile	/^dvidir = ${docdir}$/;"	m
eb	test/regress.c	/^	struct event_base *eb;$/;"	m	struct:basic_cb_args	typeref:struct:basic_cb_args::event_base	file:	access:public
echo_eventcb	test/test-ratelim.c	/^echo_eventcb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *ctx)
echo_listenercb	test/test-ratelim.c	/^echo_listenercb(struct evconnlistener *listener, evutil_socket_t newsock,$/;"	f	file:	signature:(struct evconnlistener *listener, evutil_socket_t newsock, struct sockaddr *sourceaddr, int socklen, void *ctx)
echo_readcb	test/test-ratelim.c	/^echo_readcb(struct bufferevent *bev, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, void *ctx)
echo_writecb	test/test-ratelim.c	/^echo_writecb(struct bufferevent *bev, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, void *ctx)
ed_fds	evport.c	/^	struct fd_info *ed_fds;		\/* allocated fdi table		 *\/$/;"	m	struct:evport_data	typeref:struct:evport_data::fd_info	file:	access:public
ed_nevents	evport.c	/^	int		ed_nevents;	\/* number of allocated fdi's	 *\/$/;"	m	struct:evport_data	file:	access:public
ed_pending	evport.c	/^	int ed_pending[EVENTS_PER_GETN]; \/* fd's with pending events *\/$/;"	m	struct:evport_data	file:	access:public
ed_port	evport.c	/^	int		ed_port;	\/* event port for system events  *\/$/;"	m	struct:evport_data	file:	access:public
edgetriggered_testcases	test/regress_et.c	/^struct testcase_t edgetriggered_testcases[] = {$/;"	v	typeref:struct:testcase_t
enable	bufferevent-internal.h	/^	int (*enable)(struct bufferevent *, short);$/;"	m	struct:bufferevent_ops	access:public
enable	listener.c	/^	int (*enable)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	file:	access:public
enabled	include/event2/bufferevent_struct.h	/^	short enabled;$/;"	m	struct:bufferevent	access:public
enabled	listener.c	/^	unsigned enabled : 1;$/;"	m	struct:evconnlistener	file:	access:public
encode_int	include/event2/tag_compat.h	45;"	d
encode_int64	include/event2/tag_compat.h	46;"	d
encode_int64_internal	event_tagging.c	/^encode_int64_internal(ev_uint8_t *data, ev_uint64_t number)$/;"	f	file:	signature:(ev_uint8_t *data, ev_uint64_t number)
encode_int_internal	event_tagging.c	/^encode_int_internal(ev_uint8_t *data, ev_uint32_t number)$/;"	f	file:	signature:(ev_uint8_t *data, ev_uint32_t number)
end_of_authority	http.c	/^end_of_authority(char *cp)$/;"	f	file:	signature:(char *cp)
end_of_cpath	http.c	4502;"	d	file:
end_of_path	http.c	/^end_of_path(char *cp, enum uri_part part, unsigned flags)$/;"	f	file:	signature:(char *cp, enum uri_part part, unsigned flags)
ent	evmap.c	/^	} ent;$/;"	m	struct:event_map_entry	typeref:union:event_map_entry::__anon6	file:	access:public
entries	event-internal.h	/^	TAILQ_HEAD(event_configq, event_config_entry) entries;$/;"	m	struct:event_config	access:public
entries	event-internal.h	/^	void **entries;$/;"	m	struct:event_signal_map	access:public
entry_status	test/regress_util.c	/^enum entry_status { NORMAL, CANONICAL, BAD };$/;"	g	file:
eo	test/regress_iocp.c	/^	struct event_overlapped eo;$/;"	m	struct:dummy_overlapped	typeref:struct:dummy_overlapped::event_overlapped	file:	access:public
epfd	epoll.c	/^	int epfd;$/;"	m	struct:epollop	file:	access:public
epoll_apply_changes	epoll.c	/^epoll_apply_changes(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
epoll_apply_one_change	epoll.c	/^epoll_apply_one_change(struct event_base *base,$/;"	f	file:	signature:(struct event_base *base, struct epollop *epollop, const struct event_change *ch)
epoll_create	epoll_sub.c	/^epoll_create(int size)$/;"	f	signature:(int size)
epoll_ctl	epoll_sub.c	/^epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)$/;"	f	signature:(int epfd, int op, int fd, struct epoll_event *event)
epoll_dealloc	epoll.c	/^epoll_dealloc(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
epoll_dealloc	epoll.c	/^static void epoll_dealloc(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
epoll_dispatch	epoll.c	/^epoll_dispatch(struct event_base *base, struct timeval *tv)$/;"	f	file:	signature:(struct event_base *base, struct timeval *tv)
epoll_dispatch	epoll.c	/^static int epoll_dispatch(struct event_base *, struct timeval *);$/;"	p	file:	signature:(struct event_base *, struct timeval *)
epoll_init	epoll.c	/^epoll_init(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
epoll_init	epoll.c	/^static void *epoll_init(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
epoll_nochangelist_add	epoll.c	/^epoll_nochangelist_add(struct event_base *base, evutil_socket_t fd,$/;"	f	file:	signature:(struct event_base *base, evutil_socket_t fd, short old, short events, void *p)
epoll_nochangelist_add	epoll.c	/^static int epoll_nochangelist_add(struct event_base *base, evutil_socket_t fd,$/;"	p	file:	signature:(struct event_base *base, evutil_socket_t fd, short old, short events, void *p)
epoll_nochangelist_del	epoll.c	/^epoll_nochangelist_del(struct event_base *base, evutil_socket_t fd,$/;"	f	file:	signature:(struct event_base *base, evutil_socket_t fd, short old, short events, void *p)
epoll_nochangelist_del	epoll.c	/^static int epoll_nochangelist_del(struct event_base *base, evutil_socket_t fd,$/;"	p	file:	signature:(struct event_base *base, evutil_socket_t fd, short old, short events, void *p)
epoll_op_to_string	epoll.c	/^epoll_op_to_string(int op)$/;"	f	file:	signature:(int op)
epoll_wait	epoll_sub.c	/^epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)$/;"	f	signature:(int epfd, struct epoll_event *events, int maxevents, int timeout)
epollop	epoll.c	/^struct epollop {$/;"	s	file:
epollop::epfd	epoll.c	/^	int epfd;$/;"	m	struct:epollop	file:	access:public
epollop::events	epoll.c	/^	struct epoll_event *events;$/;"	m	struct:epollop	typeref:struct:epollop::epoll_event	file:	access:public
epollop::nevents	epoll.c	/^	int nevents;$/;"	m	struct:epollop	file:	access:public
epollops	epoll.c	/^const struct eventop epollops = {$/;"	v	typeref:struct:eventop
epollops_changelist	epoll.c	/^static const struct eventop epollops_changelist = {$/;"	v	typeref:struct:eventop	file:
eq_debug_entry	event.c	/^eq_debug_entry(const struct event_debug_entry *a,$/;"	f	file:	signature:(const struct event_debug_entry *a, const struct event_debug_entry *b)
eqsocket	evmap.c	/^eqsocket(struct event_map_entry *e1, struct event_map_entry *e2)$/;"	f	file:	signature:(struct event_map_entry *e1, struct event_map_entry *e2)
err	evdns.c	/^	u32 err;$/;"	m	struct:deferred_reply_callback	file:	access:public
err	test/regress_dns.c	/^	int err;$/;"	m	struct:gai_outcome	file:	access:public
err_fn	test/regress_util.c	/^err_fn(void)$/;"	f	file:	signature:(void)
errno_pending	bufferevent-internal.h	/^	int errno_pending;$/;"	m	struct:bufferevent_private	access:public
error	include/event2/rpc_struct.h	/^	int error;$/;"	m	struct:evrpc_status	access:public
error	listener.c	/^	int error;$/;"	m	struct:accepting_socket	file:	access:public
errorcb	include/event2/bufferevent_struct.h	/^	bufferevent_event_cb errorcb;$/;"	m	struct:bufferevent	access:public
errorcb	listener.c	/^	evconnlistener_errorcb errorcb;$/;"	m	struct:evconnlistener	file:	access:public
errorcb	test/bench_httpclient.c	/^errorcb(struct bufferevent *b, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *b, short what, void *arg)
errorcb	test/bench_httpclient.c	/^static void errorcb(struct bufferevent *b, short what, void *arg);$/;"	p	file:	signature:(struct bufferevent *b, short what, void *arg)
errorcb	test/regress_bufferevent.c	/^errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *arg)
errorcb	test/regress_listener.c	/^errorcb(struct evconnlistener *lis, void *data_)$/;"	f	file:	signature:(struct evconnlistener *lis, void *data_)
errorcb	test/regress_zlib.c	/^errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *arg)
errorcb_invoked	test/regress_zlib.c	/^static int errorcb_invoked;$/;"	v	file:
errors	bufferevent_openssl.c	/^	ev_uint32_t errors[NUM_ERRORS];$/;"	m	struct:bufferevent_openssl	file:	access:public
errx_fn	test/regress_util.c	/^errx_fn(void)$/;"	f	file:	signature:(void)
ev	event.c	/^	struct event ev;$/;"	m	struct:event_once	typeref:struct:event_once::event	file:	access:public
ev	test/regress.c	/^	struct event *ev;$/;"	m	struct:basic_cb_args	typeref:struct:basic_cb_args::event	file:	access:public
ev	test/regress.c	/^	struct event ev;$/;"	m	struct:both	typeref:struct:both::event	file:	access:public
ev	test/regress.c	/^	struct event ev;$/;"	m	struct:common_timeout_info	typeref:struct:common_timeout_info::event	file:	access:public
ev	test/regress.c	/^	struct event ev;$/;"	m	struct:test_pri_event	typeref:struct:test_pri_event::event	file:	access:public
ev	test/test-time.c	/^struct event *ev[NEVENT];$/;"	v	typeref:struct:event
ev_active_next	include/event2/event_struct.h	/^	TAILQ_ENTRY(event) ev_active_next;$/;"	m	struct:event	access:public
ev_arc4random_buf	evutil_rand.c	/^ev_arc4random_buf(void *buf, size_t n)$/;"	f	file:	signature:(void *buf, size_t n)
ev_arg	include/event2/event_struct.h	/^	void *ev_arg;$/;"	m	struct:event	access:public
ev_base	include/event2/bufferevent_struct.h	/^	struct event_base *ev_base;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_base	access:public
ev_base	include/event2/event_struct.h	/^	struct event_base *ev_base;$/;"	m	struct:event	typeref:struct:event::event_base	access:public
ev_callback	include/event2/event_struct.h	/^	void (*ev_callback)(evutil_socket_t, short, void *arg);$/;"	m	struct:event	access:public
ev_closure	include/event2/event_struct.h	/^	ev_uint8_t ev_closure;$/;"	m	struct:event	access:public
ev_events	include/event2/event_struct.h	/^	short ev_events;$/;"	m	struct:event	access:public
ev_fd	include/event2/event_struct.h	/^	evutil_socket_t ev_fd;$/;"	m	struct:event	access:public
ev_flags	include/event2/event_struct.h	/^	short ev_flags;$/;"	m	struct:event	access:public
ev_int16_t	include/event2/util.h	146;"	d
ev_int16_t	include/event2/util.h	149;"	d
ev_int16_t	include/event2/util.h	152;"	d
ev_int16_t	include/event2/util.h	155;"	d
ev_int16_t	include/event2/util.h	158;"	d
ev_int32_t	include/event2/util.h	127;"	d
ev_int32_t	include/event2/util.h	130;"	d
ev_int32_t	include/event2/util.h	133;"	d
ev_int32_t	include/event2/util.h	136;"	d
ev_int32_t	include/event2/util.h	139;"	d
ev_int64_t	include/event2/util.h	108;"	d
ev_int64_t	include/event2/util.h	111;"	d
ev_int64_t	include/event2/util.h	114;"	d
ev_int64_t	include/event2/util.h	117;"	d
ev_int64_t	include/event2/util.h	120;"	d
ev_int8_t	include/event2/util.h	165;"	d
ev_int8_t	include/event2/util.h	168;"	d
ev_int8_t	include/event2/util.h	171;"	d
ev_intptr_t	include/event2/util.h	176;"	d
ev_intptr_t	include/event2/util.h	179;"	d
ev_intptr_t	include/event2/util.h	182;"	d
ev_intptr_t	include/event2/util.h	185;"	d
ev_io	include/event2/event_struct.h	/^		} ev_io;$/;"	m	union:event::__anon3	typeref:struct:event::__anon3::__anon4	access:public
ev_io_next	event-internal.h	47;"	d
ev_io_next	include/event2/event_struct.h	/^			TAILQ_ENTRY(event) ev_io_next;$/;"	m	struct:event::__anon3::__anon4	access:public
ev_io_timeout	event-internal.h	48;"	d
ev_misalign_t	evbuffer-internal.h	/^typedef ev_off_t ev_misalign_t;$/;"	t
ev_misalign_t	evbuffer-internal.h	/^typedef ev_ssize_t ev_misalign_t;$/;"	t
ev_n_signals_added	evsignal-internal.h	/^	int ev_n_signals_added;$/;"	m	struct:evsig_info	access:public
ev_ncalls	event-internal.h	51;"	d
ev_ncalls	include/event2/event_struct.h	/^			short ev_ncalls;$/;"	m	struct:event::__anon3::__anon5	access:public
ev_next	include/event2/event_struct.h	/^	TAILQ_ENTRY(event) ev_next;$/;"	m	struct:event	access:public
ev_next_with_common_timeout	include/event2/event_struct.h	/^		TAILQ_ENTRY(event) ev_next_with_common_timeout;$/;"	m	union:event::__anon2	access:public
ev_off_t	include/event2/util.h	197;"	d
ev_off_t	include/event2/util.h	199;"	d
ev_pncalls	event-internal.h	52;"	d
ev_pncalls	include/event2/event_struct.h	/^			short *ev_pncalls;$/;"	m	struct:event::__anon3::__anon5	access:public
ev_pri	include/event2/event_struct.h	/^	ev_uint8_t ev_pri;	\/* smaller numbers are higher priority *\/$/;"	m	struct:event	access:public
ev_read	include/event2/bufferevent_struct.h	/^	struct event ev_read;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event	access:public
ev_res	include/event2/event_struct.h	/^	short ev_res;		\/* result passed to event callback *\/$/;"	m	struct:event	access:public
ev_sighandler_t	evsignal-internal.h	/^typedef void (*ev_sighandler_t)(int);$/;"	t
ev_signal	evsignal-internal.h	/^	struct event ev_signal;$/;"	m	struct:evsig_info	typeref:struct:evsig_info::event	access:public
ev_signal	include/event2/event_struct.h	/^		} ev_signal;$/;"	m	union:event::__anon3	typeref:struct:event::__anon3::__anon5	access:public
ev_signal_added	evsignal-internal.h	/^	int ev_signal_added;$/;"	m	struct:evsig_info	access:public
ev_signal_next	event-internal.h	46;"	d
ev_signal_next	include/event2/event_struct.h	/^			TAILQ_ENTRY(event) ev_signal_next;$/;"	m	struct:event::__anon3::__anon5	access:public
ev_signal_pair	evsignal-internal.h	/^	evutil_socket_t ev_signal_pair[2];$/;"	m	struct:evsig_info	access:public
ev_socklen_t	include/event2/util.h	254;"	d
ev_socklen_t	include/event2/util.h	256;"	d
ev_socklen_t	include/event2/util.h	258;"	d
ev_ssize_t	include/event2/util.h	191;"	d
ev_ssize_t	include/event2/util.h	193;"	d
ev_timeout	evrpc-internal.h	/^	struct event ev_timeout;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::event	access:public
ev_timeout	include/event2/event_struct.h	/^			struct timeval ev_timeout;$/;"	m	struct:event::__anon3::__anon4	typeref:struct:event::__anon3::__anon4::timeval	access:public
ev_timeout	include/event2/event_struct.h	/^	struct timeval ev_timeout;$/;"	m	struct:event	typeref:struct:event::timeval	access:public
ev_timeout_pos	include/event2/event_struct.h	/^	} ev_timeout_pos;$/;"	m	struct:event	typeref:union:event::__anon2	access:public
ev_token_bucket	ratelim-internal.h	/^struct ev_token_bucket {$/;"	s
ev_token_bucket::last_updated	ratelim-internal.h	/^	ev_uint32_t last_updated;$/;"	m	struct:ev_token_bucket	access:public
ev_token_bucket::read_limit	ratelim-internal.h	/^	ev_ssize_t read_limit, write_limit;$/;"	m	struct:ev_token_bucket	access:public
ev_token_bucket::write_limit	ratelim-internal.h	/^	ev_ssize_t read_limit, write_limit;$/;"	m	struct:ev_token_bucket	access:public
ev_token_bucket_cfg	ratelim-internal.h	/^struct ev_token_bucket_cfg {$/;"	s
ev_token_bucket_cfg::msec_per_tick	ratelim-internal.h	/^	unsigned msec_per_tick;$/;"	m	struct:ev_token_bucket_cfg	access:public
ev_token_bucket_cfg::read_maximum	ratelim-internal.h	/^	size_t read_maximum;$/;"	m	struct:ev_token_bucket_cfg	access:public
ev_token_bucket_cfg::read_rate	ratelim-internal.h	/^	size_t read_rate;$/;"	m	struct:ev_token_bucket_cfg	access:public
ev_token_bucket_cfg::tick_timeout	ratelim-internal.h	/^	struct timeval tick_timeout;$/;"	m	struct:ev_token_bucket_cfg	typeref:struct:ev_token_bucket_cfg::timeval	access:public
ev_token_bucket_cfg::write_maximum	ratelim-internal.h	/^	size_t write_maximum;$/;"	m	struct:ev_token_bucket_cfg	access:public
ev_token_bucket_cfg::write_rate	ratelim-internal.h	/^	size_t write_rate;$/;"	m	struct:ev_token_bucket_cfg	access:public
ev_token_bucket_cfg_free	bufferevent_ratelim.c	/^ev_token_bucket_cfg_free(struct ev_token_bucket_cfg *cfg)$/;"	f	signature:(struct ev_token_bucket_cfg *cfg)
ev_token_bucket_cfg_free	include/event2/bufferevent.h	/^void ev_token_bucket_cfg_free(struct ev_token_bucket_cfg *cfg);$/;"	p	signature:(struct ev_token_bucket_cfg *cfg)
ev_token_bucket_cfg_new	bufferevent_ratelim.c	/^ev_token_bucket_cfg_new(size_t read_rate, size_t read_burst,$/;"	f	signature:(size_t read_rate, size_t read_burst, size_t write_rate, size_t write_burst, const struct timeval *tick_len)
ev_token_bucket_cfg_new	include/event2/bufferevent.h	/^struct ev_token_bucket_cfg *ev_token_bucket_cfg_new($/;"	p	signature:( size_t read_rate, size_t read_burst, size_t write_rate, size_t write_burst, const struct timeval *tick_len)
ev_token_bucket_decrement_read	ratelim-internal.h	91;"	d
ev_token_bucket_decrement_write	ratelim-internal.h	96;"	d
ev_token_bucket_get_tick	bufferevent_ratelim.c	/^ev_token_bucket_get_tick(const struct timeval *tv,$/;"	f	signature:(const struct timeval *tv, const struct ev_token_bucket_cfg *cfg)
ev_token_bucket_get_tick	ratelim-internal.h	/^ev_uint32_t ev_token_bucket_get_tick(const struct timeval *tv,$/;"	p	signature:(const struct timeval *tv, const struct ev_token_bucket_cfg *cfg)
ev_token_bucket_init	bufferevent_ratelim.c	/^ev_token_bucket_init(struct ev_token_bucket *bucket,$/;"	f	signature:(struct ev_token_bucket *bucket, const struct ev_token_bucket_cfg *cfg, ev_uint32_t current_tick, int reinitialize)
ev_token_bucket_init	ratelim-internal.h	/^int ev_token_bucket_init(struct ev_token_bucket *bucket,$/;"	p	signature:(struct ev_token_bucket *bucket, const struct ev_token_bucket_cfg *cfg, ev_uint32_t current_tick, int reinitialize)
ev_token_bucket_update	bufferevent_ratelim.c	/^ev_token_bucket_update(struct ev_token_bucket *bucket,$/;"	f	signature:(struct ev_token_bucket *bucket, const struct ev_token_bucket_cfg *cfg, ev_uint32_t current_tick)
ev_token_bucket_update	ratelim-internal.h	/^int ev_token_bucket_update(struct ev_token_bucket *bucket,$/;"	p	signature:(struct ev_token_bucket *bucket, const struct ev_token_bucket_cfg *cfg, ev_uint32_t current_tick)
ev_uint16_t	include/event2/util.h	145;"	d
ev_uint16_t	include/event2/util.h	148;"	d
ev_uint16_t	include/event2/util.h	151;"	d
ev_uint16_t	include/event2/util.h	154;"	d
ev_uint16_t	include/event2/util.h	157;"	d
ev_uint32_t	include/event2/util.h	126;"	d
ev_uint32_t	include/event2/util.h	129;"	d
ev_uint32_t	include/event2/util.h	132;"	d
ev_uint32_t	include/event2/util.h	135;"	d
ev_uint32_t	include/event2/util.h	138;"	d
ev_uint64_t	include/event2/util.h	107;"	d
ev_uint64_t	include/event2/util.h	110;"	d
ev_uint64_t	include/event2/util.h	113;"	d
ev_uint64_t	include/event2/util.h	116;"	d
ev_uint64_t	include/event2/util.h	119;"	d
ev_uint8_t	include/event2/util.h	164;"	d
ev_uint8_t	include/event2/util.h	167;"	d
ev_uint8_t	include/event2/util.h	170;"	d
ev_uintptr_t	include/event2/util.h	175;"	d
ev_uintptr_t	include/event2/util.h	178;"	d
ev_uintptr_t	include/event2/util.h	181;"	d
ev_uintptr_t	include/event2/util.h	184;"	d
ev_write	include/event2/bufferevent_struct.h	/^	struct event ev_write;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event	access:public
evbase	event-internal.h	/^	void *evbase;$/;"	m	struct:event_base	access:public
evbuffer	evbuffer-internal.h	/^struct evbuffer {$/;"	s
evbuffer	include/event2/buffer.h	/^struct evbuffer$/;"	s
evbuffer::callbacks	evbuffer-internal.h	/^	TAILQ_HEAD(evbuffer_cb_queue, evbuffer_cb_entry) callbacks;$/;"	m	struct:evbuffer	access:public
evbuffer::cb_queue	evbuffer-internal.h	/^	struct deferred_cb_queue *cb_queue;$/;"	m	struct:evbuffer	typeref:struct:evbuffer::deferred_cb_queue	access:public
evbuffer::deferred	evbuffer-internal.h	/^	struct deferred_cb deferred;$/;"	m	struct:evbuffer	typeref:struct:evbuffer::deferred_cb	access:public
evbuffer::deferred_cbs	evbuffer-internal.h	/^	unsigned deferred_cbs : 1;$/;"	m	struct:evbuffer	access:public
evbuffer::first	evbuffer-internal.h	/^	struct evbuffer_chain *first;$/;"	m	struct:evbuffer	typeref:struct:evbuffer::evbuffer_chain	access:public
evbuffer::flags	evbuffer-internal.h	/^	ev_uint32_t flags;$/;"	m	struct:evbuffer	access:public
evbuffer::freeze_end	evbuffer-internal.h	/^	unsigned freeze_end : 1;$/;"	m	struct:evbuffer	access:public
evbuffer::freeze_start	evbuffer-internal.h	/^	unsigned freeze_start : 1;$/;"	m	struct:evbuffer	access:public
evbuffer::is_overlapped	evbuffer-internal.h	/^	unsigned is_overlapped : 1;$/;"	m	struct:evbuffer	access:public
evbuffer::last	evbuffer-internal.h	/^	struct evbuffer_chain *last;$/;"	m	struct:evbuffer	typeref:struct:evbuffer::evbuffer_chain	access:public
evbuffer::last_with_datap	evbuffer-internal.h	/^	struct evbuffer_chain **last_with_datap;$/;"	m	struct:evbuffer	typeref:struct:evbuffer::evbuffer_chain	access:public
evbuffer::lock	evbuffer-internal.h	/^	void *lock;$/;"	m	struct:evbuffer	access:public
evbuffer::n_add_for_cb	evbuffer-internal.h	/^	size_t n_add_for_cb;$/;"	m	struct:evbuffer	access:public
evbuffer::n_del_for_cb	evbuffer-internal.h	/^	size_t n_del_for_cb;$/;"	m	struct:evbuffer	access:public
evbuffer::own_lock	evbuffer-internal.h	/^	unsigned own_lock : 1;$/;"	m	struct:evbuffer	access:public
evbuffer::parent	evbuffer-internal.h	/^	struct bufferevent *parent;$/;"	m	struct:evbuffer	typeref:struct:evbuffer::bufferevent	access:public
evbuffer::refcnt	evbuffer-internal.h	/^	int refcnt;$/;"	m	struct:evbuffer	access:public
evbuffer::total_len	evbuffer-internal.h	/^	size_t total_len;$/;"	m	struct:evbuffer	access:public
evbuffer_add	buffer.c	/^evbuffer_add(struct evbuffer *buf, const void *data_in, size_t datlen)$/;"	f	signature:(struct evbuffer *buf, const void *data_in, size_t datlen)
evbuffer_add	include/event2/buffer.h	/^int evbuffer_add(struct evbuffer *buf, const void *data, size_t datlen);$/;"	p	signature:(struct evbuffer *buf, const void *data, size_t datlen)
evbuffer_add_buffer	buffer.c	/^evbuffer_add_buffer(struct evbuffer *outbuf, struct evbuffer *inbuf)$/;"	f	signature:(struct evbuffer *outbuf, struct evbuffer *inbuf)
evbuffer_add_buffer	include/event2/buffer.h	/^int evbuffer_add_buffer(struct evbuffer *outbuf, struct evbuffer *inbuf);$/;"	p	signature:(struct evbuffer *outbuf, struct evbuffer *inbuf)
evbuffer_add_cb	buffer.c	/^evbuffer_add_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg)$/;"	f	signature:(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg)
evbuffer_add_cb	include/event2/buffer.h	/^struct evbuffer_cb_entry *evbuffer_add_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg);$/;"	p	signature:(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg)
evbuffer_add_file	buffer.c	/^evbuffer_add_file(struct evbuffer *outbuf, int fd,$/;"	f	signature:(struct evbuffer *outbuf, int fd, ev_off_t offset, ev_off_t length)
evbuffer_add_file	include/event2/buffer.h	/^int evbuffer_add_file(struct evbuffer *outbuf, int fd, ev_off_t offset,$/;"	p	signature:(struct evbuffer *outbuf, int fd, ev_off_t offset, ev_off_t length)
evbuffer_add_printf	buffer.c	/^evbuffer_add_printf(struct evbuffer *buf, const char *fmt, ...)$/;"	f	signature:(struct evbuffer *buf, const char *fmt, ...)
evbuffer_add_printf	include/event2/buffer.h	/^int evbuffer_add_printf(struct evbuffer *buf, const char *fmt, ...)$/;"	p	signature:(struct evbuffer *buf, const char *fmt, ...)
evbuffer_add_reference	buffer.c	/^evbuffer_add_reference(struct evbuffer *outbuf,$/;"	f	signature:(struct evbuffer *outbuf, const void *data, size_t datlen, evbuffer_ref_cleanup_cb cleanupfn, void *extra)
evbuffer_add_reference	include/event2/buffer.h	/^int evbuffer_add_reference(struct evbuffer *outbuf,$/;"	p	signature:(struct evbuffer *outbuf, const void *data, size_t datlen, evbuffer_ref_cleanup_cb cleanupfn, void *cleanupfn_arg)
evbuffer_add_vprintf	buffer.c	/^evbuffer_add_vprintf(struct evbuffer *buf, const char *fmt, va_list ap)$/;"	f	signature:(struct evbuffer *buf, const char *fmt, va_list ap)
evbuffer_add_vprintf	include/event2/buffer.h	/^int evbuffer_add_vprintf(struct evbuffer *buf, const char *fmt, va_list ap)$/;"	p	signature:(struct evbuffer *buf, const char *fmt, va_list ap)
evbuffer_cb	include/event2/buffer_compat.h	/^typedef void (*evbuffer_cb)(struct evbuffer *buffer, size_t old_len, size_t new_len, void *arg);$/;"	t
evbuffer_cb_clear_flags	buffer.c	/^evbuffer_cb_clear_flags(struct evbuffer *buffer,$/;"	f	signature:(struct evbuffer *buffer, struct evbuffer_cb_entry *cb, ev_uint32_t flags)
evbuffer_cb_clear_flags	include/event2/buffer.h	/^int evbuffer_cb_clear_flags(struct evbuffer *buffer,$/;"	p	signature:(struct evbuffer *buffer, struct evbuffer_cb_entry *cb, ev_uint32_t flags)
evbuffer_cb_entry	evbuffer-internal.h	/^struct evbuffer_cb_entry {$/;"	s
evbuffer_cb_entry::__anon13::cb_func	evbuffer-internal.h	/^		evbuffer_cb_func cb_func;$/;"	m	union:evbuffer_cb_entry::__anon13	access:public
evbuffer_cb_entry::__anon13::cb_obsolete	evbuffer-internal.h	/^		evbuffer_cb cb_obsolete;$/;"	m	union:evbuffer_cb_entry::__anon13	access:public
evbuffer_cb_entry::cb	evbuffer-internal.h	/^	} cb;$/;"	m	struct:evbuffer_cb_entry	typeref:union:evbuffer_cb_entry::__anon13	access:public
evbuffer_cb_entry::cbarg	evbuffer-internal.h	/^	void *cbarg;$/;"	m	struct:evbuffer_cb_entry	access:public
evbuffer_cb_entry::flags	evbuffer-internal.h	/^	ev_uint32_t flags;$/;"	m	struct:evbuffer_cb_entry	access:public
evbuffer_cb_entry::next	evbuffer-internal.h	/^	TAILQ_ENTRY(evbuffer_cb_entry) next;$/;"	m	struct:evbuffer_cb_entry	access:public
evbuffer_cb_func	include/event2/buffer.h	/^typedef void (*evbuffer_cb_func)(struct evbuffer *buffer, const struct evbuffer_cb_info *info, void *arg);$/;"	t
evbuffer_cb_info	include/event2/buffer.h	/^struct evbuffer_cb_info {$/;"	s
evbuffer_cb_info::n_added	include/event2/buffer.h	/^	size_t n_added;$/;"	m	struct:evbuffer_cb_info	access:public
evbuffer_cb_info::n_deleted	include/event2/buffer.h	/^	size_t n_deleted;$/;"	m	struct:evbuffer_cb_info	access:public
evbuffer_cb_info::orig_size	include/event2/buffer.h	/^	size_t orig_size;$/;"	m	struct:evbuffer_cb_info	access:public
evbuffer_cb_set_flags	buffer.c	/^evbuffer_cb_set_flags(struct evbuffer *buffer,$/;"	f	signature:(struct evbuffer *buffer, struct evbuffer_cb_entry *cb, ev_uint32_t flags)
evbuffer_cb_set_flags	include/event2/buffer.h	/^int evbuffer_cb_set_flags(struct evbuffer *buffer,$/;"	p	signature:(struct evbuffer *buffer, struct evbuffer_cb_entry *cb, ev_uint32_t flags)
evbuffer_chain	evbuffer-internal.h	/^struct evbuffer_chain {$/;"	s
evbuffer_chain::buffer	evbuffer-internal.h	/^	unsigned char *buffer;$/;"	m	struct:evbuffer_chain	access:public
evbuffer_chain::buffer_len	evbuffer-internal.h	/^	size_t buffer_len;$/;"	m	struct:evbuffer_chain	access:public
evbuffer_chain::flags	evbuffer-internal.h	/^	unsigned flags;$/;"	m	struct:evbuffer_chain	access:public
evbuffer_chain::misalign	evbuffer-internal.h	/^	ev_misalign_t misalign;$/;"	m	struct:evbuffer_chain	access:public
evbuffer_chain::next	evbuffer-internal.h	/^	struct evbuffer_chain *next;$/;"	m	struct:evbuffer_chain	typeref:struct:evbuffer_chain::evbuffer_chain	access:public
evbuffer_chain::off	evbuffer-internal.h	/^	size_t off;$/;"	m	struct:evbuffer_chain	access:public
evbuffer_chain_align	buffer.c	/^evbuffer_chain_align(struct evbuffer_chain *chain)$/;"	f	file:	signature:(struct evbuffer_chain *chain)
evbuffer_chain_align	buffer.c	/^static void evbuffer_chain_align(struct evbuffer_chain *chain);$/;"	p	file:	signature:(struct evbuffer_chain *chain)
evbuffer_chain_fd	evbuffer-internal.h	/^struct evbuffer_chain_fd {$/;"	s
evbuffer_chain_fd::fd	evbuffer-internal.h	/^	int fd;	\/**< the fd associated with this chain *\/$/;"	m	struct:evbuffer_chain_fd	access:public
evbuffer_chain_free	buffer.c	/^evbuffer_chain_free(struct evbuffer_chain *chain)$/;"	f	file:	signature:(struct evbuffer_chain *chain)
evbuffer_chain_insert	buffer.c	/^evbuffer_chain_insert(struct evbuffer *buf,$/;"	f	file:	signature:(struct evbuffer *buf, struct evbuffer_chain *chain)
evbuffer_chain_insert_new	buffer.c	/^evbuffer_chain_insert_new(struct evbuffer *buf, size_t datlen)$/;"	f	file:	signature:(struct evbuffer *buf, size_t datlen)
evbuffer_chain_new	buffer.c	/^evbuffer_chain_new(size_t size)$/;"	f	file:	signature:(size_t size)
evbuffer_chain_reference	evbuffer-internal.h	/^struct evbuffer_chain_reference {$/;"	s
evbuffer_chain_reference::cleanupfn	evbuffer-internal.h	/^	evbuffer_ref_cleanup_cb cleanupfn;$/;"	m	struct:evbuffer_chain_reference	access:public
evbuffer_chain_reference::extra	evbuffer-internal.h	/^	void *extra;$/;"	m	struct:evbuffer_chain_reference	access:public
evbuffer_chain_should_realign	buffer.c	/^evbuffer_chain_should_realign(struct evbuffer_chain *chain,$/;"	f	file:	signature:(struct evbuffer_chain *chain, size_t datlen)
evbuffer_chain_should_realign	buffer.c	/^static int evbuffer_chain_should_realign(struct evbuffer_chain *chain,$/;"	p	file:	signature:(struct evbuffer_chain *chain, size_t datalen)
evbuffer_chains_all_empty	buffer.c	/^evbuffer_chains_all_empty(struct evbuffer_chain *chain)$/;"	f	file:	signature:(struct evbuffer_chain *chain)
evbuffer_chains_all_empty	buffer.c	/^static inline int evbuffer_chains_all_empty(struct evbuffer_chain *chain) {$/;"	f	file:	signature:(struct evbuffer_chain *chain)
evbuffer_clear_flags	buffer.c	/^evbuffer_clear_flags(struct evbuffer *buf, ev_uint64_t flags)$/;"	f	signature:(struct evbuffer *buf, ev_uint64_t flags)
evbuffer_clear_flags	include/event2/buffer.h	/^int evbuffer_clear_flags(struct evbuffer *buf, ev_uint64_t flags);$/;"	p	signature:(struct evbuffer *buf, ev_uint64_t flags)
evbuffer_commit_read	buffer_iocp.c	/^evbuffer_commit_read(struct evbuffer *evbuf, ev_ssize_t nBytes)$/;"	f	signature:(struct evbuffer *evbuf, ev_ssize_t nBytes)
evbuffer_commit_read	iocp-internal.h	/^void evbuffer_commit_read(struct evbuffer *, ev_ssize_t);$/;"	p	signature:(struct evbuffer *, ev_ssize_t)
evbuffer_commit_space	buffer.c	/^evbuffer_commit_space(struct evbuffer *buf,$/;"	f	signature:(struct evbuffer *buf, struct evbuffer_iovec *vec, int n_vecs)
evbuffer_commit_space	include/event2/buffer.h	/^int evbuffer_commit_space(struct evbuffer *buf,$/;"	p	signature:(struct evbuffer *buf, struct evbuffer_iovec *vec, int n_vecs)
evbuffer_commit_write	buffer_iocp.c	/^evbuffer_commit_write(struct evbuffer *evbuf, ev_ssize_t nBytes)$/;"	f	signature:(struct evbuffer *evbuf, ev_ssize_t nBytes)
evbuffer_commit_write	iocp-internal.h	/^void evbuffer_commit_write(struct evbuffer *, ev_ssize_t);$/;"	p	signature:(struct evbuffer *, ev_ssize_t)
evbuffer_contains	test/regress_http.c	/^evbuffer_contains(struct evbuffer *buf, const char *s)$/;"	f	file:	signature:(struct evbuffer *buf, const char *s)
evbuffer_copyout	buffer.c	/^evbuffer_copyout(struct evbuffer *buf, void *data_out, size_t datlen)$/;"	f	signature:(struct evbuffer *buf, void *data_out, size_t datlen)
evbuffer_copyout	include/event2/buffer.h	/^ev_ssize_t evbuffer_copyout(struct evbuffer *buf, void *data_out, size_t datlen);$/;"	p	signature:(struct evbuffer *buf, void *data_out, size_t datlen)
evbuffer_datacmp	test/regress_http.c	/^evbuffer_datacmp(struct evbuffer *buf, const char *s)$/;"	f	file:	signature:(struct evbuffer *buf, const char *s)
evbuffer_defer_callbacks	buffer.c	/^evbuffer_defer_callbacks(struct evbuffer *buffer, struct event_base *base)$/;"	f	signature:(struct evbuffer *buffer, struct event_base *base)
evbuffer_defer_callbacks	include/event2/buffer.h	/^int evbuffer_defer_callbacks(struct evbuffer *buffer, struct event_base *base);$/;"	p	signature:(struct evbuffer *buffer, struct event_base *base)
evbuffer_deferred_callback	buffer.c	/^evbuffer_deferred_callback(struct deferred_cb *cb, void *arg)$/;"	f	file:	signature:(struct deferred_cb *cb, void *arg)
evbuffer_deferred_callback	buffer.c	/^static void evbuffer_deferred_callback(struct deferred_cb *cb, void *arg);$/;"	p	file:	signature:(struct deferred_cb *cb, void *arg)
evbuffer_drain	buffer.c	/^evbuffer_drain(struct evbuffer *buf, size_t len)$/;"	f	signature:(struct evbuffer *buf, size_t len)
evbuffer_drain	include/event2/buffer.h	/^int evbuffer_drain(struct evbuffer *buf, size_t len);$/;"	p	signature:(struct evbuffer *buf, size_t len)
evbuffer_enable_locking	buffer.c	/^evbuffer_enable_locking(struct evbuffer *buf, void *lock)$/;"	f	signature:(struct evbuffer *buf, void *lock)
evbuffer_enable_locking	include/event2/buffer.h	/^int evbuffer_enable_locking(struct evbuffer *buf, void *lock);$/;"	p	signature:(struct evbuffer *buf, void *lock)
evbuffer_eol_style	include/event2/buffer.h	/^enum evbuffer_eol_style {$/;"	g
evbuffer_expand	buffer.c	/^evbuffer_expand(struct evbuffer *buf, size_t datlen)$/;"	f	signature:(struct evbuffer *buf, size_t datlen)
evbuffer_expand	include/event2/buffer.h	/^int evbuffer_expand(struct evbuffer *buf, size_t datlen);$/;"	p	signature:(struct evbuffer *buf, size_t datlen)
evbuffer_expand_singlechain	buffer.c	/^evbuffer_expand_singlechain(struct evbuffer *buf, size_t datlen)$/;"	f	file:	signature:(struct evbuffer *buf, size_t datlen)
evbuffer_expand_singlechain	buffer.c	/^static struct evbuffer_chain *evbuffer_expand_singlechain(struct evbuffer *buf,$/;"	p	file:	signature:(struct evbuffer *buf, size_t datlen)
evbuffer_find	buffer.c	/^evbuffer_find(struct evbuffer *buffer, const unsigned char *what, size_t len)$/;"	f	signature:(struct evbuffer *buffer, const unsigned char *what, size_t len)
evbuffer_find	include/event2/buffer_compat.h	/^unsigned char *evbuffer_find(struct evbuffer *buffer, const unsigned char *what, size_t len);$/;"	p	signature:(struct evbuffer *buffer, const unsigned char *what, size_t len)
evbuffer_find_eol_char	buffer.c	/^evbuffer_find_eol_char(struct evbuffer_ptr *it)$/;"	f	file:	signature:(struct evbuffer_ptr *it)
evbuffer_free	buffer.c	/^evbuffer_free(struct evbuffer *buffer)$/;"	f	signature:(struct evbuffer *buffer)
evbuffer_free	include/event2/buffer.h	/^void evbuffer_free(struct evbuffer *buf);$/;"	p	signature:(struct evbuffer *buf)
evbuffer_free_all_chains	buffer.c	/^evbuffer_free_all_chains(struct evbuffer_chain *chain)$/;"	f	file:	signature:(struct evbuffer_chain *chain)
evbuffer_free_trailing_empty_chains	buffer.c	/^evbuffer_free_trailing_empty_chains(struct evbuffer *buf)$/;"	f	file:	signature:(struct evbuffer *buf)
evbuffer_freeze	buffer.c	/^evbuffer_freeze(struct evbuffer *buffer, int start)$/;"	f	signature:(struct evbuffer *buffer, int start)
evbuffer_freeze	include/event2/buffer.h	/^int evbuffer_freeze(struct evbuffer *buf, int at_front);$/;"	p	signature:(struct evbuffer *buf, int at_front)
evbuffer_get_contiguous_space	buffer.c	/^evbuffer_get_contiguous_space(const struct evbuffer *buf)$/;"	f	signature:(const struct evbuffer *buf)
evbuffer_get_contiguous_space	include/event2/buffer.h	/^size_t evbuffer_get_contiguous_space(const struct evbuffer *buf);$/;"	p	signature:(const struct evbuffer *buf)
evbuffer_get_length	buffer.c	/^evbuffer_get_length(const struct evbuffer *buffer)$/;"	f	signature:(const struct evbuffer *buffer)
evbuffer_get_length	include/event2/buffer.h	/^size_t evbuffer_get_length(const struct evbuffer *buf);$/;"	p	signature:(const struct evbuffer *buf)
evbuffer_get_waste	test/regress_buffer.c	/^evbuffer_get_waste(struct evbuffer *buf, size_t *allocatedp, size_t *wastedp, size_t *usedp)$/;"	f	file:	signature:(struct evbuffer *buf, size_t *allocatedp, size_t *wastedp, size_t *usedp)
evbuffer_getchr	buffer.c	/^evbuffer_getchr(struct evbuffer_ptr *it)$/;"	f	file:	signature:(struct evbuffer_ptr *it)
evbuffer_invoke_callbacks	buffer.c	/^evbuffer_invoke_callbacks(struct evbuffer *buffer)$/;"	f	signature:(struct evbuffer *buffer)
evbuffer_invoke_callbacks	evbuffer-internal.h	/^void evbuffer_invoke_callbacks(struct evbuffer *buf);$/;"	p	signature:(struct evbuffer *buf)
evbuffer_iovec	include/event2/buffer.h	/^struct evbuffer_iovec {$/;"	s
evbuffer_iovec	include/event2/buffer.h	125;"	d
evbuffer_iovec::iov_base	include/event2/buffer.h	/^	void *iov_base;$/;"	m	struct:evbuffer_iovec	access:public
evbuffer_iovec::iov_len	include/event2/buffer.h	/^	size_t iov_len;$/;"	m	struct:evbuffer_iovec	access:public
evbuffer_launch_read	buffer_iocp.c	/^evbuffer_launch_read(struct evbuffer *buf, size_t at_most,$/;"	f	signature:(struct evbuffer *buf, size_t at_most, struct event_overlapped *ol)
evbuffer_launch_read	iocp-internal.h	/^int evbuffer_launch_read(struct evbuffer *buf, size_t n, struct event_overlapped *ol);$/;"	p	signature:(struct evbuffer *buf, size_t n, struct event_overlapped *ol)
evbuffer_launch_write	buffer_iocp.c	/^evbuffer_launch_write(struct evbuffer *buf, ev_ssize_t at_most,$/;"	f	signature:(struct evbuffer *buf, ev_ssize_t at_most, struct event_overlapped *ol)
evbuffer_launch_write	iocp-internal.h	/^int evbuffer_launch_write(struct evbuffer *buf, ev_ssize_t n, struct event_overlapped *ol);$/;"	p	signature:(struct evbuffer *buf, ev_ssize_t n, struct event_overlapped *ol)
evbuffer_lock	buffer.c	/^evbuffer_lock(struct evbuffer *buf)$/;"	f	signature:(struct evbuffer *buf)
evbuffer_lock	include/event2/buffer.h	/^void evbuffer_lock(struct evbuffer *buf);$/;"	p	signature:(struct evbuffer *buf)
evbuffer_new	buffer.c	/^evbuffer_new(void)$/;"	f	signature:(void)
evbuffer_new	include/event2/buffer.h	/^struct evbuffer *evbuffer_new(void);$/;"	p	signature:(void)
evbuffer_overlapped	buffer_iocp.c	/^struct evbuffer_overlapped {$/;"	s	file:
evbuffer_overlapped::buffer	buffer_iocp.c	/^	struct evbuffer buffer;$/;"	m	struct:evbuffer_overlapped	typeref:struct:evbuffer_overlapped::evbuffer	file:	access:public
evbuffer_overlapped::buffers	buffer_iocp.c	/^	WSABUF buffers[MAX_WSABUFS];$/;"	m	struct:evbuffer_overlapped	file:	access:public
evbuffer_overlapped::fd	buffer_iocp.c	/^	evutil_socket_t fd;$/;"	m	struct:evbuffer_overlapped	file:	access:public
evbuffer_overlapped::first_pinned	buffer_iocp.c	/^	struct evbuffer_chain *first_pinned;$/;"	m	struct:evbuffer_overlapped	typeref:struct:evbuffer_overlapped::evbuffer_chain	file:	access:public
evbuffer_overlapped::n_buffers	buffer_iocp.c	/^	int n_buffers;$/;"	m	struct:evbuffer_overlapped	file:	access:public
evbuffer_overlapped::read_in_progress	buffer_iocp.c	/^	unsigned read_in_progress : 1;$/;"	m	struct:evbuffer_overlapped	file:	access:public
evbuffer_overlapped::write_in_progress	buffer_iocp.c	/^	unsigned write_in_progress : 1;$/;"	m	struct:evbuffer_overlapped	file:	access:public
evbuffer_overlapped_new	buffer_iocp.c	/^evbuffer_overlapped_new(evutil_socket_t fd)$/;"	f	signature:(evutil_socket_t fd)
evbuffer_overlapped_new	iocp-internal.h	/^struct evbuffer *evbuffer_overlapped_new(evutil_socket_t fd);$/;"	p	signature:(evutil_socket_t fd)
evbuffer_peek	buffer.c	/^evbuffer_peek(struct evbuffer *buffer, ev_ssize_t len,$/;"	f	signature:(struct evbuffer *buffer, ev_ssize_t len, struct evbuffer_ptr *start_at, struct evbuffer_iovec *vec, int n_vec)
evbuffer_peek	include/event2/buffer.h	/^int evbuffer_peek(struct evbuffer *buffer, ev_ssize_t len,$/;"	p	signature:(struct evbuffer *buffer, ev_ssize_t len, struct evbuffer_ptr *start_at, struct evbuffer_iovec *vec_out, int n_vec)
evbuffer_prepend	buffer.c	/^evbuffer_prepend(struct evbuffer *buf, const void *data, size_t datlen)$/;"	f	signature:(struct evbuffer *buf, const void *data, size_t datlen)
evbuffer_prepend	include/event2/buffer.h	/^int evbuffer_prepend(struct evbuffer *buf, const void *data, size_t size);$/;"	p	signature:(struct evbuffer *buf, const void *data, size_t size)
evbuffer_prepend_buffer	buffer.c	/^evbuffer_prepend_buffer(struct evbuffer *outbuf, struct evbuffer *inbuf)$/;"	f	signature:(struct evbuffer *outbuf, struct evbuffer *inbuf)
evbuffer_prepend_buffer	include/event2/buffer.h	/^int evbuffer_prepend_buffer(struct evbuffer *dst, struct evbuffer* src);$/;"	p	signature:(struct evbuffer *dst, struct evbuffer* src)
evbuffer_ptr	include/event2/buffer.h	/^struct evbuffer_ptr {$/;"	s
evbuffer_ptr::__anon1::chain	include/event2/buffer.h	/^		void *chain;$/;"	m	struct:evbuffer_ptr::__anon1	access:public
evbuffer_ptr::__anon1::pos_in_chain	include/event2/buffer.h	/^		size_t pos_in_chain;$/;"	m	struct:evbuffer_ptr::__anon1	access:public
evbuffer_ptr::_internal	include/event2/buffer.h	/^	} _internal;$/;"	m	struct:evbuffer_ptr	typeref:struct:evbuffer_ptr::__anon1	access:public
evbuffer_ptr::pos	include/event2/buffer.h	/^	ev_ssize_t pos;$/;"	m	struct:evbuffer_ptr	access:public
evbuffer_ptr_how	include/event2/buffer.h	/^enum evbuffer_ptr_how {$/;"	g
evbuffer_ptr_memcmp	buffer.c	/^evbuffer_ptr_memcmp(const struct evbuffer *buf, const struct evbuffer_ptr *pos,$/;"	f	file:	signature:(const struct evbuffer *buf, const struct evbuffer_ptr *pos, const char *mem, size_t len)
evbuffer_ptr_memcmp	buffer.c	/^static int evbuffer_ptr_memcmp(const struct evbuffer *buf,$/;"	p	file:	signature:(const struct evbuffer *buf, const struct evbuffer_ptr *pos, const char *mem, size_t len)
evbuffer_ptr_set	buffer.c	/^evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,$/;"	f	signature:(struct evbuffer *buf, struct evbuffer_ptr *pos, size_t position, enum evbuffer_ptr_how how)
evbuffer_ptr_set	include/event2/buffer.h	/^evbuffer_ptr_set(struct evbuffer *buffer, struct evbuffer_ptr *ptr,$/;"	p	signature:(struct evbuffer *buffer, struct evbuffer_ptr *ptr, size_t position, enum evbuffer_ptr_how how)
evbuffer_pullup	buffer.c	/^evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)$/;"	f	signature:(struct evbuffer *buf, ev_ssize_t size)
evbuffer_pullup	include/event2/buffer.h	/^unsigned char *evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size);$/;"	p	signature:(struct evbuffer *buf, ev_ssize_t size)
evbuffer_read	buffer.c	/^evbuffer_read(struct evbuffer *buf, evutil_socket_t fd, int howmuch)$/;"	f	signature:(struct evbuffer *buf, evutil_socket_t fd, int howmuch)
evbuffer_read	include/event2/buffer.h	/^int evbuffer_read(struct evbuffer *buffer, evutil_socket_t fd, int howmuch);$/;"	p	signature:(struct evbuffer *buffer, evutil_socket_t fd, int howmuch)
evbuffer_readfile	buffer.c	/^evbuffer_readfile(struct evbuffer *buf, evutil_socket_t fd, ev_ssize_t howmuch)$/;"	f	file:	signature:(struct evbuffer *buf, evutil_socket_t fd, ev_ssize_t howmuch)
evbuffer_readfile	buffer.c	/^static int evbuffer_readfile(struct evbuffer *buf, evutil_socket_t fd,$/;"	p	file:	signature:(struct evbuffer *buf, evutil_socket_t fd, ev_ssize_t howmuch)
evbuffer_readfile	buffer.c	151;"	d	file:
evbuffer_readline	buffer.c	/^evbuffer_readline(struct evbuffer *buffer)$/;"	f	signature:(struct evbuffer *buffer)
evbuffer_readline	include/event2/buffer_compat.h	/^char *evbuffer_readline(struct evbuffer *buffer);$/;"	p	signature:(struct evbuffer *buffer)
evbuffer_readln	buffer.c	/^evbuffer_readln(struct evbuffer *buffer, size_t *n_read_out,$/;"	f	signature:(struct evbuffer *buffer, size_t *n_read_out, enum evbuffer_eol_style eol_style)
evbuffer_readln	include/event2/buffer.h	/^char *evbuffer_readln(struct evbuffer *buffer, size_t *n_read_out,$/;"	p	signature:(struct evbuffer *buffer, size_t *n_read_out, enum evbuffer_eol_style eol_style)
evbuffer_ref_cleanup_cb	include/event2/buffer.h	/^typedef void (*evbuffer_ref_cleanup_cb)(const void *data,$/;"	t
evbuffer_remove	buffer.c	/^evbuffer_remove(struct evbuffer *buf, void *data_out, size_t datlen)$/;"	f	signature:(struct evbuffer *buf, void *data_out, size_t datlen)
evbuffer_remove	include/event2/buffer.h	/^int evbuffer_remove(struct evbuffer *buf, void *data, size_t datlen);$/;"	p	signature:(struct evbuffer *buf, void *data, size_t datlen)
evbuffer_remove_all_callbacks	buffer.c	/^evbuffer_remove_all_callbacks(struct evbuffer *buffer)$/;"	f	file:	signature:(struct evbuffer *buffer)
evbuffer_remove_buffer	buffer.c	/^evbuffer_remove_buffer(struct evbuffer *src, struct evbuffer *dst,$/;"	f	signature:(struct evbuffer *src, struct evbuffer *dst, size_t datlen)
evbuffer_remove_buffer	include/event2/buffer.h	/^int evbuffer_remove_buffer(struct evbuffer *src, struct evbuffer *dst,$/;"	p	signature:(struct evbuffer *src, struct evbuffer *dst, size_t datlen)
evbuffer_remove_cb	buffer.c	/^evbuffer_remove_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg)$/;"	f	signature:(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg)
evbuffer_remove_cb	include/event2/buffer.h	/^int evbuffer_remove_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg);$/;"	p	signature:(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg)
evbuffer_remove_cb_entry	buffer.c	/^evbuffer_remove_cb_entry(struct evbuffer *buffer,$/;"	f	signature:(struct evbuffer *buffer, struct evbuffer_cb_entry *ent)
evbuffer_remove_cb_entry	include/event2/buffer.h	/^int evbuffer_remove_cb_entry(struct evbuffer *buffer,$/;"	p	signature:(struct evbuffer *buffer, struct evbuffer_cb_entry *ent)
evbuffer_reserve_space	buffer.c	/^evbuffer_reserve_space(struct evbuffer *buf, ev_ssize_t size,$/;"	f	signature:(struct evbuffer *buf, ev_ssize_t size, struct evbuffer_iovec *vec, int n_vecs)
evbuffer_reserve_space	include/event2/buffer.h	/^evbuffer_reserve_space(struct evbuffer *buf, ev_ssize_t size,$/;"	p	signature:(struct evbuffer *buf, ev_ssize_t size, struct evbuffer_iovec *vec, int n_vec)
evbuffer_run_callbacks	buffer.c	/^evbuffer_run_callbacks(struct evbuffer *buffer, int running_deferred)$/;"	f	file:	signature:(struct evbuffer *buffer, int running_deferred)
evbuffer_search	buffer.c	/^evbuffer_search(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start)$/;"	f	signature:(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start)
evbuffer_search	include/event2/buffer.h	/^struct evbuffer_ptr evbuffer_search(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start);$/;"	p	signature:(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start)
evbuffer_search_eol	buffer.c	/^evbuffer_search_eol(struct evbuffer *buffer,$/;"	f	signature:(struct evbuffer *buffer, struct evbuffer_ptr *start, size_t *eol_len_out, enum evbuffer_eol_style eol_style)
evbuffer_search_eol	include/event2/buffer.h	/^struct evbuffer_ptr evbuffer_search_eol(struct evbuffer *buffer,$/;"	p	signature:(struct evbuffer *buffer, struct evbuffer_ptr *start, size_t *eol_len_out, enum evbuffer_eol_style eol_style)
evbuffer_search_range	buffer.c	/^evbuffer_search_range(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start, const struct evbuffer_ptr *end)$/;"	f	signature:(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start, const struct evbuffer_ptr *end)
evbuffer_search_range	include/event2/buffer.h	/^struct evbuffer_ptr evbuffer_search_range(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start, const struct evbuffer_ptr *end);$/;"	p	signature:(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start, const struct evbuffer_ptr *end)
evbuffer_set_flags	buffer.c	/^evbuffer_set_flags(struct evbuffer *buf, ev_uint64_t flags)$/;"	f	signature:(struct evbuffer *buf, ev_uint64_t flags)
evbuffer_set_flags	include/event2/buffer.h	/^int evbuffer_set_flags(struct evbuffer *buf, ev_uint64_t flags);$/;"	p	signature:(struct evbuffer *buf, ev_uint64_t flags)
evbuffer_set_parent	buffer.c	/^evbuffer_set_parent(struct evbuffer *buf, struct bufferevent *bev)$/;"	f	signature:(struct evbuffer *buf, struct bufferevent *bev)
evbuffer_set_parent	evbuffer-internal.h	/^void evbuffer_set_parent(struct evbuffer *buf, struct bufferevent *bev);$/;"	p	signature:(struct evbuffer *buf, struct bufferevent *bev)
evbuffer_setcb	buffer.c	/^evbuffer_setcb(struct evbuffer *buffer, evbuffer_cb cb, void *cbarg)$/;"	f	signature:(struct evbuffer *buffer, evbuffer_cb cb, void *cbarg)
evbuffer_setcb	include/event2/buffer_compat.h	/^void evbuffer_setcb(struct evbuffer *buffer, evbuffer_cb cb, void *cbarg);$/;"	p	signature:(struct evbuffer *buffer, evbuffer_cb cb, void *cbarg)
evbuffer_strchr	buffer.c	/^evbuffer_strchr(struct evbuffer_ptr *it, const char chr)$/;"	f	file:	signature:(struct evbuffer_ptr *it, const char chr)
evbuffer_strspn	buffer.c	/^evbuffer_strspn($/;"	f	file:	signature:( struct evbuffer_ptr *ptr, const char *chrset)
evbuffer_testcases	test/regress_buffer.c	/^struct testcase_t evbuffer_testcases[] = {$/;"	v	typeref:struct:testcase_t
evbuffer_unfreeze	buffer.c	/^evbuffer_unfreeze(struct evbuffer *buffer, int start)$/;"	f	signature:(struct evbuffer *buffer, int start)
evbuffer_unfreeze	include/event2/buffer.h	/^int evbuffer_unfreeze(struct evbuffer *buf, int at_front);$/;"	p	signature:(struct evbuffer *buf, int at_front)
evbuffer_unlock	buffer.c	/^evbuffer_unlock(struct evbuffer *buf)$/;"	f	signature:(struct evbuffer *buf)
evbuffer_unlock	include/event2/buffer.h	/^void evbuffer_unlock(struct evbuffer *buf);$/;"	p	signature:(struct evbuffer *buf)
evbuffer_validate	test/regress_buffer.c	165;"	d	file:
evbuffer_write	buffer.c	/^evbuffer_write(struct evbuffer *buffer, evutil_socket_t fd)$/;"	f	signature:(struct evbuffer *buffer, evutil_socket_t fd)
evbuffer_write	include/event2/buffer.h	/^int evbuffer_write(struct evbuffer *buffer, evutil_socket_t fd);$/;"	p	signature:(struct evbuffer *buffer, evutil_socket_t fd)
evbuffer_write_atmost	buffer.c	/^evbuffer_write_atmost(struct evbuffer *buffer, evutil_socket_t fd,$/;"	f	signature:(struct evbuffer *buffer, evutil_socket_t fd, ev_ssize_t howmuch)
evbuffer_write_atmost	include/event2/buffer.h	/^int evbuffer_write_atmost(struct evbuffer *buffer, evutil_socket_t fd,$/;"	p	signature:(struct evbuffer *buffer, evutil_socket_t fd, ev_ssize_t howmuch)
evbuffer_write_iovec	buffer.c	/^evbuffer_write_iovec(struct evbuffer *buffer, evutil_socket_t fd,$/;"	f	file:	signature:(struct evbuffer *buffer, evutil_socket_t fd, ev_ssize_t howmuch)
evbuffer_write_sendfile	buffer.c	/^evbuffer_write_sendfile(struct evbuffer *buffer, evutil_socket_t fd,$/;"	f	file:	signature:(struct evbuffer *buffer, evutil_socket_t fd, ev_ssize_t howmuch)
evbuffercb	include/event2/bufferevent_compat.h	31;"	d
evcon	evrpc-internal.h	/^	struct evhttp_connection *evcon;$/;"	m	struct:evrpc_hook_meta	typeref:struct:evrpc_hook_meta::evhttp_connection	access:public
evcon	evrpc-internal.h	/^	struct evhttp_connection *evcon;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::evhttp_connection	access:public
evcon	include/event2/http_struct.h	/^	struct evhttp_connection *evcon;$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evhttp_connection	access:public
evconnlistener	listener.c	/^struct evconnlistener {$/;"	s	file:
evconnlistener::cb	listener.c	/^	evconnlistener_cb cb;$/;"	m	struct:evconnlistener	file:	access:public
evconnlistener::enabled	listener.c	/^	unsigned enabled : 1;$/;"	m	struct:evconnlistener	file:	access:public
evconnlistener::errorcb	listener.c	/^	evconnlistener_errorcb errorcb;$/;"	m	struct:evconnlistener	file:	access:public
evconnlistener::flags	listener.c	/^	unsigned flags;$/;"	m	struct:evconnlistener	file:	access:public
evconnlistener::lock	listener.c	/^	void *lock;$/;"	m	struct:evconnlistener	file:	access:public
evconnlistener::ops	listener.c	/^	const struct evconnlistener_ops *ops;$/;"	m	struct:evconnlistener	typeref:struct:evconnlistener::evconnlistener_ops	file:	access:public
evconnlistener::refcnt	listener.c	/^	short refcnt;$/;"	m	struct:evconnlistener	file:	access:public
evconnlistener::user_data	listener.c	/^	void *user_data;$/;"	m	struct:evconnlistener	file:	access:public
evconnlistener_cb	include/event2/listener.h	/^typedef void (*evconnlistener_cb)(struct evconnlistener *, evutil_socket_t, struct sockaddr *, int socklen, void *);$/;"	t
evconnlistener_disable	include/event2/listener.h	/^int evconnlistener_disable(struct evconnlistener *lev);$/;"	p	signature:(struct evconnlistener *lev)
evconnlistener_disable	listener.c	/^evconnlistener_disable(struct evconnlistener *lev)$/;"	f	signature:(struct evconnlistener *lev)
evconnlistener_enable	include/event2/listener.h	/^int evconnlistener_enable(struct evconnlistener *lev);$/;"	p	signature:(struct evconnlistener *lev)
evconnlistener_enable	listener.c	/^evconnlistener_enable(struct evconnlistener *lev)$/;"	f	signature:(struct evconnlistener *lev)
evconnlistener_errorcb	include/event2/listener.h	/^typedef void (*evconnlistener_errorcb)(struct evconnlistener *, void *);$/;"	t
evconnlistener_event	listener.c	/^struct evconnlistener_event {$/;"	s	file:
evconnlistener_event::base	listener.c	/^	struct evconnlistener base;$/;"	m	struct:evconnlistener_event	typeref:struct:evconnlistener_event::evconnlistener	file:	access:public
evconnlistener_event::listener	listener.c	/^	struct event listener;$/;"	m	struct:evconnlistener_event	typeref:struct:evconnlistener_event::event	file:	access:public
evconnlistener_event_ops	listener.c	/^static const struct evconnlistener_ops evconnlistener_event_ops = {$/;"	v	typeref:struct:evconnlistener_ops	file:
evconnlistener_free	include/event2/listener.h	/^void evconnlistener_free(struct evconnlistener *lev);$/;"	p	signature:(struct evconnlistener *lev)
evconnlistener_free	listener.c	/^evconnlistener_free(struct evconnlistener *lev)$/;"	f	signature:(struct evconnlistener *lev)
evconnlistener_get_base	include/event2/listener.h	/^struct event_base *evconnlistener_get_base(struct evconnlistener *lev);$/;"	p	signature:(struct evconnlistener *lev)
evconnlistener_get_base	listener.c	/^evconnlistener_get_base(struct evconnlistener *lev)$/;"	f	signature:(struct evconnlistener *lev)
evconnlistener_get_fd	include/event2/listener.h	/^evutil_socket_t evconnlistener_get_fd(struct evconnlistener *lev);$/;"	p	signature:(struct evconnlistener *lev)
evconnlistener_get_fd	listener.c	/^evconnlistener_get_fd(struct evconnlistener *lev)$/;"	f	signature:(struct evconnlistener *lev)
evconnlistener_iocp	listener.c	/^struct evconnlistener_iocp {$/;"	s	file:
evconnlistener_iocp::accepting	listener.c	/^	struct accepting_socket **accepting;$/;"	m	struct:evconnlistener_iocp	typeref:struct:evconnlistener_iocp::accepting_socket	file:	access:public
evconnlistener_iocp::base	listener.c	/^	struct evconnlistener base;$/;"	m	struct:evconnlistener_iocp	typeref:struct:evconnlistener_iocp::evconnlistener	file:	access:public
evconnlistener_iocp::event_added	listener.c	/^	unsigned event_added : 1;$/;"	m	struct:evconnlistener_iocp	file:	access:public
evconnlistener_iocp::event_base	listener.c	/^	struct event_base *event_base;$/;"	m	struct:evconnlistener_iocp	typeref:struct:evconnlistener_iocp::event_base	file:	access:public
evconnlistener_iocp::fd	listener.c	/^	evutil_socket_t fd;$/;"	m	struct:evconnlistener_iocp	file:	access:public
evconnlistener_iocp::n_accepting	listener.c	/^	short n_accepting;$/;"	m	struct:evconnlistener_iocp	file:	access:public
evconnlistener_iocp::port	listener.c	/^	struct event_iocp_port *port;$/;"	m	struct:evconnlistener_iocp	typeref:struct:evconnlistener_iocp::event_iocp_port	file:	access:public
evconnlistener_iocp::shutting_down	listener.c	/^	unsigned shutting_down : 1;$/;"	m	struct:evconnlistener_iocp	file:	access:public
evconnlistener_iocp_ops	listener.c	/^static const struct evconnlistener_ops evconnlistener_iocp_ops = {$/;"	v	typeref:struct:evconnlistener_ops	file:
evconnlistener_new	include/event2/listener.h	/^struct evconnlistener *evconnlistener_new(struct event_base *base,$/;"	p	signature:(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, evutil_socket_t fd)
evconnlistener_new	listener.c	/^evconnlistener_new(struct event_base *base,$/;"	f	signature:(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, evutil_socket_t fd)
evconnlistener_new_async	listener.c	/^evconnlistener_new_async(struct event_base *base,$/;"	f	signature:(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, evutil_socket_t fd)
evconnlistener_new_async	listener.c	/^evconnlistener_new_async(struct event_base *base,$/;"	p	file:	signature:(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, evutil_socket_t fd)
evconnlistener_new_bind	include/event2/listener.h	/^struct evconnlistener *evconnlistener_new_bind(struct event_base *base,$/;"	p	signature:(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, const struct sockaddr *sa, int socklen)
evconnlistener_new_bind	listener.c	/^evconnlistener_new_bind(struct event_base *base, evconnlistener_cb cb,$/;"	f	signature:(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, const struct sockaddr *sa, int socklen)
evconnlistener_ops	listener.c	/^struct evconnlistener_ops {$/;"	s	file:
evconnlistener_ops::destroy	listener.c	/^	void (*destroy)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	file:	access:public
evconnlistener_ops::disable	listener.c	/^	int (*disable)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	file:	access:public
evconnlistener_ops::enable	listener.c	/^	int (*enable)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	file:	access:public
evconnlistener_ops::getbase	listener.c	/^	struct event_base *(*getbase)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	typeref:struct:evconnlistener_ops::getbase	file:	access:public
evconnlistener_ops::getfd	listener.c	/^	evutil_socket_t (*getfd)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	file:	access:public
evconnlistener_ops::shutdown	listener.c	/^	void (*shutdown)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	file:	access:public
evconnlistener_set_cb	include/event2/listener.h	/^void evconnlistener_set_cb(struct evconnlistener *lev,$/;"	p	signature:(struct evconnlistener *lev, evconnlistener_cb cb, void *arg)
evconnlistener_set_cb	listener.c	/^evconnlistener_set_cb(struct evconnlistener *lev,$/;"	f	signature:(struct evconnlistener *lev, evconnlistener_cb cb, void *arg)
evconnlistener_set_error_cb	include/event2/listener.h	/^void evconnlistener_set_error_cb(struct evconnlistener *lev,$/;"	p	signature:(struct evconnlistener *lev, evconnlistener_errorcb errorcb)
evconnlistener_set_error_cb	listener.c	/^evconnlistener_set_error_cb(struct evconnlistener *lev,$/;"	f	signature:(struct evconnlistener *lev, evconnlistener_errorcb errorcb)
evdns_add_server_port	evdns.c	/^evdns_add_server_port(evutil_socket_t socket, int flags, evdns_request_callback_fn_type cb, void *user_data)$/;"	f	signature:(evutil_socket_t socket, int flags, evdns_request_callback_fn_type cb, void *user_data)
evdns_add_server_port	include/event2/dns_compat.h	/^struct evdns_server_port *evdns_add_server_port(evutil_socket_t socket, int flags, evdns_request_callback_fn_type callback, void *user_data);$/;"	p	signature:(evutil_socket_t socket, int flags, evdns_request_callback_fn_type callback, void *user_data)
evdns_add_server_port_with_base	evdns.c	/^evdns_add_server_port_with_base(struct event_base *base, evutil_socket_t socket, int flags, evdns_request_callback_fn_type cb, void *user_data)$/;"	f	signature:(struct event_base *base, evutil_socket_t socket, int flags, evdns_request_callback_fn_type cb, void *user_data)
evdns_add_server_port_with_base	include/event2/dns.h	/^struct evdns_server_port *evdns_add_server_port_with_base(struct event_base *base, evutil_socket_t socket, int flags, evdns_request_callback_fn_type callback, void *user_data);$/;"	p	signature:(struct event_base *base, evutil_socket_t socket, int flags, evdns_request_callback_fn_type callback, void *user_data)
evdns_base	evdns.c	/^	struct evdns_base *evdns_base;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::evdns_base	file:	access:public
evdns_base	evdns.c	/^struct evdns_base {$/;"	s	file:
evdns_base::TAILQ_HEAD	evdns.c	/^	TAILQ_HEAD(hosts_list, hosts_entry) hostsdb;$/;"	p	struct:evdns_base	file:	access:public
evdns_base::event_base	evdns.c	/^	struct event_base *event_base;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::event_base	file:	access:public
evdns_base::getaddrinfo_ipv4_answered	evdns.c	/^	int getaddrinfo_ipv4_answered;$/;"	m	struct:evdns_base	file:	access:public
evdns_base::getaddrinfo_ipv4_timeouts	evdns.c	/^	int getaddrinfo_ipv4_timeouts;$/;"	m	struct:evdns_base	file:	access:public
evdns_base::getaddrinfo_ipv6_answered	evdns.c	/^	int getaddrinfo_ipv6_answered;$/;"	m	struct:evdns_base	file:	access:public
evdns_base::getaddrinfo_ipv6_timeouts	evdns.c	/^	int getaddrinfo_ipv6_timeouts;$/;"	m	struct:evdns_base	file:	access:public
evdns_base::global_getaddrinfo_allow_skew	evdns.c	/^	struct timeval global_getaddrinfo_allow_skew;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::timeval	file:	access:public
evdns_base::global_good_nameservers	evdns.c	/^	int global_good_nameservers;$/;"	m	struct:evdns_base	file:	access:public
evdns_base::global_max_nameserver_timeout	evdns.c	/^	int global_max_nameserver_timeout;$/;"	m	struct:evdns_base	file:	access:public
evdns_base::global_max_reissues	evdns.c	/^	int global_max_reissues;  \/* a reissue occurs when we get some errors from the server *\/$/;"	m	struct:evdns_base	file:	access:public
evdns_base::global_max_requests_inflight	evdns.c	/^	int global_max_requests_inflight;$/;"	m	struct:evdns_base	file:	access:public
evdns_base::global_max_retransmits	evdns.c	/^	int global_max_retransmits;  \/* number of times we'll retransmit a request which timed out *\/$/;"	m	struct:evdns_base	file:	access:public
evdns_base::global_nameserver_probe_initial_timeout	evdns.c	/^	struct timeval global_nameserver_probe_initial_timeout;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::timeval	file:	access:public
evdns_base::global_outgoing_address	evdns.c	/^	struct sockaddr_storage global_outgoing_address;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::sockaddr_storage	file:	access:public
evdns_base::global_outgoing_addrlen	evdns.c	/^	ev_socklen_t global_outgoing_addrlen;$/;"	m	struct:evdns_base	file:	access:public
evdns_base::global_randomize_case	evdns.c	/^	int global_randomize_case;$/;"	m	struct:evdns_base	file:	access:public
evdns_base::global_requests_inflight	evdns.c	/^	int global_requests_inflight;$/;"	m	struct:evdns_base	file:	access:public
evdns_base::global_requests_waiting	evdns.c	/^	int global_requests_waiting;$/;"	m	struct:evdns_base	file:	access:public
evdns_base::global_search_state	evdns.c	/^	struct search_state *global_search_state;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::search_state	file:	access:public
evdns_base::global_timeout	evdns.c	/^	struct timeval global_timeout;	\/* 5 seconds by default *\/$/;"	m	struct:evdns_base	typeref:struct:evdns_base::timeval	file:	access:public
evdns_base::lock	evdns.c	/^	void *lock;$/;"	m	struct:evdns_base	file:	access:public
evdns_base::n_req_heads	evdns.c	/^	int n_req_heads;$/;"	m	struct:evdns_base	file:	access:public
evdns_base::req_heads	evdns.c	/^	struct request **req_heads;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::request	file:	access:public
evdns_base::req_waiting_head	evdns.c	/^	struct request *req_waiting_head;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::request	file:	access:public
evdns_base::server_head	evdns.c	/^	struct nameserver *server_head;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::nameserver	file:	access:public
evdns_base_clear_nameservers_and_suspend	evdns.c	/^evdns_base_clear_nameservers_and_suspend(struct evdns_base *base)$/;"	f	signature:(struct evdns_base *base)
evdns_base_clear_nameservers_and_suspend	include/event2/dns.h	/^int evdns_base_clear_nameservers_and_suspend(struct evdns_base *base);$/;"	p	signature:(struct evdns_base *base)
evdns_base_config_windows_nameservers	evdns.c	/^evdns_base_config_windows_nameservers(struct evdns_base *base)$/;"	f	signature:(struct evdns_base *base)
evdns_base_config_windows_nameservers	include/event2/dns.h	/^int evdns_base_config_windows_nameservers(struct evdns_base *);$/;"	p	signature:(struct evdns_base *)
evdns_base_count_nameservers	evdns.c	/^evdns_base_count_nameservers(struct evdns_base *base)$/;"	f	signature:(struct evdns_base *base)
evdns_base_count_nameservers	include/event2/dns.h	/^int evdns_base_count_nameservers(struct evdns_base *base);$/;"	p	signature:(struct evdns_base *base)
evdns_base_free	evdns.c	/^evdns_base_free(struct evdns_base *base, int fail_requests)$/;"	f	signature:(struct evdns_base *base, int fail_requests)
evdns_base_free	include/event2/dns.h	/^void evdns_base_free(struct evdns_base *base, int fail_requests);$/;"	p	signature:(struct evdns_base *base, int fail_requests)
evdns_base_free_and_unlock	evdns.c	/^evdns_base_free_and_unlock(struct evdns_base *base, int fail_requests)$/;"	f	file:	signature:(struct evdns_base *base, int fail_requests)
evdns_base_free_and_unlock	evdns.c	/^static void evdns_base_free_and_unlock(struct evdns_base *base, int fail_requests);$/;"	p	file:	signature:(struct evdns_base *base, int fail_requests)
evdns_base_load_hosts	evdns.c	/^evdns_base_load_hosts(struct evdns_base *base, const char *hosts_fname)$/;"	f	signature:(struct evdns_base *base, const char *hosts_fname)
evdns_base_load_hosts	include/event2/dns.h	/^int evdns_base_load_hosts(struct evdns_base *base, const char *hosts_fname);$/;"	p	signature:(struct evdns_base *base, const char *hosts_fname)
evdns_base_load_hosts_impl	evdns.c	/^evdns_base_load_hosts_impl(struct evdns_base *base, const char *hosts_fname)$/;"	f	file:	signature:(struct evdns_base *base, const char *hosts_fname)
evdns_base_nameserver_add	evdns.c	/^evdns_base_nameserver_add(struct evdns_base *base, unsigned long int address)$/;"	f	signature:(struct evdns_base *base, unsigned long int address)
evdns_base_nameserver_add	include/event2/dns.h	/^int evdns_base_nameserver_add(struct evdns_base *base,$/;"	p	signature:(struct evdns_base *base, unsigned long int address)
evdns_base_nameserver_ip_add	evdns.c	/^evdns_base_nameserver_ip_add(struct evdns_base *base, const char *ip_as_string) {$/;"	f	signature:(struct evdns_base *base, const char *ip_as_string)
evdns_base_nameserver_ip_add	include/event2/dns.h	/^int evdns_base_nameserver_ip_add(struct evdns_base *base,$/;"	p	signature:(struct evdns_base *base, const char *ip_as_string)
evdns_base_nameserver_sockaddr_add	evdns.c	/^evdns_base_nameserver_sockaddr_add(struct evdns_base *base,$/;"	f	signature:(struct evdns_base *base, const struct sockaddr *sa, ev_socklen_t len, unsigned flags)
evdns_base_nameserver_sockaddr_add	include/event2/dns.h	/^evdns_base_nameserver_sockaddr_add(struct evdns_base *base,$/;"	p	signature:(struct evdns_base *base, const struct sockaddr *sa, ev_socklen_t len, unsigned flags)
evdns_base_new	evdns.c	/^evdns_base_new(struct event_base *event_base, int initialize_nameservers)$/;"	f	signature:(struct event_base *event_base, int initialize_nameservers)
evdns_base_new	include/event2/dns.h	/^struct evdns_base * evdns_base_new(struct event_base *event_base, int initialize_nameservers);$/;"	p	signature:(struct event_base *event_base, int initialize_nameservers)
evdns_base_parse_hosts_line	evdns.c	/^evdns_base_parse_hosts_line(struct evdns_base *base, char *line)$/;"	f	file:	signature:(struct evdns_base *base, char *line)
evdns_base_resolv_conf_parse	evdns.c	/^evdns_base_resolv_conf_parse(struct evdns_base *base, int flags, const char *const filename) {$/;"	f	signature:(struct evdns_base *base, int flags, const char *const filename)
evdns_base_resolv_conf_parse	include/event2/dns.h	/^int evdns_base_resolv_conf_parse(struct evdns_base *base, int flags, const char *const filename);$/;"	p	signature:(struct evdns_base *base, int flags, const char *const filename)
evdns_base_resolv_conf_parse_impl	evdns.c	/^evdns_base_resolv_conf_parse_impl(struct evdns_base *base, int flags, const char *const filename) {$/;"	f	file:	signature:(struct evdns_base *base, int flags, const char *const filename)
evdns_base_resolv_conf_parse_impl	evdns.c	/^static int evdns_base_resolv_conf_parse_impl(struct evdns_base *base, int flags, const char *const filename);$/;"	p	file:	signature:(struct evdns_base *base, int flags, const char *const filename)
evdns_base_resolve_ipv4	evdns.c	/^evdns_base_resolve_ipv4(struct evdns_base *base, const char *name, int flags,$/;"	f	signature:(struct evdns_base *base, const char *name, int flags, evdns_callback_type callback, void *ptr)
evdns_base_resolve_ipv4	include/event2/dns.h	/^struct evdns_request *evdns_base_resolve_ipv4(struct evdns_base *base, const char *name, int flags, evdns_callback_type callback, void *ptr);$/;"	p	signature:(struct evdns_base *base, const char *name, int flags, evdns_callback_type callback, void *ptr)
evdns_base_resolve_ipv6	evdns.c	/^evdns_base_resolve_ipv6(struct evdns_base *base,$/;"	f	signature:(struct evdns_base *base, const char *name, int flags, evdns_callback_type callback, void *ptr)
evdns_base_resolve_ipv6	include/event2/dns.h	/^struct evdns_request *evdns_base_resolve_ipv6(struct evdns_base *base, const char *name, int flags, evdns_callback_type callback, void *ptr);$/;"	p	signature:(struct evdns_base *base, const char *name, int flags, evdns_callback_type callback, void *ptr)
evdns_base_resolve_reverse	evdns.c	/^evdns_base_resolve_reverse(struct evdns_base *base, const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr) {$/;"	f	signature:(struct evdns_base *base, const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr)
evdns_base_resolve_reverse	include/event2/dns.h	/^struct evdns_request *evdns_base_resolve_reverse(struct evdns_base *base, const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr);$/;"	p	signature:(struct evdns_base *base, const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr)
evdns_base_resolve_reverse_ipv6	evdns.c	/^evdns_base_resolve_reverse_ipv6(struct evdns_base *base, const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr) {$/;"	f	signature:(struct evdns_base *base, const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr)
evdns_base_resolve_reverse_ipv6	include/event2/dns.h	/^struct evdns_request *evdns_base_resolve_reverse_ipv6(struct evdns_base *base, const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr);$/;"	p	signature:(struct evdns_base *base, const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr)
evdns_base_resume	evdns.c	/^evdns_base_resume(struct evdns_base *base)$/;"	f	signature:(struct evdns_base *base)
evdns_base_resume	include/event2/dns.h	/^int evdns_base_resume(struct evdns_base *base);$/;"	p	signature:(struct evdns_base *base)
evdns_base_search_add	evdns.c	/^evdns_base_search_add(struct evdns_base *base, const char *domain) {$/;"	f	signature:(struct evdns_base *base, const char *domain)
evdns_base_search_add	include/event2/dns.h	/^void evdns_base_search_add(struct evdns_base *base, const char *domain);$/;"	p	signature:(struct evdns_base *base, const char *domain)
evdns_base_search_clear	evdns.c	/^evdns_base_search_clear(struct evdns_base *base)$/;"	f	signature:(struct evdns_base *base)
evdns_base_search_clear	include/event2/dns.h	/^void evdns_base_search_clear(struct evdns_base *base);$/;"	p	signature:(struct evdns_base *base)
evdns_base_search_ndots_set	evdns.c	/^evdns_base_search_ndots_set(struct evdns_base *base, const int ndots) {$/;"	f	signature:(struct evdns_base *base, const int ndots)
evdns_base_search_ndots_set	include/event2/dns.h	/^void evdns_base_search_ndots_set(struct evdns_base *base, const int ndots);$/;"	p	signature:(struct evdns_base *base, const int ndots)
evdns_base_set_max_requests_inflight	evdns.c	/^evdns_base_set_max_requests_inflight(struct evdns_base *base, int maxinflight)$/;"	f	file:	signature:(struct evdns_base *base, int maxinflight)
evdns_base_set_option	evdns.c	/^evdns_base_set_option(struct evdns_base *base,$/;"	f	signature:(struct evdns_base *base, const char *option, const char *val)
evdns_base_set_option	include/event2/dns.h	/^int evdns_base_set_option(struct evdns_base *base, const char *option, const char *val);$/;"	p	signature:(struct evdns_base *base, const char *option, const char *val)
evdns_base_set_option_impl	evdns.c	/^evdns_base_set_option_impl(struct evdns_base *base,$/;"	f	file:	signature:(struct evdns_base *base, const char *option, const char *val, int flags)
evdns_base_set_option_impl	evdns.c	/^static int evdns_base_set_option_impl(struct evdns_base *base,$/;"	p	file:	signature:(struct evdns_base *base, const char *option, const char *val, int flags)
evdns_callback_type	include/event2/dns.h	/^typedef void (*evdns_callback_type) (int result, char type, int count, int ttl, void *addresses, void *arg);$/;"	t
evdns_cancel_request	evdns.c	/^evdns_cancel_request(struct evdns_base *base, struct evdns_request *handle)$/;"	f	signature:(struct evdns_base *base, struct evdns_request *handle)
evdns_cancel_request	include/event2/dns.h	/^void evdns_cancel_request(struct evdns_base *base, struct evdns_request *req);$/;"	p	signature:(struct evdns_base *base, struct evdns_request *req)
evdns_clear_nameservers_and_suspend	evdns.c	/^evdns_clear_nameservers_and_suspend(void)$/;"	f	signature:(void)
evdns_clear_nameservers_and_suspend	include/event2/dns_compat.h	/^int evdns_clear_nameservers_and_suspend(void);$/;"	p	signature:(void)
evdns_close_server_port	evdns.c	/^evdns_close_server_port(struct evdns_server_port *port)$/;"	f	signature:(struct evdns_server_port *port)
evdns_close_server_port	include/event2/dns.h	/^void evdns_close_server_port(struct evdns_server_port *port);$/;"	p	signature:(struct evdns_server_port *port)
evdns_config_windows_nameservers	evdns.c	/^evdns_config_windows_nameservers(void)$/;"	f	signature:(void)
evdns_config_windows_nameservers	include/event2/dns_compat.h	/^int evdns_config_windows_nameservers(void);$/;"	p	signature:(void)
evdns_count_nameservers	evdns.c	/^evdns_count_nameservers(void)$/;"	f	signature:(void)
evdns_count_nameservers	include/event2/dns_compat.h	/^int evdns_count_nameservers(void);$/;"	p	signature:(void)
evdns_debug_log_fn_type	include/event2/dns.h	/^typedef void (*evdns_debug_log_fn_type)(int is_warning, const char *msg);$/;"	t
evdns_err_to_getaddrinfo_err	evdns.c	/^evdns_err_to_getaddrinfo_err(int e1)$/;"	f	file:	signature:(int e1)
evdns_err_to_string	evdns.c	/^evdns_err_to_string(int err)$/;"	f	signature:(int err)
evdns_err_to_string	include/event2/dns.h	/^const char *evdns_err_to_string(int err);$/;"	p	signature:(int err)
evdns_get_default_hosts_filename	evdns.c	/^evdns_get_default_hosts_filename(void)$/;"	f	file:	signature:(void)
evdns_get_global_base	evdns.c	/^evdns_get_global_base(void)$/;"	f	signature:(void)
evdns_get_global_base	include/event2/dns_compat.h	/^struct evdns_base *evdns_get_global_base(void);$/;"	p	signature:(void)
evdns_getaddrinfo	evdns.c	/^evdns_getaddrinfo(struct evdns_base *dns_base,$/;"	f	signature:(struct evdns_base *dns_base, const char *nodename, const char *servname, const struct evutil_addrinfo *hints_in, evdns_getaddrinfo_cb cb, void *arg)
evdns_getaddrinfo	include/event2/dns.h	/^struct evdns_getaddrinfo_request *evdns_getaddrinfo($/;"	p	signature:( struct evdns_base *dns_base, const char *nodename, const char *servname, const struct evutil_addrinfo *hints_in, evdns_getaddrinfo_cb cb, void *arg)
evdns_getaddrinfo_cancel	evdns.c	/^evdns_getaddrinfo_cancel(struct evdns_getaddrinfo_request *data)$/;"	f	signature:(struct evdns_getaddrinfo_request *data)
evdns_getaddrinfo_cancel	include/event2/dns.h	/^void evdns_getaddrinfo_cancel(struct evdns_getaddrinfo_request *req);$/;"	p	signature:(struct evdns_getaddrinfo_request *req)
evdns_getaddrinfo_cb	include/event2/dns.h	/^typedef void (*evdns_getaddrinfo_cb)(int result, struct evutil_addrinfo *res, void *arg);$/;"	t
evdns_getaddrinfo_fn	util-internal.h	/^typedef struct evdns_getaddrinfo_request* (*evdns_getaddrinfo_fn)($/;"	t	typeref:struct:evdns_getaddrinfo_fn
evdns_getaddrinfo_fromhosts	evdns.c	/^evdns_getaddrinfo_fromhosts(struct evdns_base *base,$/;"	f	file:	signature:(struct evdns_base *base, const char *nodename, struct evutil_addrinfo *hints, ev_uint16_t port, struct evutil_addrinfo **res)
evdns_getaddrinfo_gotresolve	evdns.c	/^evdns_getaddrinfo_gotresolve(int result, char type, int count,$/;"	f	file:	signature:(int result, char type, int count, int ttl, void *addresses, void *arg)
evdns_getaddrinfo_impl	evutil.c	/^static evdns_getaddrinfo_fn evdns_getaddrinfo_impl = NULL;$/;"	v	file:
evdns_getaddrinfo_request	evdns.c	/^struct evdns_getaddrinfo_request {$/;"	s	file:
evdns_getaddrinfo_request::cname_result	evdns.c	/^	char *cname_result;$/;"	m	struct:evdns_getaddrinfo_request	file:	access:public
evdns_getaddrinfo_request::evdns_base	evdns.c	/^	struct evdns_base *evdns_base;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::evdns_base	file:	access:public
evdns_getaddrinfo_request::hints	evdns.c	/^	struct evutil_addrinfo hints;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::evutil_addrinfo	file:	access:public
evdns_getaddrinfo_request::ipv4_request	evdns.c	/^	struct getaddrinfo_subrequest ipv4_request;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::getaddrinfo_subrequest	file:	access:public
evdns_getaddrinfo_request::ipv6_request	evdns.c	/^	struct getaddrinfo_subrequest ipv6_request;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::getaddrinfo_subrequest	file:	access:public
evdns_getaddrinfo_request::pending_error	evdns.c	/^	int pending_error;$/;"	m	struct:evdns_getaddrinfo_request	file:	access:public
evdns_getaddrinfo_request::pending_result	evdns.c	/^	struct evutil_addrinfo *pending_result;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::evutil_addrinfo	file:	access:public
evdns_getaddrinfo_request::port	evdns.c	/^	ev_uint16_t port;$/;"	m	struct:evdns_getaddrinfo_request	file:	access:public
evdns_getaddrinfo_request::request_done	evdns.c	/^	unsigned request_done : 1;$/;"	m	struct:evdns_getaddrinfo_request	file:	access:public
evdns_getaddrinfo_request::timeout	evdns.c	/^	struct event timeout;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::event	file:	access:public
evdns_getaddrinfo_request::user_canceled	evdns.c	/^	unsigned user_canceled : 1;$/;"	m	struct:evdns_getaddrinfo_request	file:	access:public
evdns_getaddrinfo_request::user_cb	evdns.c	/^	evdns_getaddrinfo_cb user_cb;$/;"	m	struct:evdns_getaddrinfo_request	file:	access:public
evdns_getaddrinfo_request::user_data	evdns.c	/^	void *user_data;$/;"	m	struct:evdns_getaddrinfo_request	file:	access:public
evdns_getaddrinfo_set_timeout	evdns.c	/^evdns_getaddrinfo_set_timeout(struct evdns_base *evdns_base,$/;"	f	file:	signature:(struct evdns_base *evdns_base, struct evdns_getaddrinfo_request *data)
evdns_getaddrinfo_timeout_cb	evdns.c	/^evdns_getaddrinfo_timeout_cb(evutil_socket_t fd, short what, void *ptr)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *ptr)
evdns_init	evdns.c	/^evdns_init(void)$/;"	f	signature:(void)
evdns_init	include/event2/dns_compat.h	/^int evdns_init(void);$/;"	p	signature:(void)
evdns_log_fn	evdns.c	/^static evdns_debug_log_fn_type evdns_log_fn = NULL;$/;"	v	file:
evdns_nameserver_add	evdns.c	/^evdns_nameserver_add(unsigned long int address) {$/;"	f	signature:(unsigned long int address)
evdns_nameserver_add	include/event2/dns_compat.h	/^int evdns_nameserver_add(unsigned long int address);$/;"	p	signature:(unsigned long int address)
evdns_nameserver_free	evdns.c	/^evdns_nameserver_free(struct nameserver *server)$/;"	f	file:	signature:(struct nameserver *server)
evdns_nameserver_ip_add	evdns.c	/^evdns_nameserver_ip_add(const char *ip_as_string) {$/;"	f	signature:(const char *ip_as_string)
evdns_nameserver_ip_add	include/event2/dns_compat.h	/^int evdns_nameserver_ip_add(const char *ip_as_string);$/;"	p	signature:(const char *ip_as_string)
evdns_nameserver_ip_add_line	evdns.c	/^evdns_nameserver_ip_add_line(struct evdns_base *base, const char *ips) {$/;"	f	file:	signature:(struct evdns_base *base, const char *ips)
evdns_request	evdns.c	/^struct evdns_request {$/;"	s	file:
evdns_request::base	evdns.c	/^	struct evdns_base *base;$/;"	m	struct:evdns_request	typeref:struct:evdns_request::evdns_base	file:	access:public
evdns_request::current_req	evdns.c	/^	struct request *current_req;$/;"	m	struct:evdns_request	typeref:struct:evdns_request::request	file:	access:public
evdns_request::pending_cb	evdns.c	/^	int pending_cb; \/* Waiting for its callback to be invoked; not$/;"	m	struct:evdns_request	file:	access:public
evdns_request::search_flags	evdns.c	/^	int search_flags;$/;"	m	struct:evdns_request	file:	access:public
evdns_request::search_index	evdns.c	/^	int search_index;$/;"	m	struct:evdns_request	file:	access:public
evdns_request::search_origname	evdns.c	/^	char *search_origname;	\/* needs to be free()ed *\/$/;"	m	struct:evdns_request	file:	access:public
evdns_request::search_state	evdns.c	/^	struct search_state *search_state;$/;"	m	struct:evdns_request	typeref:struct:evdns_request::search_state	file:	access:public
evdns_request_callback_fn_type	include/event2/dns.h	/^typedef void (*evdns_request_callback_fn_type)(struct evdns_server_request *, void *);$/;"	t
evdns_request_data_build	evdns.c	/^evdns_request_data_build(const char *const name, const size_t name_len,$/;"	f	file:	signature:(const char *const name, const size_t name_len, const u16 trans_id, const u16 type, const u16 class, u8 *const buf, size_t buf_len)
evdns_request_insert	evdns.c	/^evdns_request_insert(struct request *req, struct request **head) {$/;"	f	file:	signature:(struct request *req, struct request **head)
evdns_request_insert	evdns.c	/^static void evdns_request_insert(struct request *req, struct request **head);$/;"	p	file:	signature:(struct request *req, struct request **head)
evdns_request_len	evdns.c	/^evdns_request_len(const size_t name_len) {$/;"	f	file:	signature:(const size_t name_len)
evdns_request_remove	evdns.c	/^evdns_request_remove(struct request *req, struct request **head)$/;"	f	file:	signature:(struct request *req, struct request **head)
evdns_request_remove	evdns.c	/^static void evdns_request_remove(struct request *req, struct request **head);$/;"	p	file:	signature:(struct request *req, struct request **head)
evdns_request_timeout_callback	evdns.c	/^evdns_request_timeout_callback(evutil_socket_t fd, short events, void *arg) {$/;"	f	file:	signature:(evutil_socket_t fd, short events, void *arg)
evdns_request_transmit	evdns.c	/^evdns_request_transmit(struct request *req) {$/;"	f	file:	signature:(struct request *req)
evdns_request_transmit	evdns.c	/^static int evdns_request_transmit(struct request *req);$/;"	p	file:	signature:(struct request *req)
evdns_request_transmit_to	evdns.c	/^evdns_request_transmit_to(struct request *req, struct nameserver *server) {$/;"	f	file:	signature:(struct request *req, struct nameserver *server)
evdns_requests_pump_waiting_queue	evdns.c	/^evdns_requests_pump_waiting_queue(struct evdns_base *base) {$/;"	f	file:	signature:(struct evdns_base *base)
evdns_requests_pump_waiting_queue	evdns.c	/^static void evdns_requests_pump_waiting_queue(struct evdns_base *base);$/;"	p	file:	signature:(struct evdns_base *base)
evdns_resolv_conf_parse	evdns.c	/^evdns_resolv_conf_parse(int flags, const char *const filename) {$/;"	f	signature:(int flags, const char *const filename)
evdns_resolv_conf_parse	include/event2/dns_compat.h	/^int evdns_resolv_conf_parse(int flags, const char *const filename);$/;"	p	signature:(int flags, const char *const filename)
evdns_resolv_set_defaults	evdns.c	/^evdns_resolv_set_defaults(struct evdns_base *base, int flags) {$/;"	f	file:	signature:(struct evdns_base *base, int flags)
evdns_resolve_ipv4	evdns.c	/^int evdns_resolve_ipv4(const char *name, int flags,$/;"	f	signature:(const char *name, int flags, evdns_callback_type callback, void *ptr)
evdns_resolve_ipv4	include/event2/dns_compat.h	/^int evdns_resolve_ipv4(const char *name, int flags, evdns_callback_type callback, void *ptr);$/;"	p	signature:(const char *name, int flags, evdns_callback_type callback, void *ptr)
evdns_resolve_ipv6	evdns.c	/^int evdns_resolve_ipv6(const char *name, int flags,$/;"	f	signature:(const char *name, int flags, evdns_callback_type callback, void *ptr)
evdns_resolve_ipv6	include/event2/dns_compat.h	/^int evdns_resolve_ipv6(const char *name, int flags, evdns_callback_type callback, void *ptr);$/;"	p	signature:(const char *name, int flags, evdns_callback_type callback, void *ptr)
evdns_resolve_reverse	evdns.c	/^int evdns_resolve_reverse(const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr) {$/;"	f	signature:(const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr)
evdns_resolve_reverse	include/event2/dns_compat.h	/^int evdns_resolve_reverse(const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr);$/;"	p	signature:(const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr)
evdns_resolve_reverse_ipv6	evdns.c	/^int evdns_resolve_reverse_ipv6(const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr) {$/;"	f	signature:(const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr)
evdns_resolve_reverse_ipv6	include/event2/dns_compat.h	/^int evdns_resolve_reverse_ipv6(const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr);$/;"	p	signature:(const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr)
evdns_result_is_answer	evdns.c	/^evdns_result_is_answer(int result)$/;"	f	file:	signature:(int result)
evdns_resume	evdns.c	/^evdns_resume(void)$/;"	f	signature:(void)
evdns_resume	include/event2/dns_compat.h	/^int evdns_resume(void);$/;"	p	signature:(void)
evdns_search_add	evdns.c	/^evdns_search_add(const char *domain) {$/;"	f	signature:(const char *domain)
evdns_search_add	include/event2/dns_compat.h	/^void evdns_search_add(const char *domain);$/;"	p	signature:(const char *domain)
evdns_search_clear	evdns.c	/^evdns_search_clear(void) {$/;"	f	signature:(void)
evdns_search_clear	include/event2/dns_compat.h	/^void evdns_search_clear(void);$/;"	p	signature:(void)
evdns_search_ndots_set	evdns.c	/^evdns_search_ndots_set(const int ndots) {$/;"	f	signature:(const int ndots)
evdns_search_ndots_set	include/event2/dns_compat.h	/^void evdns_search_ndots_set(const int ndots);$/;"	p	signature:(const int ndots)
evdns_server_callback	sample/dns-example.c	/^evdns_server_callback(struct evdns_server_request *req, void *data)$/;"	f	file:	signature:(struct evdns_server_request *req, void *data)
evdns_server_port	evdns.c	/^struct evdns_server_port {$/;"	s	file:
evdns_server_port::choked	evdns.c	/^	char choked; \/* Are we currently blocked from writing? *\/$/;"	m	struct:evdns_server_port	file:	access:public
evdns_server_port::closing	evdns.c	/^	char closing; \/* Are we trying to close this port, pending writes? *\/$/;"	m	struct:evdns_server_port	file:	access:public
evdns_server_port::event	evdns.c	/^	struct event event; \/* Read\/write event *\/$/;"	m	struct:evdns_server_port	typeref:struct:evdns_server_port::event	file:	access:public
evdns_server_port::event_base	evdns.c	/^	struct event_base *event_base;$/;"	m	struct:evdns_server_port	typeref:struct:evdns_server_port::event_base	file:	access:public
evdns_server_port::lock	evdns.c	/^	void *lock;$/;"	m	struct:evdns_server_port	file:	access:public
evdns_server_port::pending_replies	evdns.c	/^	struct server_request *pending_replies;$/;"	m	struct:evdns_server_port	typeref:struct:evdns_server_port::server_request	file:	access:public
evdns_server_port::refcnt	evdns.c	/^	int refcnt; \/* reference count. *\/$/;"	m	struct:evdns_server_port	file:	access:public
evdns_server_port::socket	evdns.c	/^	evutil_socket_t socket; \/* socket we use to read queries and write replies. *\/$/;"	m	struct:evdns_server_port	file:	access:public
evdns_server_port::user_callback	evdns.c	/^	evdns_request_callback_fn_type user_callback; \/* Fn to handle requests *\/$/;"	m	struct:evdns_server_port	file:	access:public
evdns_server_port::user_data	evdns.c	/^	void *user_data; \/* Opaque pointer passed to user_callback *\/$/;"	m	struct:evdns_server_port	file:	access:public
evdns_server_question	include/event2/dns_struct.h	/^struct evdns_server_question {$/;"	s
evdns_server_question::dns_question_class	include/event2/dns_struct.h	/^	int dns_question_class;$/;"	m	struct:evdns_server_question	access:public
evdns_server_question::name	include/event2/dns_struct.h	/^	char name[1];$/;"	m	struct:evdns_server_question	access:public
evdns_server_question::type	include/event2/dns_struct.h	/^	int type;$/;"	m	struct:evdns_server_question	access:public
evdns_server_request	include/event2/dns_struct.h	/^struct evdns_server_request {$/;"	s
evdns_server_request::flags	include/event2/dns_struct.h	/^	int flags;$/;"	m	struct:evdns_server_request	access:public
evdns_server_request::nquestions	include/event2/dns_struct.h	/^	int nquestions;$/;"	m	struct:evdns_server_request	access:public
evdns_server_request::questions	include/event2/dns_struct.h	/^	struct evdns_server_question **questions;$/;"	m	struct:evdns_server_request	typeref:struct:evdns_server_request::evdns_server_question	access:public
evdns_server_request_add_a_reply	evdns.c	/^evdns_server_request_add_a_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)$/;"	f	signature:(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)
evdns_server_request_add_a_reply	include/event2/dns.h	/^int evdns_server_request_add_a_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl);$/;"	p	signature:(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)
evdns_server_request_add_aaaa_reply	evdns.c	/^evdns_server_request_add_aaaa_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)$/;"	f	signature:(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)
evdns_server_request_add_aaaa_reply	include/event2/dns.h	/^int evdns_server_request_add_aaaa_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl);$/;"	p	signature:(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)
evdns_server_request_add_cname_reply	evdns.c	/^evdns_server_request_add_cname_reply(struct evdns_server_request *req, const char *name, const char *cname, int ttl)$/;"	f	signature:(struct evdns_server_request *req, const char *name, const char *cname, int ttl)
evdns_server_request_add_cname_reply	include/event2/dns.h	/^int evdns_server_request_add_cname_reply(struct evdns_server_request *req, const char *name, const char *cname, int ttl);$/;"	p	signature:(struct evdns_server_request *req, const char *name, const char *cname, int ttl)
evdns_server_request_add_ptr_reply	evdns.c	/^evdns_server_request_add_ptr_reply(struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl)$/;"	f	signature:(struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl)
evdns_server_request_add_ptr_reply	include/event2/dns.h	/^int evdns_server_request_add_ptr_reply(struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl);$/;"	p	signature:(struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl)
evdns_server_request_add_reply	evdns.c	/^evdns_server_request_add_reply(struct evdns_server_request *_req, int section, const char *name, int type, int class, int ttl, int datalen, int is_name, const char *data)$/;"	f	signature:(struct evdns_server_request *_req, int section, const char *name, int type, int class, int ttl, int datalen, int is_name, const char *data)
evdns_server_request_add_reply	include/event2/dns.h	/^int evdns_server_request_add_reply(struct evdns_server_request *req, int section, const char *name, int type, int dns_class, int ttl, int datalen, int is_name, const char *data);$/;"	p	signature:(struct evdns_server_request *req, int section, const char *name, int type, int dns_class, int ttl, int datalen, int is_name, const char *data)
evdns_server_request_drop	evdns.c	/^evdns_server_request_drop(struct evdns_server_request *_req)$/;"	f	signature:(struct evdns_server_request *_req)
evdns_server_request_drop	include/event2/dns.h	/^int evdns_server_request_drop(struct evdns_server_request *req);$/;"	p	signature:(struct evdns_server_request *req)
evdns_server_request_format_response	evdns.c	/^evdns_server_request_format_response(struct server_request *req, int err)$/;"	f	file:	signature:(struct server_request *req, int err)
evdns_server_request_get_requesting_addr	evdns.c	/^evdns_server_request_get_requesting_addr(struct evdns_server_request *_req, struct sockaddr *sa, int addr_len)$/;"	f	signature:(struct evdns_server_request *_req, struct sockaddr *sa, int addr_len)
evdns_server_request_get_requesting_addr	include/event2/dns.h	/^int evdns_server_request_get_requesting_addr(struct evdns_server_request *_req, struct sockaddr *sa, int addr_len);$/;"	p	signature:(struct evdns_server_request *_req, struct sockaddr *sa, int addr_len)
evdns_server_request_respond	evdns.c	/^evdns_server_request_respond(struct evdns_server_request *_req, int err)$/;"	f	signature:(struct evdns_server_request *_req, int err)
evdns_server_request_respond	include/event2/dns.h	/^int evdns_server_request_respond(struct evdns_server_request *req, int err);$/;"	p	signature:(struct evdns_server_request *req, int err)
evdns_server_request_set_flags	evdns.c	/^evdns_server_request_set_flags(struct evdns_server_request *exreq, int flags)$/;"	f	signature:(struct evdns_server_request *exreq, int flags)
evdns_server_request_set_flags	include/event2/dns.h	/^void evdns_server_request_set_flags(struct evdns_server_request *req, int flags);$/;"	p	signature:(struct evdns_server_request *req, int flags)
evdns_set_log_fn	evdns.c	/^evdns_set_log_fn(evdns_debug_log_fn_type fn)$/;"	f	signature:(evdns_debug_log_fn_type fn)
evdns_set_log_fn	include/event2/dns.h	/^void evdns_set_log_fn(evdns_debug_log_fn_type fn);$/;"	p	signature:(evdns_debug_log_fn_type fn)
evdns_set_option	evdns.c	/^evdns_set_option(const char *option, const char *val, int flags)$/;"	f	signature:(const char *option, const char *val, int flags)
evdns_set_option	include/event2/dns_compat.h	/^int evdns_set_option(const char *option, const char *val, int flags);$/;"	p	signature:(const char *option, const char *val, int flags)
evdns_set_random_bytes_fn	evdns.c	/^evdns_set_random_bytes_fn(void (*fn)(char *, size_t))$/;"	f	signature:(void (*fn)(char *, size_t))
evdns_set_random_bytes_fn	include/event2/dns.h	/^void evdns_set_random_bytes_fn(void (*fn)(char *, size_t));$/;"	p	signature:(void (*fn)(char *, size_t))
evdns_set_transaction_id_fn	evdns.c	/^evdns_set_transaction_id_fn(ev_uint16_t (*fn)(void))$/;"	f	signature:(ev_uint16_t (fn)void))
evdns_set_transaction_id_fn	include/event2/dns.h	/^void evdns_set_transaction_id_fn(ev_uint16_t (*fn)(void));$/;"	p	signature:(ev_uint16_t (fn)void))
evdns_shutdown	evdns.c	/^evdns_shutdown(int fail_requests)$/;"	f	signature:(int fail_requests)
evdns_shutdown	include/event2/dns_compat.h	/^void evdns_shutdown(int fail_requests);$/;"	p	signature:(int fail_requests)
evdns_transmit	evdns.c	/^evdns_transmit(struct evdns_base *base) {$/;"	f	file:	signature:(struct evdns_base *base)
evdns_transmit	evdns.c	/^static int evdns_transmit(struct evdns_base *base);$/;"	p	file:	signature:(struct evdns_base *base)
event	evdns.c	/^	struct event event; \/* Read\/write event *\/$/;"	m	struct:evdns_server_port	typeref:struct:evdns_server_port::event	file:	access:public
event	evdns.c	/^	struct event event;$/;"	m	struct:nameserver	typeref:struct:nameserver::event	file:	access:public
event	evthread_win32.c	/^	HANDLE event;$/;"	m	struct:evthread_win32_cond	file:	access:public
event	include/event2/event.h	/^struct event$/;"	s
event	include/event2/event_struct.h	/^struct event {$/;"	s
event::__anon2::ev_next_with_common_timeout	include/event2/event_struct.h	/^		TAILQ_ENTRY(event) ev_next_with_common_timeout;$/;"	m	union:event::__anon2	access:public
event::__anon2::min_heap_idx	include/event2/event_struct.h	/^		int min_heap_idx;$/;"	m	union:event::__anon2	access:public
event::__anon3::__anon4::ev_io_next	include/event2/event_struct.h	/^			TAILQ_ENTRY(event) ev_io_next;$/;"	m	struct:event::__anon3::__anon4	access:public
event::__anon3::__anon4::ev_timeout	include/event2/event_struct.h	/^			struct timeval ev_timeout;$/;"	m	struct:event::__anon3::__anon4	typeref:struct:event::__anon3::__anon4::timeval	access:public
event::__anon3::__anon5::ev_ncalls	include/event2/event_struct.h	/^			short ev_ncalls;$/;"	m	struct:event::__anon3::__anon5	access:public
event::__anon3::__anon5::ev_pncalls	include/event2/event_struct.h	/^			short *ev_pncalls;$/;"	m	struct:event::__anon3::__anon5	access:public
event::__anon3::__anon5::ev_signal_next	include/event2/event_struct.h	/^			TAILQ_ENTRY(event) ev_signal_next;$/;"	m	struct:event::__anon3::__anon5	access:public
event::__anon3::ev_io	include/event2/event_struct.h	/^		} ev_io;$/;"	m	union:event::__anon3	typeref:struct:event::__anon3::__anon4	access:public
event::__anon3::ev_signal	include/event2/event_struct.h	/^		} ev_signal;$/;"	m	union:event::__anon3	typeref:struct:event::__anon3::__anon5	access:public
event::_ev	include/event2/event_struct.h	/^	} _ev;$/;"	m	struct:event	typeref:union:event::__anon3	access:public
event::ev_active_next	include/event2/event_struct.h	/^	TAILQ_ENTRY(event) ev_active_next;$/;"	m	struct:event	access:public
event::ev_arg	include/event2/event_struct.h	/^	void *ev_arg;$/;"	m	struct:event	access:public
event::ev_base	include/event2/event_struct.h	/^	struct event_base *ev_base;$/;"	m	struct:event	typeref:struct:event::event_base	access:public
event::ev_callback	include/event2/event_struct.h	/^	void (*ev_callback)(evutil_socket_t, short, void *arg);$/;"	m	struct:event	access:public
event::ev_closure	include/event2/event_struct.h	/^	ev_uint8_t ev_closure;$/;"	m	struct:event	access:public
event::ev_events	include/event2/event_struct.h	/^	short ev_events;$/;"	m	struct:event	access:public
event::ev_fd	include/event2/event_struct.h	/^	evutil_socket_t ev_fd;$/;"	m	struct:event	access:public
event::ev_flags	include/event2/event_struct.h	/^	short ev_flags;$/;"	m	struct:event	access:public
event::ev_next	include/event2/event_struct.h	/^	TAILQ_ENTRY(event) ev_next;$/;"	m	struct:event	access:public
event::ev_pri	include/event2/event_struct.h	/^	ev_uint8_t ev_pri;	\/* smaller numbers are higher priority *\/$/;"	m	struct:event	access:public
event::ev_res	include/event2/event_struct.h	/^	short ev_res;		\/* result passed to event callback *\/$/;"	m	struct:event	access:public
event::ev_timeout	include/event2/event_struct.h	/^	struct timeval ev_timeout;$/;"	m	struct:event	typeref:struct:event::timeval	access:public
event::ev_timeout_pos	include/event2/event_struct.h	/^	} ev_timeout_pos;$/;"	m	struct:event	typeref:union:event::__anon2	access:public
event_active	event.c	/^event_active(struct event *ev, int res, short ncalls)$/;"	f	signature:(struct event *ev, int res, short ncalls)
event_active	include/event2/event.h	/^void event_active(struct event *ev, int res, short ncalls);$/;"	p	signature:(struct event *ev, int res, short ncalls)
event_active_nolock	event-internal.h	/^void event_active_nolock(struct event *ev, int res, short count);$/;"	p	signature:(struct event *ev, int res, short count)
event_active_nolock	event.c	/^event_active_nolock(struct event *ev, int res, short ncalls)$/;"	f	signature:(struct event *ev, int res, short ncalls)
event_add	event.c	/^event_add(struct event *ev, const struct timeval *tv)$/;"	f	signature:(struct event *ev, const struct timeval *tv)
event_add	include/event2/event.h	/^int event_add(struct event *ev, const struct timeval *timeout);$/;"	p	signature:(struct event *ev, const struct timeval *timeout)
event_add_internal	event.c	/^event_add_internal(struct event *ev, const struct timeval *tv,$/;"	f	file:	signature:(struct event *ev, const struct timeval *tv, int tv_is_absolute)
event_add_internal	event.c	/^static inline int event_add_internal(struct event *ev,$/;"	p	file:	signature:(struct event *ev, const struct timeval *tv, int tv_is_absolute)
event_added	listener.c	/^	unsigned event_added : 1;$/;"	m	struct:evconnlistener_iocp	file:	access:public
event_assign	event.c	/^event_assign(struct event *ev, struct event_base *base, evutil_socket_t fd, short events, void (*callback)(evutil_socket_t, short, void *), void *arg)$/;"	f	signature:(struct event *ev, struct event_base *base, evutil_socket_t fd, short events, void (*callback)(evutil_socket_t, short, void *), void *arg)
event_assign	include/event2/event.h	/^int event_assign(struct event *, struct event_base *, evutil_socket_t, short, event_callback_fn, void *);$/;"	p	signature:(struct event *, struct event_base *, evutil_socket_t, short, event_callback_fn, void *)
event_base	evdns.c	/^	struct event_base *event_base;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::event_base	file:	access:public
event_base	evdns.c	/^	struct event_base *event_base;$/;"	m	struct:evdns_server_port	typeref:struct:evdns_server_port::event_base	file:	access:public
event_base	event-internal.h	/^struct event_base {$/;"	s
event_base	include/event2/event.h	/^struct event_base$/;"	s
event_base	listener.c	/^	struct event_base *event_base;$/;"	m	struct:evconnlistener_iocp	typeref:struct:evconnlistener_iocp::event_base	file:	access:public
event_base::activequeues	event-internal.h	/^	struct event_list *activequeues;$/;"	m	struct:event_base	typeref:struct:event_base::event_list	access:public
event_base::changelist	event-internal.h	/^	struct event_changelist changelist;$/;"	m	struct:event_base	typeref:struct:event_base::event_changelist	access:public
event_base::common_timeout_queues	event-internal.h	/^	struct common_timeout_list **common_timeout_queues;$/;"	m	struct:event_base	typeref:struct:event_base::common_timeout_list	access:public
event_base::current_event	event-internal.h	/^	struct event *current_event;$/;"	m	struct:event_base	typeref:struct:event_base::event	access:public
event_base::current_event_cond	event-internal.h	/^	void *current_event_cond;$/;"	m	struct:event_base	access:public
event_base::current_event_waiters	event-internal.h	/^	int current_event_waiters;$/;"	m	struct:event_base	access:public
event_base::defer_queue	event-internal.h	/^	struct deferred_cb_queue defer_queue;$/;"	m	struct:event_base	typeref:struct:event_base::deferred_cb_queue	access:public
event_base::evbase	event-internal.h	/^	void *evbase;$/;"	m	struct:event_base	access:public
event_base::event_break	event-internal.h	/^	int event_break;$/;"	m	struct:event_base	access:public
event_base::event_continue	event-internal.h	/^	int event_continue;$/;"	m	struct:event_base	access:public
event_base::event_count	event-internal.h	/^	int event_count;$/;"	m	struct:event_base	access:public
event_base::event_count_active	event-internal.h	/^	int event_count_active;$/;"	m	struct:event_base	access:public
event_base::event_gotterm	event-internal.h	/^	int event_gotterm;$/;"	m	struct:event_base	access:public
event_base::event_running_priority	event-internal.h	/^	int event_running_priority;$/;"	m	struct:event_base	access:public
event_base::event_tv	event-internal.h	/^	struct timeval event_tv;$/;"	m	struct:event_base	typeref:struct:event_base::timeval	access:public
event_base::eventqueue	event-internal.h	/^	struct event_list eventqueue;$/;"	m	struct:event_base	typeref:struct:event_base::event_list	access:public
event_base::evsel	event-internal.h	/^	const struct eventop *evsel;$/;"	m	struct:event_base	typeref:struct:event_base::eventop	access:public
event_base::evsigsel	event-internal.h	/^	const struct eventop *evsigsel;$/;"	m	struct:event_base	typeref:struct:event_base::eventop	access:public
event_base::flags	event-internal.h	/^	enum event_base_config_flag flags;$/;"	m	struct:event_base	typeref:enum:event_base::event_base_config_flag	access:public
event_base::io	event-internal.h	/^	struct event_io_map io;$/;"	m	struct:event_base	typeref:struct:event_base::event_io_map	access:public
event_base::iocp	event-internal.h	/^	struct event_iocp_port *iocp;$/;"	m	struct:event_base	typeref:struct:event_base::event_iocp_port	access:public
event_base::is_notify_pending	event-internal.h	/^	int is_notify_pending;$/;"	m	struct:event_base	access:public
event_base::last_updated_clock_diff	event-internal.h	/^	time_t last_updated_clock_diff;$/;"	m	struct:event_base	access:public
event_base::n_common_timeouts	event-internal.h	/^	int n_common_timeouts;$/;"	m	struct:event_base	access:public
event_base::n_common_timeouts_allocated	event-internal.h	/^	int n_common_timeouts_allocated;$/;"	m	struct:event_base	access:public
event_base::nactivequeues	event-internal.h	/^	int nactivequeues;$/;"	m	struct:event_base	access:public
event_base::running_loop	event-internal.h	/^	int running_loop;$/;"	m	struct:event_base	access:public
event_base::sig	event-internal.h	/^	struct evsig_info sig;$/;"	m	struct:event_base	typeref:struct:event_base::evsig_info	access:public
event_base::sigmap	event-internal.h	/^	struct event_signal_map sigmap;$/;"	m	struct:event_base	typeref:struct:event_base::event_signal_map	access:public
event_base::th_base_lock	event-internal.h	/^	void *th_base_lock;$/;"	m	struct:event_base	access:public
event_base::th_notify	event-internal.h	/^	struct event th_notify;$/;"	m	struct:event_base	typeref:struct:event_base::event	access:public
event_base::th_notify_fd	event-internal.h	/^	evutil_socket_t th_notify_fd[2];$/;"	m	struct:event_base	access:public
event_base::th_notify_fn	event-internal.h	/^	int (*th_notify_fn)(struct event_base *base);$/;"	m	struct:event_base	access:public
event_base::th_owner_id	event-internal.h	/^	unsigned long th_owner_id;$/;"	m	struct:event_base	access:public
event_base::timeheap	event-internal.h	/^	struct min_heap timeheap;$/;"	m	struct:event_base	typeref:struct:event_base::min_heap	access:public
event_base::tv_cache	event-internal.h	/^	struct timeval tv_cache;$/;"	m	struct:event_base	typeref:struct:event_base::timeval	access:public
event_base::tv_clock_diff	event-internal.h	/^	struct timeval tv_clock_diff;$/;"	m	struct:event_base	typeref:struct:event_base::timeval	access:public
event_base::virtual_event_count	event-internal.h	/^	int virtual_event_count;$/;"	m	struct:event_base	access:public
event_base_add_virtual	event-internal.h	/^void event_base_add_virtual(struct event_base *base);$/;"	p	signature:(struct event_base *base)
event_base_add_virtual	event.c	/^event_base_add_virtual(struct event_base *base)$/;"	f	signature:(struct event_base *base)
event_base_assert_ok	event-internal.h	/^void event_base_assert_ok(struct event_base *base);$/;"	p	signature:(struct event_base *base)
event_base_assert_ok	event.c	/^event_base_assert_ok(struct event_base *base)$/;"	f	signature:(struct event_base *base)
event_base_config_flag	include/event2/event.h	/^enum event_base_config_flag {$/;"	g
event_base_del_virtual	event-internal.h	/^void event_base_del_virtual(struct event_base *base);$/;"	p	signature:(struct event_base *base)
event_base_del_virtual	event.c	/^event_base_del_virtual(struct event_base *base)$/;"	f	signature:(struct event_base *base)
event_base_dispatch	event.c	/^event_base_dispatch(struct event_base *event_base)$/;"	f	signature:(struct event_base *event_base)
event_base_dispatch	include/event2/event.h	/^int event_base_dispatch(struct event_base *);$/;"	p	signature:(struct event_base *)
event_base_dump_events	event.c	/^event_base_dump_events(struct event_base *base, FILE *output)$/;"	f	signature:(struct event_base *base, FILE *output)
event_base_dump_events	include/event2/event.h	/^void event_base_dump_events(struct event_base *, FILE *);$/;"	p	signature:(struct event_base *, FILE *)
event_base_free	event.c	/^event_base_free(struct event_base *base)$/;"	f	signature:(struct event_base *base)
event_base_free	include/event2/event.h	/^void event_base_free(struct event_base *);$/;"	p	signature:(struct event_base *)
event_base_get_deferred_cb_queue	defer-internal.h	/^struct deferred_cb_queue *event_base_get_deferred_cb_queue(struct event_base *);$/;"	p	signature:(struct event_base *)
event_base_get_deferred_cb_queue	event.c	/^event_base_get_deferred_cb_queue(struct event_base *base)$/;"	f	signature:(struct event_base *base)
event_base_get_features	event.c	/^event_base_get_features(const struct event_base *base)$/;"	f	signature:(const struct event_base *base)
event_base_get_features	include/event2/event.h	/^int event_base_get_features(const struct event_base *base);$/;"	p	signature:(const struct event_base *base)
event_base_get_iocp	event_iocp.c	/^event_base_get_iocp(struct event_base *base)$/;"	f	signature:(struct event_base *base)
event_base_get_iocp	iocp-internal.h	/^struct event_iocp_port *event_base_get_iocp(struct event_base *base);$/;"	p	signature:(struct event_base *base)
event_base_get_method	event.c	/^event_base_get_method(const struct event_base *base)$/;"	f	signature:(const struct event_base *base)
event_base_get_method	include/event2/event.h	/^const char *event_base_get_method(const struct event_base *);$/;"	p	signature:(const struct event_base *)
event_base_gettimeofday_cached	event.c	/^event_base_gettimeofday_cached(struct event_base *base, struct timeval *tv)$/;"	f	signature:(struct event_base *base, struct timeval *tv)
event_base_gettimeofday_cached	include/event2/event.h	/^int event_base_gettimeofday_cached(struct event_base *base,$/;"	p	signature:(struct event_base *base, struct timeval *tv)
event_base_got_break	event.c	/^event_base_got_break(struct event_base *event_base)$/;"	f	signature:(struct event_base *event_base)
event_base_got_break	include/event2/event.h	/^int event_base_got_break(struct event_base *);$/;"	p	signature:(struct event_base *)
event_base_got_exit	event.c	/^event_base_got_exit(struct event_base *event_base)$/;"	f	signature:(struct event_base *event_base)
event_base_got_exit	include/event2/event.h	/^int event_base_got_exit(struct event_base *);$/;"	p	signature:(struct event_base *)
event_base_init_common_timeout	event.c	/^event_base_init_common_timeout(struct event_base *base,$/;"	f	signature:(struct event_base *base, const struct timeval *duration)
event_base_init_common_timeout	include/event2/event.h	/^const struct timeval *event_base_init_common_timeout(struct event_base *base,$/;"	p	signature:(struct event_base *base, const struct timeval *duration)
event_base_loop	event.c	/^event_base_loop(struct event_base *base, int flags)$/;"	f	signature:(struct event_base *base, int flags)
event_base_loop	include/event2/event.h	/^int event_base_loop(struct event_base *, int);$/;"	p	signature:(struct event_base *, int)
event_base_loopbreak	event.c	/^event_base_loopbreak(struct event_base *event_base)$/;"	f	signature:(struct event_base *event_base)
event_base_loopbreak	include/event2/event.h	/^int event_base_loopbreak(struct event_base *);$/;"	p	signature:(struct event_base *)
event_base_loopexit	event.c	/^event_base_loopexit(struct event_base *event_base, const struct timeval *tv)$/;"	f	signature:(struct event_base *event_base, const struct timeval *tv)
event_base_loopexit	include/event2/event.h	/^int event_base_loopexit(struct event_base *, const struct timeval *);$/;"	p	signature:(struct event_base *, const struct timeval *)
event_base_new	event.c	/^event_base_new(void)$/;"	f	signature:(void)
event_base_new	include/event2/event.h	/^struct event_base *event_base_new(void);$/;"	p	signature:(void)
event_base_new_with_config	event.c	/^event_base_new_with_config(const struct event_config *cfg)$/;"	f	signature:(const struct event_config *cfg)
event_base_new_with_config	include/event2/event.h	/^struct event_base *event_base_new_with_config(const struct event_config *);$/;"	p	signature:(const struct event_config *)
event_base_once	event.c	/^event_base_once(struct event_base *base, evutil_socket_t fd, short events,$/;"	f	signature:(struct event_base *base, evutil_socket_t fd, short events, void (*callback)(evutil_socket_t, short, void *), void *arg, const struct timeval *tv)
event_base_once	include/event2/event.h	/^int event_base_once(struct event_base *, evutil_socket_t, short, event_callback_fn, void *, const struct timeval *);$/;"	p	signature:(struct event_base *, evutil_socket_t, short, event_callback_fn, void *, const struct timeval *)
event_base_priority_init	event.c	/^event_base_priority_init(struct event_base *base, int npriorities)$/;"	f	signature:(struct event_base *base, int npriorities)
event_base_priority_init	include/event2/event.h	/^int	event_base_priority_init(struct event_base *, int);$/;"	p	signature:(struct event_base *, int)
event_base_set	event.c	/^event_base_set(struct event_base *base, struct event *ev)$/;"	f	signature:(struct event_base *base, struct event *ev)
event_base_set	include/event2/event.h	/^int event_base_set(struct event_base *, struct event *);$/;"	p	signature:(struct event_base *, struct event *)
event_base_start_iocp	event.c	/^event_base_start_iocp(struct event_base *base, int n_cpus)$/;"	f	signature:(struct event_base *base, int n_cpus)
event_base_start_iocp	iocp-internal.h	/^int event_base_start_iocp(struct event_base *base, int n_cpus);$/;"	p	signature:(struct event_base *base, int n_cpus)
event_base_stop_iocp	event.c	/^event_base_stop_iocp(struct event_base *base)$/;"	f	signature:(struct event_base *base)
event_base_stop_iocp	iocp-internal.h	/^void event_base_stop_iocp(struct event_base *base);$/;"	p	signature:(struct event_base *base)
event_break	event-internal.h	/^	int event_break;$/;"	m	struct:event_base	access:public
event_callback_fn	include/event2/event.h	/^typedef void (*event_callback_fn)(evutil_socket_t, short, void *);$/;"	t
event_change	changelist-internal.h	/^struct event_change {$/;"	s
event_change::fd	changelist-internal.h	/^	evutil_socket_t fd;$/;"	m	struct:event_change	access:public
event_change::old_events	changelist-internal.h	/^	short old_events;$/;"	m	struct:event_change	access:public
event_change::read_change	changelist-internal.h	/^	ev_uint8_t read_change;$/;"	m	struct:event_change	access:public
event_change::write_change	changelist-internal.h	/^	ev_uint8_t write_change;$/;"	m	struct:event_change	access:public
event_change_get_fdinfo	evmap.c	/^event_change_get_fdinfo(struct event_base *base,$/;"	f	file:	signature:(struct event_base *base, const struct event_change *change)
event_changelist	event-internal.h	/^struct event_changelist {$/;"	s
event_changelist::changes	event-internal.h	/^	struct event_change *changes;$/;"	m	struct:event_changelist	typeref:struct:event_changelist::event_change	access:public
event_changelist::changes_size	event-internal.h	/^	int changes_size;$/;"	m	struct:event_changelist	access:public
event_changelist::n_changes	event-internal.h	/^	int n_changes;$/;"	m	struct:event_changelist	access:public
event_changelist_add	changelist-internal.h	/^int event_changelist_add(struct event_base *base, evutil_socket_t fd, short old, short events,$/;"	p	signature:(struct event_base *base, evutil_socket_t fd, short old, short events, void *p)
event_changelist_add	evmap.c	/^event_changelist_add(struct event_base *base, evutil_socket_t fd, short old, short events,$/;"	f	signature:(struct event_base *base, evutil_socket_t fd, short old, short events, void *p)
event_changelist_check	evmap.c	/^event_changelist_check(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
event_changelist_check	evmap.c	556;"	d	file:
event_changelist_del	changelist-internal.h	/^int event_changelist_del(struct event_base *base, evutil_socket_t fd, short old, short events,$/;"	p	signature:(struct event_base *base, evutil_socket_t fd, short old, short events, void *p)
event_changelist_del	evmap.c	/^event_changelist_del(struct event_base *base, evutil_socket_t fd, short old, short events,$/;"	f	signature:(struct event_base *base, evutil_socket_t fd, short old, short events, void *p)
event_changelist_fdinfo	evmap.c	/^struct event_changelist_fdinfo {$/;"	s	file:
event_changelist_fdinfo::idxplus1	evmap.c	/^	int idxplus1; \/* this is the index +1, so that memset(0) will make it$/;"	m	struct:event_changelist_fdinfo	file:	access:public
event_changelist_freemem	changelist-internal.h	/^void event_changelist_freemem(struct event_changelist *changelist);$/;"	p	signature:(struct event_changelist *changelist)
event_changelist_freemem	evmap.c	/^event_changelist_freemem(struct event_changelist *changelist)$/;"	f	signature:(struct event_changelist *changelist)
event_changelist_get_or_construct	evmap.c	/^event_changelist_get_or_construct(struct event_changelist *changelist,$/;"	f	file:	signature:(struct event_changelist *changelist, evutil_socket_t fd, short old_events, struct event_changelist_fdinfo *fdinfo)
event_changelist_grow	evmap.c	/^event_changelist_grow(struct event_changelist *changelist)$/;"	f	file:	signature:(struct event_changelist *changelist)
event_changelist_init	changelist-internal.h	/^void event_changelist_init(struct event_changelist *changelist);$/;"	p	signature:(struct event_changelist *changelist)
event_changelist_init	evmap.c	/^event_changelist_init(struct event_changelist *changelist)$/;"	f	signature:(struct event_changelist *changelist)
event_changelist_remove_all	changelist-internal.h	/^void event_changelist_remove_all(struct event_changelist *changelist,$/;"	p	signature:(struct event_changelist *changelist, struct event_base *base)
event_changelist_remove_all	evmap.c	/^event_changelist_remove_all(struct event_changelist *changelist,$/;"	f	signature:(struct event_changelist *changelist, struct event_base *base)
event_config	event-internal.h	/^struct event_config {$/;"	s
event_config	include/event2/event.h	/^struct event_config$/;"	s
event_config::entries	event-internal.h	/^	TAILQ_HEAD(event_configq, event_config_entry) entries;$/;"	m	struct:event_config	access:public
event_config::flags	event-internal.h	/^	enum event_base_config_flag flags;$/;"	m	struct:event_config	typeref:enum:event_config::event_base_config_flag	access:public
event_config::n_cpus_hint	event-internal.h	/^	int n_cpus_hint;$/;"	m	struct:event_config	access:public
event_config::require_features	event-internal.h	/^	enum event_method_feature require_features;$/;"	m	struct:event_config	typeref:enum:event_config::event_method_feature	access:public
event_config_avoid_method	event.c	/^event_config_avoid_method(struct event_config *cfg, const char *method)$/;"	f	signature:(struct event_config *cfg, const char *method)
event_config_avoid_method	include/event2/event.h	/^int event_config_avoid_method(struct event_config *cfg, const char *method);$/;"	p	signature:(struct event_config *cfg, const char *method)
event_config_entry	event-internal.h	/^struct event_config_entry {$/;"	s
event_config_entry::avoid_method	event-internal.h	/^	const char *avoid_method;$/;"	m	struct:event_config_entry	access:public
event_config_entry::next	event-internal.h	/^	TAILQ_ENTRY(event_config_entry) next;$/;"	m	struct:event_config_entry	access:public
event_config_entry_free	event.c	/^event_config_entry_free(struct event_config_entry *entry)$/;"	f	file:	signature:(struct event_config_entry *entry)
event_config_free	event.c	/^event_config_free(struct event_config *cfg)$/;"	f	signature:(struct event_config *cfg)
event_config_free	include/event2/event.h	/^void event_config_free(struct event_config *cfg);$/;"	p	signature:(struct event_config *cfg)
event_config_is_avoided_method	event.c	/^event_config_is_avoided_method(const struct event_config *cfg,$/;"	f	file:	signature:(const struct event_config *cfg, const char *method)
event_config_new	event.c	/^event_config_new(void)$/;"	f	signature:(void)
event_config_new	include/event2/event.h	/^struct event_config *event_config_new(void);$/;"	p	signature:(void)
event_config_require_features	event.c	/^event_config_require_features(struct event_config *cfg,$/;"	f	signature:(struct event_config *cfg, int features)
event_config_require_features	include/event2/event.h	/^int event_config_require_features(struct event_config *cfg, int feature);$/;"	p	signature:(struct event_config *cfg, int feature)
event_config_set_flag	event.c	/^event_config_set_flag(struct event_config *cfg, int flag)$/;"	f	signature:(struct event_config *cfg, int flag)
event_config_set_flag	include/event2/event.h	/^int event_config_set_flag(struct event_config *cfg, int flag);$/;"	p	signature:(struct event_config *cfg, int flag)
event_config_set_num_cpus_hint	event.c	/^event_config_set_num_cpus_hint(struct event_config *cfg, int cpus)$/;"	f	signature:(struct event_config *cfg, int cpus)
event_config_set_num_cpus_hint	include/event2/event.h	/^int event_config_set_num_cpus_hint(struct event_config *cfg, int cpus);$/;"	p	signature:(struct event_config *cfg, int cpus)
event_continue	event-internal.h	/^	int event_continue;$/;"	m	struct:event_base	access:public
event_count	event-internal.h	/^	int event_count;$/;"	m	struct:event_base	access:public
event_count	poll.c	/^	int event_count;		\/* Highest number alloc *\/$/;"	m	struct:pollop	file:	access:public
event_count_active	event-internal.h	/^	int event_count_active;$/;"	m	struct:event_base	access:public
event_debug	log-internal.h	52;"	d
event_debug	log-internal.h	54;"	d
event_debug_entry	event.c	/^struct event_debug_entry {$/;"	s	file:
event_debug_entry::HT_ENTRY	event.c	/^	HT_ENTRY(event_debug_entry) node;$/;"	p	struct:event_debug_entry	file:	access:public
event_debug_entry::added	event.c	/^	unsigned added : 1;$/;"	m	struct:event_debug_entry	file:	access:public
event_debug_entry::ptr	event.c	/^	const struct event *ptr;$/;"	m	struct:event_debug_entry	typeref:struct:event_debug_entry::event	file:	access:public
event_debug_mode_too_late	event.c	/^static int event_debug_mode_too_late = 0;$/;"	v	file:
event_debug_unassign	event.c	/^event_debug_unassign(struct event *ev)$/;"	f	signature:(struct event *ev)
event_debug_unassign	include/event2/event.h	/^void event_debug_unassign(struct event *);$/;"	p	signature:(struct event *)
event_deferred_cb_cancel	defer-internal.h	/^void event_deferred_cb_cancel(struct deferred_cb_queue *, struct deferred_cb *);$/;"	p	signature:(struct deferred_cb_queue *, struct deferred_cb *)
event_deferred_cb_cancel	event.c	/^event_deferred_cb_cancel(struct deferred_cb_queue *queue,$/;"	f	signature:(struct deferred_cb_queue *queue, struct deferred_cb *cb)
event_deferred_cb_init	defer-internal.h	/^void event_deferred_cb_init(struct deferred_cb *, deferred_cb_fn, void *);$/;"	p	signature:(struct deferred_cb *, deferred_cb_fn, void *)
event_deferred_cb_init	event.c	/^event_deferred_cb_init(struct deferred_cb *cb, deferred_cb_fn fn, void *arg)$/;"	f	signature:(struct deferred_cb *cb, deferred_cb_fn fn, void *arg)
event_deferred_cb_queue_init	defer-internal.h	/^void event_deferred_cb_queue_init(struct deferred_cb_queue *);$/;"	p	signature:(struct deferred_cb_queue *)
event_deferred_cb_queue_init	event.c	/^event_deferred_cb_queue_init(struct deferred_cb_queue *cb)$/;"	f	signature:(struct deferred_cb_queue *cb)
event_deferred_cb_schedule	defer-internal.h	/^void event_deferred_cb_schedule(struct deferred_cb_queue *, struct deferred_cb *);$/;"	p	signature:(struct deferred_cb_queue *, struct deferred_cb *)
event_deferred_cb_schedule	event.c	/^event_deferred_cb_schedule(struct deferred_cb_queue *queue,$/;"	f	signature:(struct deferred_cb_queue *queue, struct deferred_cb *cb)
event_del	event.c	/^event_del(struct event *ev)$/;"	f	signature:(struct event *ev)
event_del	include/event2/event.h	/^int event_del(struct event *);$/;"	p	signature:(struct event *)
event_del_internal	event.c	/^event_del_internal(struct event *ev)$/;"	f	file:	signature:(struct event *ev)
event_del_internal	event.c	/^static inline int event_del_internal(struct event *ev);$/;"	p	file:	signature:(struct event *ev)
event_dispatch	event.c	/^event_dispatch(void)$/;"	f	signature:(void)
event_dispatch	include/event2/event_compat.h	/^int event_dispatch(void);$/;"	p	signature:(void)
event_enable_debug_mode	event.c	/^event_enable_debug_mode(void)$/;"	f	signature:(void)
event_enable_debug_mode	include/event2/event.h	/^void event_enable_debug_mode(void);$/;"	p	signature:(void)
event_err	log.c	/^event_err(int eval, const char *fmt, ...)$/;"	f	signature:(int eval, const char *fmt, ...)
event_errx	log.c	/^event_errx(int eval, const char *fmt, ...)$/;"	f	signature:(int eval, const char *fmt, ...)
event_exit	log.c	/^event_exit(int errcode)$/;"	f	file:	signature:(int errcode)
event_fatal_cb	include/event2/event.h	/^typedef void (*event_fatal_cb)(int err);$/;"	t
event_fds	select.c	/^	int event_fds;		\/* Highest fd in fd set *\/$/;"	m	struct:selectop	file:	access:public
event_fdsz	select.c	/^	int event_fdsz;$/;"	m	struct:selectop	file:	access:public
event_free	event.c	/^event_free(struct event *ev)$/;"	f	signature:(struct event *ev)
event_free	include/event2/event.h	/^void event_free(struct event *);$/;"	p	signature:(struct event *)
event_get_assignment	event.c	/^event_get_assignment(const struct event *event, struct event_base **base_out, evutil_socket_t *fd_out, short *events_out, event_callback_fn *callback_out, void **arg_out)$/;"	f	signature:(const struct event *event, struct event_base **base_out, evutil_socket_t *fd_out, short *events_out, event_callback_fn *callback_out, void **arg_out)
event_get_assignment	include/event2/event.h	/^void event_get_assignment(const struct event *event,$/;"	p	signature:(const struct event *event, struct event_base **base_out, evutil_socket_t *fd_out, short *events_out, event_callback_fn *callback_out, void **arg_out)
event_get_base	event.c	/^event_get_base(const struct event *ev)$/;"	f	signature:(const struct event *ev)
event_get_base	include/event2/event.h	/^struct event_base *event_get_base(const struct event *ev);$/;"	p	signature:(const struct event *ev)
event_get_callback	event.c	/^event_get_callback(const struct event *ev)$/;"	f	signature:(const struct event *ev)
event_get_callback	include/event2/event.h	/^event_callback_fn event_get_callback(const struct event *ev);$/;"	p	signature:(const struct event *ev)
event_get_callback_arg	event.c	/^event_get_callback_arg(const struct event *ev)$/;"	f	signature:(const struct event *ev)
event_get_callback_arg	include/event2/event.h	/^void *event_get_callback_arg(const struct event *ev);$/;"	p	signature:(const struct event *ev)
event_get_events	event.c	/^event_get_events(const struct event *ev)$/;"	f	signature:(const struct event *ev)
event_get_events	include/event2/event.h	/^short event_get_events(const struct event *ev);$/;"	p	signature:(const struct event *ev)
event_get_fd	event.c	/^event_get_fd(const struct event *ev)$/;"	f	signature:(const struct event *ev)
event_get_fd	include/event2/event.h	/^evutil_socket_t event_get_fd(const struct event *ev);$/;"	p	signature:(const struct event *ev)
event_get_method	event.c	/^event_get_method(void)$/;"	f	signature:(void)
event_get_method	include/event2/event_compat.h	/^const char *event_get_method(void);$/;"	p	signature:(void)
event_get_signal	include/event2/event.h	1005;"	d
event_get_struct_event_size	event.c	/^event_get_struct_event_size(void)$/;"	f	signature:(void)
event_get_struct_event_size	include/event2/event.h	/^size_t event_get_struct_event_size(void);$/;"	p	signature:(void)
event_get_supported_methods	event.c	/^event_get_supported_methods(void)$/;"	f	signature:(void)
event_get_supported_methods	include/event2/event.h	/^const char **event_get_supported_methods(void);$/;"	p	signature:(void)
event_get_version	event.c	/^event_get_version(void)$/;"	f	signature:(void)
event_get_version	include/event2/event.h	/^const char *event_get_version(void);$/;"	p	signature:(void)
event_get_version_number	event.c	/^event_get_version_number(void)$/;"	f	signature:(void)
event_get_version_number	include/event2/event.h	/^ev_uint32_t event_get_version_number(void);$/;"	p	signature:(void)
event_get_win32_extension_fns	event_iocp.c	/^event_get_win32_extension_fns(void)$/;"	f	signature:(void)
event_get_win32_extension_fns	iocp-internal.h	/^const struct win32_extension_fns *event_get_win32_extension_fns(void);$/;"	p	signature:(void)
event_global_current_base_	event.c	/^struct event_base *event_global_current_base_ = NULL;$/;"	v	typeref:struct:event_base
event_global_setup_locks_	event.c	/^event_global_setup_locks_(const int enable_locks)$/;"	f	signature:(const int enable_locks)
event_global_setup_locks_	evthread-internal.h	/^int event_global_setup_locks_(const int enable_locks);$/;"	p	signature:(const int enable_locks)
event_gotterm	event-internal.h	/^	int event_gotterm;$/;"	m	struct:event_base	access:public
event_haveevents	event.c	/^event_haveevents(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
event_haveevents	event.c	/^static int	event_haveevents(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
event_init	event.c	/^event_init(void)$/;"	f	signature:(void)
event_init	include/event2/event_compat.h	/^struct event_base *event_init(void);$/;"	p	signature:(void)
event_initialized	event.c	/^event_initialized(const struct event *ev)$/;"	f	signature:(const struct event *ev)
event_initialized	include/event2/event.h	/^int event_initialized(const struct event *ev);$/;"	p	signature:(const struct event *ev)
event_io_map	event-internal.h	117;"	d
event_iocp_activate_overlapped	event_iocp.c	/^event_iocp_activate_overlapped($/;"	f	signature:( struct event_iocp_port *port, struct event_overlapped *o, ev_uintptr_t key, ev_uint32_t n)
event_iocp_activate_overlapped	iocp-internal.h	/^int event_iocp_activate_overlapped(struct event_iocp_port *port,$/;"	p	signature:(struct event_iocp_port *port, struct event_overlapped *o, ev_uintptr_t key, ev_uint32_t n_bytes)
event_iocp_notify_all	event_iocp.c	/^event_iocp_notify_all(struct event_iocp_port *port)$/;"	f	file:	signature:(struct event_iocp_port *port)
event_iocp_port	iocp-internal.h	/^struct event_iocp_port {$/;"	s
event_iocp_port::lock	iocp-internal.h	/^	CRITICAL_SECTION lock;$/;"	m	struct:event_iocp_port	access:public
event_iocp_port::ms	iocp-internal.h	/^	long ms;$/;"	m	struct:event_iocp_port	access:public
event_iocp_port::n_live_threads	iocp-internal.h	/^	short n_live_threads;$/;"	m	struct:event_iocp_port	access:public
event_iocp_port::n_threads	iocp-internal.h	/^	short n_threads;$/;"	m	struct:event_iocp_port	access:public
event_iocp_port::port	iocp-internal.h	/^	HANDLE port;$/;"	m	struct:event_iocp_port	access:public
event_iocp_port::shutdown	iocp-internal.h	/^	short shutdown;$/;"	m	struct:event_iocp_port	access:public
event_iocp_port::shutdownSemaphore	iocp-internal.h	/^	HANDLE *shutdownSemaphore;$/;"	m	struct:event_iocp_port	access:public
event_iocp_port::threads	iocp-internal.h	/^	HANDLE *threads;$/;"	m	struct:event_iocp_port	access:public
event_iocp_port_associate	event_iocp.c	/^event_iocp_port_associate(struct event_iocp_port *port, evutil_socket_t fd,$/;"	f	signature:(struct event_iocp_port *port, evutil_socket_t fd, ev_uintptr_t key)
event_iocp_port_associate	iocp-internal.h	/^int event_iocp_port_associate(struct event_iocp_port *port, evutil_socket_t fd,$/;"	p	signature:(struct event_iocp_port *port, evutil_socket_t fd, ev_uintptr_t key)
event_iocp_port_launch	event_iocp.c	/^event_iocp_port_launch(int n_cpus)$/;"	f	signature:(int n_cpus)
event_iocp_port_launch	iocp-internal.h	/^struct event_iocp_port *event_iocp_port_launch(int n_cpus);$/;"	p	signature:(int n_cpus)
event_iocp_shutdown	event_iocp.c	/^event_iocp_shutdown(struct event_iocp_port *port, long waitMsec)$/;"	f	signature:(struct event_iocp_port *port, long waitMsec)
event_iocp_shutdown	iocp-internal.h	/^int event_iocp_shutdown(struct event_iocp_port *port, long waitMsec);$/;"	p	signature:(struct event_iocp_port *port, long waitMsec)
event_is_method_disabled	event.c	/^event_is_method_disabled(const char *name)$/;"	f	file:	signature:(const char *name)
event_is_persistent	sample/time-test.c	/^int event_is_persistent;$/;"	v
event_listener_destroy	listener.c	/^event_listener_destroy(struct evconnlistener *lev)$/;"	f	file:	signature:(struct evconnlistener *lev)
event_listener_destroy	listener.c	/^static void event_listener_destroy(struct evconnlistener *);$/;"	p	file:	signature:(struct evconnlistener *)
event_listener_disable	listener.c	/^event_listener_disable(struct evconnlistener *lev)$/;"	f	file:	signature:(struct evconnlistener *lev)
event_listener_disable	listener.c	/^static int event_listener_disable(struct evconnlistener *);$/;"	p	file:	signature:(struct evconnlistener *)
event_listener_enable	listener.c	/^event_listener_enable(struct evconnlistener *lev)$/;"	f	file:	signature:(struct evconnlistener *lev)
event_listener_enable	listener.c	/^static int event_listener_enable(struct evconnlistener *);$/;"	p	file:	signature:(struct evconnlistener *)
event_listener_getbase	listener.c	/^event_listener_getbase(struct evconnlistener *lev)$/;"	f	file:	signature:(struct evconnlistener *lev)
event_listener_getbase	listener.c	/^static struct event_base *event_listener_getbase(struct evconnlistener *);$/;"	p	file:	signature:(struct evconnlistener *)
event_listener_getfd	listener.c	/^event_listener_getfd(struct evconnlistener *lev)$/;"	f	file:	signature:(struct evconnlistener *lev)
event_listener_getfd	listener.c	/^static evutil_socket_t event_listener_getfd(struct evconnlistener *);$/;"	p	file:	signature:(struct evconnlistener *)
event_log	log.c	/^event_log(int severity, const char *msg)$/;"	f	file:	signature:(int severity, const char *msg)
event_log	log.c	/^static void event_log(int severity, const char *msg);$/;"	p	file:	signature:(int severity, const char *msg)
event_log_cb	include/event2/event.h	/^typedef void (*event_log_cb)(int severity, const char *msg);$/;"	t
event_loop	event.c	/^event_loop(int flags)$/;"	f	signature:(int flags)
event_loop	include/event2/event_compat.h	/^int event_loop(int);$/;"	p	signature:(int)
event_loopbreak	event.c	/^event_loopbreak(void)$/;"	f	signature:(void)
event_loopbreak	include/event2/event_compat.h	/^int event_loopbreak(void);$/;"	p	signature:(void)
event_loopexit	event.c	/^event_loopexit(const struct timeval *tv)$/;"	f	signature:(const struct timeval *tv)
event_loopexit	include/event2/event_compat.h	/^int event_loopexit(const struct timeval *);$/;"	p	signature:(const struct timeval *)
event_loopexit_cb	event.c	/^event_loopexit_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
event_map_entry	evmap.c	/^struct event_map_entry {$/;"	s	file:
event_map_entry::HT_ENTRY	evmap.c	/^	HT_ENTRY(event_map_entry) map_node;$/;"	p	struct:event_map_entry	file:	access:public
event_map_entry::__anon6::evmap_io	evmap.c	/^		struct evmap_io evmap_io;$/;"	m	union:event_map_entry::__anon6	typeref:struct:event_map_entry::__anon6::evmap_io	file:	access:public
event_map_entry::ent	evmap.c	/^	} ent;$/;"	m	struct:event_map_entry	typeref:union:event_map_entry::__anon6	file:	access:public
event_map_entry::fd	evmap.c	/^	evutil_socket_t fd;$/;"	m	struct:event_map_entry	file:	access:public
event_method_feature	include/event2/event.h	/^enum event_method_feature {$/;"	g
event_mm_calloc_	event.c	/^event_mm_calloc_(size_t count, size_t size)$/;"	f	signature:(size_t count, size_t size)
event_mm_calloc_	mm-internal.h	/^void *event_mm_calloc_(size_t count, size_t size);$/;"	p	signature:(size_t count, size_t size)
event_mm_free_	event.c	/^event_mm_free_(void *ptr)$/;"	f	signature:(void *ptr)
event_mm_free_	mm-internal.h	/^void event_mm_free_(void *p);$/;"	p	signature:(void *p)
event_mm_malloc_	event.c	/^event_mm_malloc_(size_t sz)$/;"	f	signature:(size_t sz)
event_mm_malloc_	mm-internal.h	/^void *event_mm_malloc_(size_t sz);$/;"	p	signature:(size_t sz)
event_mm_realloc_	event.c	/^event_mm_realloc_(void *ptr, size_t sz)$/;"	f	signature:(void *ptr, size_t sz)
event_mm_realloc_	mm-internal.h	/^void *event_mm_realloc_(void *p, size_t sz);$/;"	p	signature:(void *p, size_t sz)
event_mm_strdup_	event.c	/^event_mm_strdup_(const char *str)$/;"	f	signature:(const char *str)
event_mm_strdup_	mm-internal.h	/^char *event_mm_strdup_(const char *s);$/;"	p	signature:(const char *s)
event_msgx	log.c	/^event_msgx(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
event_new	event.c	/^event_new(struct event_base *base, evutil_socket_t fd, short events, void (*cb)(evutil_socket_t, short, void *), void *arg)$/;"	f	signature:(struct event_base *base, evutil_socket_t fd, short events, void (*cb)(evutil_socket_t, short, void *), void *arg)
event_new	include/event2/event.h	/^struct event *event_new(struct event_base *, evutil_socket_t, short, event_callback_fn, void *);$/;"	p	signature:(struct event_base *, evutil_socket_t, short, event_callback_fn, void *)
event_once	event.c	/^event_once(evutil_socket_t fd, short events,$/;"	f	signature:(evutil_socket_t fd, short events, void (*callback)(evutil_socket_t, short, void *), void *arg, const struct timeval *tv)
event_once	event.c	/^struct event_once {$/;"	s	file:
event_once	include/event2/event_compat.h	/^int event_once(evutil_socket_t , short,$/;"	p	signature:(evutil_socket_t , short, void (*)(evutil_socket_t, short, void *), void *, const struct timeval *)
event_once::arg	event.c	/^	void *arg;$/;"	m	struct:event_once	file:	access:public
event_once::cb	event.c	/^	void (*cb)(evutil_socket_t, short, void *);$/;"	m	struct:event_once	file:	access:public
event_once::ev	event.c	/^	struct event ev;$/;"	m	struct:event_once	typeref:struct:event_once::event	file:	access:public
event_once_cb	event.c	/^event_once_cb(evutil_socket_t fd, short events, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short events, void *arg)
event_overlapped	iocp-internal.h	/^struct event_overlapped {$/;"	s
event_overlapped::cb	iocp-internal.h	/^	iocp_callback cb;$/;"	m	struct:event_overlapped	access:public
event_overlapped::overlapped	iocp-internal.h	/^	OVERLAPPED overlapped;$/;"	m	struct:event_overlapped	access:public
event_overlapped_init	event_iocp.c	/^event_overlapped_init(struct event_overlapped *o, iocp_callback cb)$/;"	f	signature:(struct event_overlapped *o, iocp_callback cb)
event_overlapped_init	iocp-internal.h	/^void event_overlapped_init(struct event_overlapped *, iocp_callback cb);$/;"	p	signature:(struct event_overlapped *, iocp_callback cb)
event_pending	event.c	/^event_pending(const struct event *ev, short event, struct timeval *tv)$/;"	f	signature:(const struct event *ev, short event, struct timeval *tv)
event_pending	include/event2/event.h	/^int event_pending(const struct event *ev, short events, struct timeval *tv);$/;"	p	signature:(const struct event *ev, short events, struct timeval *tv)
event_persist_closure	event.c	/^event_persist_closure(struct event_base *base, struct event *ev)$/;"	f	file:	signature:(struct event_base *base, struct event *ev)
event_persist_closure	event.c	/^static inline void	event_persist_closure(struct event_base *, struct event *ev);$/;"	p	file:	signature:(struct event_base *, struct event *ev)
event_priority_init	event.c	/^event_priority_init(int npriorities)$/;"	f	signature:(int npriorities)
event_priority_init	include/event2/event_compat.h	/^int	event_priority_init(int);$/;"	p	signature:(int)
event_priority_set	event.c	/^event_priority_set(struct event *ev, int pri)$/;"	f	signature:(struct event *ev, int pri)
event_priority_set	include/event2/event.h	/^int	event_priority_set(struct event *, int);$/;"	p	signature:(struct event *, int)
event_process_active	event.c	/^event_process_active(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
event_process_active	event.c	/^static int	event_process_active(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
event_process_active_single_queue	event.c	/^event_process_active_single_queue(struct event_base *base,$/;"	f	file:	signature:(struct event_base *base, struct event_list *activeq)
event_process_deferred_callbacks	event.c	/^event_process_deferred_callbacks(struct deferred_cb_queue *queue, int *breakptr)$/;"	f	file:	signature:(struct deferred_cb_queue *queue, int *breakptr)
event_queue_insert	event.c	/^event_queue_insert(struct event_base *base, struct event *ev, int queue)$/;"	f	file:	signature:(struct event_base *base, struct event *ev, int queue)
event_queue_insert	event.c	/^static void	event_queue_insert(struct event_base *, struct event *, int);$/;"	p	file:	signature:(struct event_base *, struct event *, int)
event_queue_remove	event.c	/^event_queue_remove(struct event_base *base, struct event *ev, int queue)$/;"	f	file:	signature:(struct event_base *base, struct event *ev, int queue)
event_queue_remove	event.c	/^static void	event_queue_remove(struct event_base *, struct event *, int);$/;"	p	file:	signature:(struct event_base *, struct event *, int)
event_readset_in	select.c	/^	fd_set *event_readset_in;$/;"	m	struct:selectop	file:	access:public
event_readset_out	select.c	/^	fd_set *event_readset_out;$/;"	m	struct:selectop	file:	access:public
event_reinit	event.c	/^event_reinit(struct event_base *base)$/;"	f	signature:(struct event_base *base)
event_reinit	include/event2/event.h	/^int event_reinit(struct event_base *base);$/;"	p	signature:(struct event_base *base)
event_running_priority	event-internal.h	/^	int event_running_priority;$/;"	m	struct:event_base	access:public
event_set	event.c	/^event_set(struct event *ev, evutil_socket_t fd, short events,$/;"	f	signature:(struct event *ev, evutil_socket_t fd, short events, void (*callback)(evutil_socket_t, short, void *), void *arg)
event_set	include/event2/event_compat.h	/^void event_set(struct event *, evutil_socket_t, short, void (*)(evutil_socket_t, short, void *), void *);$/;"	p	signature:(struct event *, evutil_socket_t, short, void (*)(evutil_socket_t, short, void *), void *)
event_set	poll.c	/^	struct pollfd *event_set;$/;"	m	struct:pollop	typeref:struct:pollop::pollfd	file:	access:public
event_set_copy	poll.c	/^	struct pollfd *event_set_copy;$/;"	m	struct:pollop	typeref:struct:pollop::pollfd	file:	access:public
event_set_fatal_callback	include/event2/event.h	/^void event_set_fatal_callback(event_fatal_cb cb);$/;"	p	signature:(event_fatal_cb cb)
event_set_fatal_callback	log.c	/^event_set_fatal_callback(event_fatal_cb cb)$/;"	f	signature:(event_fatal_cb cb)
event_set_log_callback	include/event2/event.h	/^void event_set_log_callback(event_log_cb cb);$/;"	p	signature:(event_log_cb cb)
event_set_log_callback	log.c	/^event_set_log_callback(event_log_cb cb)$/;"	f	signature:(event_log_cb cb)
event_set_mem_functions	event.c	/^event_set_mem_functions(void *(*malloc_fn)(size_t sz),$/;"	f	signature:(void *(*malloc_fn)(size_t sz), void *(*realloc_fn)(void *ptr, size_t sz), void (*free_fn)(void *ptr))
event_set_mem_functions	include/event2/event.h	/^void event_set_mem_functions($/;"	p	signature:( void *(*malloc_fn)(size_t sz), void *(*realloc_fn)(void *ptr, size_t sz), void (*free_fn)(void *ptr))
event_signal_closure	event.c	/^event_signal_closure(struct event_base *base, struct event *ev)$/;"	f	file:	signature:(struct event_base *base, struct event *ev)
event_signal_closure	event.c	/^static inline void	event_signal_closure(struct event_base *, struct event *ev);$/;"	p	file:	signature:(struct event_base *, struct event *ev)
event_signal_map	event-internal.h	/^struct event_signal_map {$/;"	s
event_signal_map::entries	event-internal.h	/^	void **entries;$/;"	m	struct:event_signal_map	access:public
event_signal_map::nentries	event-internal.h	/^	int nentries;$/;"	m	struct:event_signal_map	access:public
event_sock_err	log.c	/^event_sock_err(int eval, evutil_socket_t sock, const char *fmt, ...)$/;"	f	signature:(int eval, evutil_socket_t sock, const char *fmt, ...)
event_sock_warn	log.c	/^event_sock_warn(evutil_socket_t sock, const char *fmt, ...)$/;"	f	signature:(evutil_socket_t sock, const char *fmt, ...)
event_test_DEPENDENCIES	sample/Makefile	/^event_test_DEPENDENCIES = $(am__DEPENDENCIES_1) ..\/libevent.la$/;"	m
event_test_LDADD	sample/Makefile	/^event_test_LDADD = $(LDADD)$/;"	m
event_test_OBJECTS	sample/Makefile	/^event_test_OBJECTS = $(am_event_test_OBJECTS)$/;"	m
event_test_SOURCES	sample/Makefile	/^event_test_SOURCES = event-test.c$/;"	m
event_tv	event-internal.h	/^	struct timeval event_tv;$/;"	m	struct:event_base	typeref:struct:event_base::timeval	access:public
event_warn	log.c	/^event_warn(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
event_warnx	log.c	/^event_warnx(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
event_watermark	include/event2/bufferevent_struct.h	/^struct event_watermark {$/;"	s
event_watermark::high	include/event2/bufferevent_struct.h	/^	size_t high;$/;"	m	struct:event_watermark	access:public
event_watermark::low	include/event2/bufferevent_struct.h	/^	size_t low;$/;"	m	struct:event_watermark	access:public
event_writeset_in	select.c	/^	fd_set *event_writeset_in;$/;"	m	struct:selectop	file:	access:public
event_writeset_out	select.c	/^	fd_set *event_writeset_out;$/;"	m	struct:selectop	file:	access:public
eventcb	sample/le-proxy.c	/^eventcb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *ctx)
eventcb	sample/le-proxy.c	/^static void eventcb(struct bufferevent *bev, short what, void *ctx);$/;"	p	file:	signature:(struct bufferevent *bev, short what, void *ctx)
eventcb	test/regress_ssl.c	/^eventcb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *ctx)
eventcb_pending	bufferevent-internal.h	/^	short eventcb_pending;$/;"	m	struct:bufferevent_private	access:public
eventop	event-internal.h	/^struct eventop {$/;"	s
eventop::add	event-internal.h	/^	int (*add)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);$/;"	m	struct:eventop	access:public
eventop::dealloc	event-internal.h	/^	void (*dealloc)(struct event_base *);$/;"	m	struct:eventop	access:public
eventop::del	event-internal.h	/^	int (*del)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);$/;"	m	struct:eventop	access:public
eventop::dispatch	event-internal.h	/^	int (*dispatch)(struct event_base *, struct timeval *);$/;"	m	struct:eventop	access:public
eventop::fdinfo_len	event-internal.h	/^	size_t fdinfo_len;$/;"	m	struct:eventop	access:public
eventop::features	event-internal.h	/^	enum event_method_feature features;$/;"	m	struct:eventop	typeref:enum:eventop::event_method_feature	access:public
eventop::init	event-internal.h	/^	void *(*init)(struct event_base *);$/;"	m	struct:eventop	access:public
eventop::name	event-internal.h	/^	const char *name;$/;"	m	struct:eventop	access:public
eventop::need_reinit	event-internal.h	/^	int need_reinit;$/;"	m	struct:eventop	access:public
eventops	event.c	/^static const struct eventop *eventops[] = {$/;"	v	typeref:struct:eventop	file:
eventqueue	event-internal.h	/^	struct event_list eventqueue;$/;"	m	struct:event_base	typeref:struct:event_base::event_list	access:public
events	devpoll.c	/^	struct pollfd *events;$/;"	m	struct:devpollop	typeref:struct:devpollop::pollfd	file:	access:public
events	epoll.c	/^	struct epoll_event *events;$/;"	m	struct:epollop	typeref:struct:epollop::epoll_event	file:	access:public
events	event-internal.h	/^	struct event_list events;$/;"	m	struct:common_timeout_list	typeref:struct:common_timeout_list::event_list	access:public
events	evmap.c	/^	struct event_list events;$/;"	m	struct:evmap_io	typeref:struct:evmap_io::event_list	file:	access:public
events	evmap.c	/^	struct event_list events;$/;"	m	struct:evmap_signal	typeref:struct:evmap_signal::event_list	file:	access:public
events	kqueue.c	/^	struct kevent *events;$/;"	m	struct:kqop	typeref:struct:kqop::kevent	file:	access:public
events	test/bench.c	/^static struct event *events;$/;"	v	typeref:struct:event	file:
events	test/bench_cascade.c	/^static struct event *events;$/;"	v	typeref:struct:event	file:
events	test/regress.c	/^	short events[16];$/;"	m	struct:persist_active_timeout_called	file:	access:public
events_size	kqueue.c	/^	int events_size;$/;"	m	struct:kqop	file:	access:public
everrorcb	include/event2/bufferevent_compat.h	32;"	d
evhttp	http-internal.h	/^struct evhttp {$/;"	s
evhttp::aliases	http-internal.h	/^	TAILQ_HEAD(aliasq, evhttp_server_alias) aliases;$/;"	m	struct:evhttp	access:public
evhttp::allowed_methods	http-internal.h	/^	ev_uint16_t allowed_methods;$/;"	m	struct:evhttp	access:public
evhttp::base	http-internal.h	/^	struct event_base *base;$/;"	m	struct:evhttp	typeref:struct:evhttp::event_base	access:public
evhttp::callbacks	http-internal.h	/^	TAILQ_HEAD(httpcbq, evhttp_cb) callbacks;$/;"	m	struct:evhttp	access:public
evhttp::connections	http-internal.h	/^	struct evconq connections;$/;"	m	struct:evhttp	typeref:struct:evhttp::evconq	access:public
evhttp::default_max_body_size	http-internal.h	/^	ev_uint64_t default_max_body_size;$/;"	m	struct:evhttp	access:public
evhttp::default_max_headers_size	http-internal.h	/^	size_t default_max_headers_size;$/;"	m	struct:evhttp	access:public
evhttp::gencb	http-internal.h	/^	void (*gencb)(struct evhttp_request *req, void *);$/;"	m	struct:evhttp	access:public
evhttp::gencbarg	http-internal.h	/^	void *gencbarg;$/;"	m	struct:evhttp	access:public
evhttp::next_vhost	http-internal.h	/^	TAILQ_ENTRY(evhttp) next_vhost;$/;"	m	struct:evhttp	access:public
evhttp::sockets	http-internal.h	/^	TAILQ_HEAD(boundq, evhttp_bound_socket) sockets;$/;"	m	struct:evhttp	access:public
evhttp::timeout	http-internal.h	/^	int timeout;$/;"	m	struct:evhttp	access:public
evhttp::vhost_pattern	http-internal.h	/^	char *vhost_pattern;$/;"	m	struct:evhttp	access:public
evhttp::virtualhosts	http-internal.h	/^	TAILQ_HEAD(vhostsq, evhttp) virtualhosts;$/;"	m	struct:evhttp	access:public
evhttp_accept_socket	http.c	/^evhttp_accept_socket(struct evhttp *http, evutil_socket_t fd)$/;"	f	signature:(struct evhttp *http, evutil_socket_t fd)
evhttp_accept_socket	include/event2/http.h	/^int evhttp_accept_socket(struct evhttp *http, evutil_socket_t fd);$/;"	p	signature:(struct evhttp *http, evutil_socket_t fd)
evhttp_accept_socket_with_handle	http.c	/^evhttp_accept_socket_with_handle(struct evhttp *http, evutil_socket_t fd)$/;"	f	signature:(struct evhttp *http, evutil_socket_t fd)
evhttp_accept_socket_with_handle	include/event2/http.h	/^struct evhttp_bound_socket *evhttp_accept_socket_with_handle(struct evhttp *http, evutil_socket_t fd);$/;"	p	signature:(struct evhttp *http, evutil_socket_t fd)
evhttp_add_event	http.c	/^evhttp_add_event(struct event *ev, int timeout, int default_timeout)$/;"	f	file:	signature:(struct event *ev, int timeout, int default_timeout)
evhttp_add_header	http.c	/^evhttp_add_header(struct evkeyvalq *headers,$/;"	f	signature:(struct evkeyvalq *headers, const char *key, const char *value)
evhttp_add_header	include/event2/http.h	/^int evhttp_add_header(struct evkeyvalq *headers, const char *key, const char *value);$/;"	p	signature:(struct evkeyvalq *headers, const char *key, const char *value)
evhttp_add_header_internal	http.c	/^evhttp_add_header_internal(struct evkeyvalq *headers,$/;"	f	file:	signature:(struct evkeyvalq *headers, const char *key, const char *value)
evhttp_add_header_internal	http.c	/^static int evhttp_add_header_internal(struct evkeyvalq *headers,$/;"	p	file:	signature:(struct evkeyvalq *headers, const char *key, const char *value)
evhttp_add_server_alias	http.c	/^evhttp_add_server_alias(struct evhttp *http, const char *alias)$/;"	f	signature:(struct evhttp *http, const char *alias)
evhttp_add_server_alias	include/event2/http.h	/^int evhttp_add_server_alias(struct evhttp *http, const char *alias);$/;"	p	signature:(struct evhttp *http, const char *alias)
evhttp_add_virtual_host	http.c	/^evhttp_add_virtual_host(struct evhttp* http, const char *pattern,$/;"	f	signature:(struct evhttp* http, const char *pattern, struct evhttp* vhost)
evhttp_add_virtual_host	include/event2/http.h	/^int evhttp_add_virtual_host(struct evhttp* http, const char *pattern,$/;"	p	signature:(struct evhttp* http, const char *pattern, struct evhttp* vhost)
evhttp_append_to_last_header	http.c	/^evhttp_append_to_last_header(struct evkeyvalq *headers, const char *line)$/;"	f	file:	signature:(struct evkeyvalq *headers, const char *line)
evhttp_associate_new_request_with_connection	http.c	/^evhttp_associate_new_request_with_connection(struct evhttp_connection *evcon)$/;"	f	file:	signature:(struct evhttp_connection *evcon)
evhttp_associate_new_request_with_connection	http.c	/^static int evhttp_associate_new_request_with_connection($/;"	p	file:	signature:( struct evhttp_connection *evcon)
evhttp_bind_listener	http.c	/^evhttp_bind_listener(struct evhttp *http, struct evconnlistener *listener)$/;"	f	signature:(struct evhttp *http, struct evconnlistener *listener)
evhttp_bind_listener	include/event2/http.h	/^struct evhttp_bound_socket *evhttp_bind_listener(struct evhttp *http, struct evconnlistener *listener);$/;"	p	signature:(struct evhttp *http, struct evconnlistener *listener)
evhttp_bind_socket	http.c	/^evhttp_bind_socket(struct evhttp *http, const char *address, ev_uint16_t port)$/;"	f	signature:(struct evhttp *http, const char *address, ev_uint16_t port)
evhttp_bind_socket	include/event2/http.h	/^int evhttp_bind_socket(struct evhttp *http, const char *address, ev_uint16_t port);$/;"	p	signature:(struct evhttp *http, const char *address, ev_uint16_t port)
evhttp_bind_socket_with_handle	http.c	/^evhttp_bind_socket_with_handle(struct evhttp *http, const char *address, ev_uint16_t port)$/;"	f	signature:(struct evhttp *http, const char *address, ev_uint16_t port)
evhttp_bind_socket_with_handle	include/event2/http.h	/^struct evhttp_bound_socket *evhttp_bind_socket_with_handle(struct evhttp *http, const char *address, ev_uint16_t port);$/;"	p	signature:(struct evhttp *http, const char *address, ev_uint16_t port)
evhttp_bound_socket	http-internal.h	/^struct evhttp_bound_socket {$/;"	s
evhttp_bound_socket::listener	http-internal.h	/^	struct evconnlistener *listener;$/;"	m	struct:evhttp_bound_socket	typeref:struct:evhttp_bound_socket::evconnlistener	access:public
evhttp_bound_socket::next	http-internal.h	/^	TAILQ_ENTRY(evhttp_bound_socket) next;$/;"	m	struct:evhttp_bound_socket	access:public
evhttp_bound_socket_get_fd	http.c	/^evhttp_bound_socket_get_fd(struct evhttp_bound_socket *bound)$/;"	f	signature:(struct evhttp_bound_socket *bound)
evhttp_bound_socket_get_fd	include/event2/http.h	/^evutil_socket_t evhttp_bound_socket_get_fd(struct evhttp_bound_socket *bound_socket);$/;"	p	signature:(struct evhttp_bound_socket *bound_socket)
evhttp_bound_socket_get_listener	http.c	/^evhttp_bound_socket_get_listener(struct evhttp_bound_socket *bound)$/;"	f	signature:(struct evhttp_bound_socket *bound)
evhttp_bound_socket_get_listener	include/event2/http.h	/^struct evconnlistener *evhttp_bound_socket_get_listener(struct evhttp_bound_socket *bound);$/;"	p	signature:(struct evhttp_bound_socket *bound)
evhttp_cancel_request	http.c	/^evhttp_cancel_request(struct evhttp_request *req)$/;"	f	signature:(struct evhttp_request *req)
evhttp_cancel_request	include/event2/http.h	/^void evhttp_cancel_request(struct evhttp_request *req);$/;"	p	signature:(struct evhttp_request *req)
evhttp_cb	http-internal.h	/^struct evhttp_cb {$/;"	s
evhttp_cb::cb	http-internal.h	/^	void (*cb)(struct evhttp_request *req, void *);$/;"	m	struct:evhttp_cb	access:public
evhttp_cb::cbarg	http-internal.h	/^	void *cbarg;$/;"	m	struct:evhttp_cb	access:public
evhttp_cb::next	http-internal.h	/^	TAILQ_ENTRY(evhttp_cb) next;$/;"	m	struct:evhttp_cb	access:public
evhttp_cb::what	http-internal.h	/^	char *what;$/;"	m	struct:evhttp_cb	access:public
evhttp_clear_headers	http.c	/^evhttp_clear_headers(struct evkeyvalq *headers)$/;"	f	signature:(struct evkeyvalq *headers)
evhttp_clear_headers	include/event2/http.h	/^void evhttp_clear_headers(struct evkeyvalq *headers);$/;"	p	signature:(struct evkeyvalq *headers)
evhttp_cmd_type	include/event2/http.h	/^enum evhttp_cmd_type {$/;"	g
evhttp_connected	http.c	/^evhttp_connected(struct evhttp_connection *evcon)$/;"	f	file:	signature:(struct evhttp_connection *evcon)
evhttp_connection	http-internal.h	/^struct evhttp_connection {$/;"	s
evhttp_connection::address	http-internal.h	/^	char *address;			\/* address to connect to *\/$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::base	http-internal.h	/^	struct event_base *base;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::event_base	access:public
evhttp_connection::bind_address	http-internal.h	/^	char *bind_address;		\/* address to use for binding the src *\/$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::bind_port	http-internal.h	/^	u_short bind_port;		\/* local port for binding the src *\/$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::bufev	http-internal.h	/^	struct bufferevent *bufev;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::bufferevent	access:public
evhttp_connection::cb	http-internal.h	/^	void (*cb)(struct evhttp_connection *, void *);$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::cb_arg	http-internal.h	/^	void *cb_arg;$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::closecb	http-internal.h	/^	void (*closecb)(struct evhttp_connection *, void *);$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::closecb_arg	http-internal.h	/^	void *closecb_arg;$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::dns_base	http-internal.h	/^	struct evdns_base *dns_base;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::evdns_base	access:public
evhttp_connection::fd	http-internal.h	/^	evutil_socket_t fd;$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::flags	http-internal.h	/^	int flags;$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::http_server	http-internal.h	/^	struct evhttp *http_server;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::evhttp	access:public
evhttp_connection::max_body_size	http-internal.h	/^	ev_uint64_t max_body_size;$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::max_headers_size	http-internal.h	/^	size_t max_headers_size;$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::next	http-internal.h	/^	TAILQ_ENTRY(evhttp_connection) next;$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::port	http-internal.h	/^	u_short port;$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::read_more_deferred_cb	http-internal.h	/^	struct deferred_cb read_more_deferred_cb;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::deferred_cb	access:public
evhttp_connection::requests	http-internal.h	/^	TAILQ_HEAD(evcon_requestq, evhttp_request) requests;$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::retry_cnt	http-internal.h	/^	int retry_cnt;			\/* retry count *\/$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::retry_ev	http-internal.h	/^	struct event retry_ev;		\/* for retrying connects *\/$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::event	access:public
evhttp_connection::retry_max	http-internal.h	/^	int retry_max;			\/* maximum number of retries *\/$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::state	http-internal.h	/^	enum evhttp_connection_state state;$/;"	m	struct:evhttp_connection	typeref:enum:evhttp_connection::evhttp_connection_state	access:public
evhttp_connection::timeout	http-internal.h	/^	int timeout;			\/* timeout in seconds for events *\/$/;"	m	struct:evhttp_connection	access:public
evhttp_connection_base_new	http.c	/^evhttp_connection_base_new(struct event_base *base, struct evdns_base *dnsbase,$/;"	f	signature:(struct event_base *base, struct evdns_base *dnsbase, const char *address, unsigned short port)
evhttp_connection_base_new	include/event2/http.h	/^struct evhttp_connection *evhttp_connection_base_new($/;"	p	signature:( struct event_base *base, struct evdns_base *dnsbase, const char *address, unsigned short port)
evhttp_connection_cb	http.c	/^evhttp_connection_cb(struct bufferevent *bufev, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *bufev, short what, void *arg)
evhttp_connection_cb_cleanup	http.c	/^evhttp_connection_cb_cleanup(struct evhttp_connection *evcon)$/;"	f	file:	signature:(struct evhttp_connection *evcon)
evhttp_connection_connect	http-internal.h	/^int evhttp_connection_connect(struct evhttp_connection *);$/;"	p	signature:(struct evhttp_connection *)
evhttp_connection_connect	http.c	/^evhttp_connection_connect(struct evhttp_connection *evcon)$/;"	f	signature:(struct evhttp_connection *evcon)
evhttp_connection_done	http.c	/^evhttp_connection_done(struct evhttp_connection *evcon)$/;"	f	file:	signature:(struct evhttp_connection *evcon)
evhttp_connection_error	http-internal.h	/^enum evhttp_connection_error {$/;"	g
evhttp_connection_fail	http-internal.h	/^void evhttp_connection_fail(struct evhttp_connection *,$/;"	p	signature:(struct evhttp_connection *, enum evhttp_connection_error error)
evhttp_connection_fail	http.c	/^evhttp_connection_fail(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, enum evhttp_connection_error error)
evhttp_connection_free	http.c	/^evhttp_connection_free(struct evhttp_connection *evcon)$/;"	f	signature:(struct evhttp_connection *evcon)
evhttp_connection_free	include/event2/http.h	/^void evhttp_connection_free(struct evhttp_connection *evcon);$/;"	p	signature:(struct evhttp_connection *evcon)
evhttp_connection_get_base	http.c	/^evhttp_connection_get_base(struct evhttp_connection *conn)$/;"	f	signature:(struct evhttp_connection *conn)
evhttp_connection_get_base	include/event2/http.h	/^struct event_base *evhttp_connection_get_base(struct evhttp_connection *req);$/;"	p	signature:(struct evhttp_connection *req)
evhttp_connection_get_bufferevent	http.c	/^evhttp_connection_get_bufferevent(struct evhttp_connection *evcon)$/;"	f	signature:(struct evhttp_connection *evcon)
evhttp_connection_get_bufferevent	include/event2/http.h	/^struct bufferevent *evhttp_connection_get_bufferevent($/;"	p	signature:( struct evhttp_connection *evcon)
evhttp_connection_get_peer	http.c	/^evhttp_connection_get_peer(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, char **address, ev_uint16_t *port)
evhttp_connection_get_peer	include/event2/http.h	/^void evhttp_connection_get_peer(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, char **address, ev_uint16_t *port)
evhttp_connection_incoming_fail	http.c	/^evhttp_connection_incoming_fail(struct evhttp_request *req,$/;"	f	file:	signature:(struct evhttp_request *req, enum evhttp_connection_error error)
evhttp_connection_new	http.c	/^evhttp_connection_new(const char *address, unsigned short port)$/;"	f	signature:(const char *address, unsigned short port)
evhttp_connection_new	include/event2/http_compat.h	/^struct evhttp_connection *evhttp_connection_new($/;"	p	signature:( const char *address, unsigned short port)
evhttp_connection_reset	http-internal.h	/^void evhttp_connection_reset(struct evhttp_connection *);$/;"	p	signature:(struct evhttp_connection *)
evhttp_connection_reset	http.c	/^evhttp_connection_reset(struct evhttp_connection *evcon)$/;"	f	signature:(struct evhttp_connection *evcon)
evhttp_connection_retry	http.c	/^evhttp_connection_retry(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
evhttp_connection_set_base	http.c	/^evhttp_connection_set_base(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, struct event_base *base)
evhttp_connection_set_base	include/event2/http_compat.h	/^void evhttp_connection_set_base(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, struct event_base *base)
evhttp_connection_set_closecb	http.c	/^evhttp_connection_set_closecb(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, void (*cb)(struct evhttp_connection *, void *), void *cbarg)
evhttp_connection_set_closecb	include/event2/http.h	/^void evhttp_connection_set_closecb(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, void (*)(struct evhttp_connection *, void *), void *)
evhttp_connection_set_local_address	http.c	/^evhttp_connection_set_local_address(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, const char *address)
evhttp_connection_set_local_address	include/event2/http.h	/^void evhttp_connection_set_local_address(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, const char *address)
evhttp_connection_set_local_port	http.c	/^evhttp_connection_set_local_port(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, ev_uint16_t port)
evhttp_connection_set_local_port	include/event2/http.h	/^void evhttp_connection_set_local_port(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, ev_uint16_t port)
evhttp_connection_set_max_body_size	http.c	/^evhttp_connection_set_max_body_size(struct evhttp_connection* evcon,$/;"	f	signature:(struct evhttp_connection* evcon, ev_ssize_t new_max_body_size)
evhttp_connection_set_max_body_size	include/event2/http.h	/^void evhttp_connection_set_max_body_size(struct evhttp_connection* evcon,$/;"	p	signature:(struct evhttp_connection* evcon, ev_ssize_t new_max_body_size)
evhttp_connection_set_max_headers_size	http.c	/^evhttp_connection_set_max_headers_size(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, ev_ssize_t new_max_headers_size)
evhttp_connection_set_max_headers_size	include/event2/http.h	/^void evhttp_connection_set_max_headers_size(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, ev_ssize_t new_max_headers_size)
evhttp_connection_set_retries	http.c	/^evhttp_connection_set_retries(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, int retry_max)
evhttp_connection_set_retries	include/event2/http.h	/^void evhttp_connection_set_retries(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, int retry_max)
evhttp_connection_set_timeout	http.c	/^evhttp_connection_set_timeout(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, int timeout_in_secs)
evhttp_connection_set_timeout	include/event2/http.h	/^void evhttp_connection_set_timeout(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, int timeout_in_secs)
evhttp_connection_start_detectclose	http.c	/^evhttp_connection_start_detectclose(struct evhttp_connection *evcon)$/;"	f	file:	signature:(struct evhttp_connection *evcon)
evhttp_connection_start_detectclose	http.c	/^static void evhttp_connection_start_detectclose($/;"	p	file:	signature:( struct evhttp_connection *evcon)
evhttp_connection_state	http-internal.h	/^enum evhttp_connection_state {$/;"	g
evhttp_connection_stop_detectclose	http.c	/^evhttp_connection_stop_detectclose(struct evhttp_connection *evcon)$/;"	f	file:	signature:(struct evhttp_connection *evcon)
evhttp_connection_stop_detectclose	http.c	/^static void evhttp_connection_stop_detectclose($/;"	p	file:	signature:( struct evhttp_connection *evcon)
evhttp_decode_uri	http.c	/^evhttp_decode_uri(const char *uri)$/;"	f	signature:(const char *uri)
evhttp_decode_uri	include/event2/http.h	/^char *evhttp_decode_uri(const char *uri);$/;"	p	signature:(const char *uri)
evhttp_decode_uri_internal	http.c	/^evhttp_decode_uri_internal($/;"	f	file:	signature:( const char *uri, size_t length, char *ret, int decode_plus_ctl)
evhttp_decode_uri_internal	http.c	/^static int evhttp_decode_uri_internal(const char *uri, size_t length,$/;"	p	file:	signature:(const char *uri, size_t length, char *ret, int decode_plus)
evhttp_deferred_read_cb	http.c	/^evhttp_deferred_read_cb(struct deferred_cb *cb, void *data)$/;"	f	file:	signature:(struct deferred_cb *cb, void *data)
evhttp_del_accept_socket	http.c	/^evhttp_del_accept_socket(struct evhttp *http, struct evhttp_bound_socket *bound)$/;"	f	signature:(struct evhttp *http, struct evhttp_bound_socket *bound)
evhttp_del_accept_socket	include/event2/http.h	/^void evhttp_del_accept_socket(struct evhttp *http, struct evhttp_bound_socket *bound_socket);$/;"	p	signature:(struct evhttp *http, struct evhttp_bound_socket *bound_socket)
evhttp_del_cb	http.c	/^evhttp_del_cb(struct evhttp *http, const char *uri)$/;"	f	signature:(struct evhttp *http, const char *uri)
evhttp_del_cb	include/event2/http.h	/^int evhttp_del_cb(struct evhttp *, const char *);$/;"	p	signature:(struct evhttp *, const char *)
evhttp_dispatch_callback	http.c	/^evhttp_dispatch_callback(struct httpcbq *callbacks, struct evhttp_request *req)$/;"	f	file:	signature:(struct httpcbq *callbacks, struct evhttp_request *req)
evhttp_encode_uri	http.c	/^evhttp_encode_uri(const char *str)$/;"	f	signature:(const char *str)
evhttp_encode_uri	include/event2/http.h	/^char *evhttp_encode_uri(const char *str);$/;"	p	signature:(const char *str)
evhttp_error_cb	http.c	/^evhttp_error_cb(struct bufferevent *bufev, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *bufev, short what, void *arg)
evhttp_error_cb	http.c	/^static void evhttp_error_cb(struct bufferevent *bufev, short what, void *arg);$/;"	p	file:	signature:(struct bufferevent *bufev, short what, void *arg)
evhttp_find_alias	http.c	/^evhttp_find_alias(struct evhttp *http, struct evhttp **outhttp,$/;"	f	file:	signature:(struct evhttp *http, struct evhttp **outhttp, const char *hostname)
evhttp_find_header	http.c	/^evhttp_find_header(const struct evkeyvalq *headers, const char *key)$/;"	f	signature:(const struct evkeyvalq *headers, const char *key)
evhttp_find_header	include/event2/http.h	/^const char *evhttp_find_header(const struct evkeyvalq *headers,$/;"	p	signature:(const struct evkeyvalq *headers, const char *key)
evhttp_find_vhost	http.c	/^evhttp_find_vhost(struct evhttp *http, struct evhttp **outhttp,$/;"	f	file:	signature:(struct evhttp *http, struct evhttp **outhttp, const char *hostname)
evhttp_find_vhost	http.c	/^static int evhttp_find_vhost(struct evhttp *http, struct evhttp **outhttp,$/;"	p	file:	signature:(struct evhttp *http, struct evhttp **outhttp, const char *hostname)
evhttp_free	http.c	/^evhttp_free(struct evhttp* http)$/;"	f	signature:(struct evhttp* http)
evhttp_free	include/event2/http.h	/^void evhttp_free(struct evhttp* http);$/;"	p	signature:(struct evhttp* http)
evhttp_get_body	http.c	/^evhttp_get_body(struct evhttp_connection *evcon, struct evhttp_request *req)$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_get_body_length	http.c	/^evhttp_get_body_length(struct evhttp_request *req)$/;"	f	file:	signature:(struct evhttp_request *req)
evhttp_get_request	http.c	/^evhttp_get_request(struct evhttp *http, evutil_socket_t fd,$/;"	f	file:	signature:(struct evhttp *http, evutil_socket_t fd, struct sockaddr *sa, ev_socklen_t salen)
evhttp_get_request	http.c	/^static void evhttp_get_request(struct evhttp *, evutil_socket_t, struct sockaddr *, ev_socklen_t);$/;"	p	file:	signature:(struct evhttp *, evutil_socket_t, struct sockaddr *, ev_socklen_t)
evhttp_get_request_connection	http.c	/^evhttp_get_request_connection($/;"	f	file:	signature:( struct evhttp* http, evutil_socket_t fd, struct sockaddr *sa, ev_socklen_t salen)
evhttp_handle_chunked_read	http.c	/^evhttp_handle_chunked_read(struct evhttp_request *req, struct evbuffer *buf)$/;"	f	file:	signature:(struct evhttp_request *req, struct evbuffer *buf)
evhttp_handle_request	http.c	/^evhttp_handle_request(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
evhttp_header_is_valid_value	http.c	/^evhttp_header_is_valid_value(const char *value)$/;"	f	file:	signature:(const char *value)
evhttp_htmlescape	http.c	/^evhttp_htmlescape(const char *html)$/;"	f	signature:(const char *html)
evhttp_htmlescape	include/event2/http.h	/^char *evhttp_htmlescape(const char *html);$/;"	p	signature:(const char *html)
evhttp_is_connection_close	http.c	/^evhttp_is_connection_close(int flags, struct evkeyvalq* headers)$/;"	f	file:	signature:(int flags, struct evkeyvalq* headers)
evhttp_is_connection_keepalive	http.c	/^evhttp_is_connection_keepalive(struct evkeyvalq* headers)$/;"	f	file:	signature:(struct evkeyvalq* headers)
evhttp_make_header	http.c	/^evhttp_make_header(struct evhttp_connection *evcon, struct evhttp_request *req)$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_make_header	http.c	/^static void evhttp_make_header(struct evhttp_connection *, struct evhttp_request *);$/;"	p	file:	signature:(struct evhttp_connection *, struct evhttp_request *)
evhttp_make_header_request	http.c	/^evhttp_make_header_request(struct evhttp_connection *evcon,$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_make_header_response	http.c	/^evhttp_make_header_response(struct evhttp_connection *evcon,$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_make_request	http.c	/^evhttp_make_request(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, struct evhttp_request *req, enum evhttp_cmd_type type, const char *uri)
evhttp_make_request	include/event2/http.h	/^int evhttp_make_request(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, struct evhttp_request *req, enum evhttp_cmd_type type, const char *uri)
evhttp_maybe_add_content_length_header	http.c	/^evhttp_maybe_add_content_length_header(struct evkeyvalq *headers,$/;"	f	file:	signature:(struct evkeyvalq *headers, size_t content_length)
evhttp_maybe_add_date_header	http.c	/^evhttp_maybe_add_date_header(struct evkeyvalq *headers)$/;"	f	file:	signature:(struct evkeyvalq *headers)
evhttp_method	http.c	/^evhttp_method(enum evhttp_cmd_type type)$/;"	f	file:	signature:(enum evhttp_cmd_type type)
evhttp_method_may_have_body	http.c	/^evhttp_method_may_have_body(enum evhttp_cmd_type type)$/;"	f	file:	signature:(enum evhttp_cmd_type type)
evhttp_new	http.c	/^evhttp_new(struct event_base *base)$/;"	f	signature:(struct event_base *base)
evhttp_new	include/event2/http.h	/^struct evhttp *evhttp_new(struct event_base *base);$/;"	p	signature:(struct event_base *base)
evhttp_new_object	http.c	/^evhttp_new_object(void)$/;"	f	file:	signature:(void)
evhttp_parse_firstline	http-internal.h	/^enum message_read_status evhttp_parse_firstline(struct evhttp_request *, struct evbuffer*);$/;"	p	signature:(struct evhttp_request *, struct evbuffer*)
evhttp_parse_firstline	http.c	/^evhttp_parse_firstline(struct evhttp_request *req, struct evbuffer *buffer)$/;"	f	signature:(struct evhttp_request *req, struct evbuffer *buffer)
evhttp_parse_headers	http-internal.h	/^enum message_read_status evhttp_parse_headers(struct evhttp_request *, struct evbuffer*);$/;"	p	signature:(struct evhttp_request *, struct evbuffer*)
evhttp_parse_headers	http.c	/^evhttp_parse_headers(struct evhttp_request *req, struct evbuffer* buffer)$/;"	f	signature:(struct evhttp_request *req, struct evbuffer* buffer)
evhttp_parse_http_version	http.c	/^evhttp_parse_http_version(const char *version, struct evhttp_request *req)$/;"	f	file:	signature:(const char *version, struct evhttp_request *req)
evhttp_parse_query	http.c	/^evhttp_parse_query(const char *uri, struct evkeyvalq *headers)$/;"	f	signature:(const char *uri, struct evkeyvalq *headers)
evhttp_parse_query	include/event2/http.h	/^int evhttp_parse_query(const char *uri, struct evkeyvalq *headers);$/;"	p	signature:(const char *uri, struct evkeyvalq *headers)
evhttp_parse_query_impl	http.c	/^evhttp_parse_query_impl(const char *str, struct evkeyvalq *headers,$/;"	f	file:	signature:(const char *str, struct evkeyvalq *headers, int is_whole_uri)
evhttp_parse_query_str	http.c	/^evhttp_parse_query_str(const char *uri, struct evkeyvalq *headers)$/;"	f	signature:(const char *uri, struct evkeyvalq *headers)
evhttp_parse_query_str	include/event2/http.h	/^int evhttp_parse_query_str(const char *uri, struct evkeyvalq *headers);$/;"	p	signature:(const char *uri, struct evkeyvalq *headers)
evhttp_parse_request_line	http.c	/^evhttp_parse_request_line(struct evhttp_request *req, char *line)$/;"	f	file:	signature:(struct evhttp_request *req, char *line)
evhttp_parse_response_line	http.c	/^evhttp_parse_response_line(struct evhttp_request *req, char *line)$/;"	f	file:	signature:(struct evhttp_request *req, char *line)
evhttp_read_body	http.c	/^evhttp_read_body(struct evhttp_connection *evcon, struct evhttp_request *req)$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_read_cb	http.c	/^evhttp_read_cb(struct bufferevent *bufev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bufev, void *arg)
evhttp_read_cb	http.c	/^static void evhttp_read_cb(struct bufferevent *, void *);$/;"	p	file:	signature:(struct bufferevent *, void *)
evhttp_read_firstline	http.c	/^evhttp_read_firstline(struct evhttp_connection *evcon,$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_read_firstline	http.c	/^static void evhttp_read_firstline(struct evhttp_connection *evcon,$/;"	p	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_read_header	http.c	/^evhttp_read_header(struct evhttp_connection *evcon,$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_read_header	http.c	/^static void evhttp_read_header(struct evhttp_connection *evcon,$/;"	p	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_read_trailer	http.c	/^evhttp_read_trailer(struct evhttp_connection *evcon, struct evhttp_request *req)$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_remove_header	http.c	/^evhttp_remove_header(struct evkeyvalq *headers, const char *key)$/;"	f	signature:(struct evkeyvalq *headers, const char *key)
evhttp_remove_header	include/event2/http.h	/^int evhttp_remove_header(struct evkeyvalq *headers, const char *key);$/;"	p	signature:(struct evkeyvalq *headers, const char *key)
evhttp_remove_server_alias	http.c	/^evhttp_remove_server_alias(struct evhttp *http, const char *alias)$/;"	f	signature:(struct evhttp *http, const char *alias)
evhttp_remove_server_alias	include/event2/http.h	/^int evhttp_remove_server_alias(struct evhttp *http, const char *alias);$/;"	p	signature:(struct evhttp *http, const char *alias)
evhttp_remove_virtual_host	http.c	/^evhttp_remove_virtual_host(struct evhttp* http, struct evhttp* vhost)$/;"	f	signature:(struct evhttp* http, struct evhttp* vhost)
evhttp_remove_virtual_host	include/event2/http.h	/^int evhttp_remove_virtual_host(struct evhttp* http, struct evhttp* vhost);$/;"	p	signature:(struct evhttp* http, struct evhttp* vhost)
evhttp_request	include/event2/http_struct.h	/^struct evhttp_request {$/;"	s
evhttp_request::body_size	include/event2/http_struct.h	/^	size_t body_size;$/;"	m	struct:evhttp_request	access:public
evhttp_request::cb	include/event2/http_struct.h	/^	void (*cb)(struct evhttp_request *, void *);$/;"	m	struct:evhttp_request	access:public
evhttp_request::cb_arg	include/event2/http_struct.h	/^	void *cb_arg;$/;"	m	struct:evhttp_request	access:public
evhttp_request::chunk_cb	include/event2/http_struct.h	/^	void (*chunk_cb)(struct evhttp_request *, void *);$/;"	m	struct:evhttp_request	access:public
evhttp_request::chunked	include/event2/http_struct.h	/^	unsigned chunked:1,		\/* a chunked request *\/$/;"	m	struct:evhttp_request	access:public
evhttp_request::evcon	include/event2/http_struct.h	/^	struct evhttp_connection *evcon;$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evhttp_connection	access:public
evhttp_request::flags	include/event2/http_struct.h	/^	int flags;$/;"	m	struct:evhttp_request	access:public
evhttp_request::headers_size	include/event2/http_struct.h	/^	size_t headers_size;$/;"	m	struct:evhttp_request	access:public
evhttp_request::host_cache	include/event2/http_struct.h	/^	char *host_cache;$/;"	m	struct:evhttp_request	access:public
evhttp_request::input_buffer	include/event2/http_struct.h	/^	struct evbuffer *input_buffer;	\/* read data *\/$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evbuffer	access:public
evhttp_request::input_headers	include/event2/http_struct.h	/^	struct evkeyvalq *input_headers;$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evkeyvalq	access:public
evhttp_request::kind	include/event2/http_struct.h	/^	enum evhttp_request_kind kind;$/;"	m	struct:evhttp_request	typeref:enum:evhttp_request::evhttp_request_kind	access:public
evhttp_request::major	include/event2/http_struct.h	/^	char major;			\/* HTTP Major number *\/$/;"	m	struct:evhttp_request	access:public
evhttp_request::minor	include/event2/http_struct.h	/^	char minor;			\/* HTTP Minor number *\/$/;"	m	struct:evhttp_request	access:public
evhttp_request::next	include/event2/http_struct.h	/^	TAILQ_ENTRY(evhttp_request) next;$/;"	m	struct:evhttp_request	access:public
evhttp_request::ntoread	include/event2/http_struct.h	/^	ev_int64_t ntoread;$/;"	m	struct:evhttp_request	access:public
evhttp_request::output_buffer	include/event2/http_struct.h	/^	struct evbuffer *output_buffer;	\/* outgoing post or data *\/$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evbuffer	access:public
evhttp_request::output_headers	include/event2/http_struct.h	/^	struct evkeyvalq *output_headers;$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evkeyvalq	access:public
evhttp_request::remote_host	include/event2/http_struct.h	/^	char *remote_host;$/;"	m	struct:evhttp_request	access:public
evhttp_request::remote_port	include/event2/http_struct.h	/^	ev_uint16_t remote_port;$/;"	m	struct:evhttp_request	access:public
evhttp_request::response_code	include/event2/http_struct.h	/^	int response_code;		\/* HTTP Response code *\/$/;"	m	struct:evhttp_request	access:public
evhttp_request::response_code_line	include/event2/http_struct.h	/^	char *response_code_line;	\/* Readable response *\/$/;"	m	struct:evhttp_request	access:public
evhttp_request::type	include/event2/http_struct.h	/^	enum evhttp_cmd_type type;$/;"	m	struct:evhttp_request	typeref:enum:evhttp_request::evhttp_cmd_type	access:public
evhttp_request::uri	include/event2/http_struct.h	/^	char *uri;			\/* uri after HTTP request was parsed *\/$/;"	m	struct:evhttp_request	access:public
evhttp_request::uri_elems	include/event2/http_struct.h	/^	struct evhttp_uri *uri_elems;	\/* uri elements *\/$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evhttp_uri	access:public
evhttp_request::userdone	include/event2/http_struct.h	/^	    userdone:1;			\/* the user has sent all data *\/$/;"	m	struct:evhttp_request	access:public
evhttp_request_dispatch	http.c	/^evhttp_request_dispatch(struct evhttp_connection* evcon)$/;"	f	file:	signature:(struct evhttp_connection* evcon)
evhttp_request_dispatch	http.c	/^static void evhttp_request_dispatch(struct evhttp_connection* evcon);$/;"	p	file:	signature:(struct evhttp_connection* evcon)
evhttp_request_free	http.c	/^evhttp_request_free(struct evhttp_request *req)$/;"	f	signature:(struct evhttp_request *req)
evhttp_request_free	include/event2/http.h	/^void evhttp_request_free(struct evhttp_request *req);$/;"	p	signature:(struct evhttp_request *req)
evhttp_request_get_command	http.c	/^evhttp_request_get_command(const struct evhttp_request *req) {$/;"	f	signature:(const struct evhttp_request *req)
evhttp_request_get_command	include/event2/http.h	/^enum evhttp_cmd_type evhttp_request_get_command(const struct evhttp_request *req);$/;"	p	signature:(const struct evhttp_request *req)
evhttp_request_get_connection	http.c	/^evhttp_request_get_connection(struct evhttp_request *req)$/;"	f	signature:(struct evhttp_request *req)
evhttp_request_get_connection	include/event2/http.h	/^struct evhttp_connection *evhttp_request_get_connection(struct evhttp_request *req);$/;"	p	signature:(struct evhttp_request *req)
evhttp_request_get_evhttp_uri	http.c	/^evhttp_request_get_evhttp_uri(const struct evhttp_request *req) {$/;"	f	signature:(const struct evhttp_request *req)
evhttp_request_get_evhttp_uri	include/event2/http.h	/^const struct evhttp_uri *evhttp_request_get_evhttp_uri(const struct evhttp_request *req);$/;"	p	signature:(const struct evhttp_request *req)
evhttp_request_get_host	http.c	/^evhttp_request_get_host(struct evhttp_request *req)$/;"	f	signature:(struct evhttp_request *req)
evhttp_request_get_host	include/event2/http.h	/^const char *evhttp_request_get_host(struct evhttp_request *req);$/;"	p	signature:(struct evhttp_request *req)
evhttp_request_get_input_buffer	http.c	/^struct evbuffer *evhttp_request_get_input_buffer(struct evhttp_request *req)$/;"	f	signature:(struct evhttp_request *req)
evhttp_request_get_input_buffer	include/event2/http.h	/^struct evbuffer *evhttp_request_get_input_buffer(struct evhttp_request *req);$/;"	p	signature:(struct evhttp_request *req)
evhttp_request_get_input_headers	http.c	/^struct evkeyvalq *evhttp_request_get_input_headers(struct evhttp_request *req)$/;"	f	signature:(struct evhttp_request *req)
evhttp_request_get_input_headers	include/event2/http.h	/^struct evkeyvalq *evhttp_request_get_input_headers(struct evhttp_request *req);$/;"	p	signature:(struct evhttp_request *req)
evhttp_request_get_output_buffer	http.c	/^struct evbuffer *evhttp_request_get_output_buffer(struct evhttp_request *req)$/;"	f	signature:(struct evhttp_request *req)
evhttp_request_get_output_buffer	include/event2/http.h	/^struct evbuffer *evhttp_request_get_output_buffer(struct evhttp_request *req);$/;"	p	signature:(struct evhttp_request *req)
evhttp_request_get_output_headers	http.c	/^struct evkeyvalq *evhttp_request_get_output_headers(struct evhttp_request *req)$/;"	f	signature:(struct evhttp_request *req)
evhttp_request_get_output_headers	include/event2/http.h	/^struct evkeyvalq *evhttp_request_get_output_headers(struct evhttp_request *req);$/;"	p	signature:(struct evhttp_request *req)
evhttp_request_get_response_code	http.c	/^evhttp_request_get_response_code(const struct evhttp_request *req)$/;"	f	signature:(const struct evhttp_request *req)
evhttp_request_get_response_code	include/event2/http.h	/^int evhttp_request_get_response_code(const struct evhttp_request *req);$/;"	p	signature:(const struct evhttp_request *req)
evhttp_request_get_uri	http.c	/^evhttp_request_get_uri(const struct evhttp_request *req) {$/;"	f	signature:(const struct evhttp_request *req)
evhttp_request_get_uri	include/event2/http.h	/^const char *evhttp_request_get_uri(const struct evhttp_request *req);$/;"	p	signature:(const struct evhttp_request *req)
evhttp_request_is_owned	http.c	/^evhttp_request_is_owned(struct evhttp_request *req)$/;"	f	signature:(struct evhttp_request *req)
evhttp_request_is_owned	include/event2/http.h	/^int evhttp_request_is_owned(struct evhttp_request *req);$/;"	p	signature:(struct evhttp_request *req)
evhttp_request_kind	include/event2/http.h	/^enum evhttp_request_kind { EVHTTP_REQUEST, EVHTTP_RESPONSE };$/;"	g
evhttp_request_new	http.c	/^evhttp_request_new(void (*cb)(struct evhttp_request *, void *), void *arg)$/;"	f	signature:(void (*cb)(struct evhttp_request *, void *), void *arg)
evhttp_request_new	include/event2/http.h	/^struct evhttp_request *evhttp_request_new($/;"	p	signature:( void (*cb)(struct evhttp_request *, void *), void *arg)
evhttp_request_own	http.c	/^evhttp_request_own(struct evhttp_request *req)$/;"	f	signature:(struct evhttp_request *req)
evhttp_request_own	include/event2/http.h	/^void evhttp_request_own(struct evhttp_request *req);$/;"	p	signature:(struct evhttp_request *req)
evhttp_request_set_chunked_cb	http.c	/^evhttp_request_set_chunked_cb(struct evhttp_request *req,$/;"	f	signature:(struct evhttp_request *req, void (*cb)(struct evhttp_request *, void *))
evhttp_request_set_chunked_cb	include/event2/http.h	/^void evhttp_request_set_chunked_cb(struct evhttp_request *,$/;"	p	signature:(struct evhttp_request *, void (*cb)(struct evhttp_request *, void *))
evhttp_request_uri	include/event2/http_compat.h	84;"	d
evhttp_response_code	http-internal.h	/^void evhttp_response_code(struct evhttp_request *, int, const char *);$/;"	p	signature:(struct evhttp_request *, int, const char *)
evhttp_response_code	http.c	/^evhttp_response_code(struct evhttp_request *req, int code, const char *reason)$/;"	f	signature:(struct evhttp_request *req, int code, const char *reason)
evhttp_response_needs_body	http.c	/^evhttp_response_needs_body(struct evhttp_request *req)$/;"	f	file:	signature:(struct evhttp_request *req)
evhttp_response_phrase_internal	http.c	/^evhttp_response_phrase_internal(int code)$/;"	f	file:	signature:(int code)
evhttp_response_phrase_internal	http.c	/^static const char *evhttp_response_phrase_internal(int code);$/;"	p	file:	signature:(int code)
evhttp_send	http.c	/^evhttp_send(struct evhttp_request *req, struct evbuffer *databuf)$/;"	f	file:	signature:(struct evhttp_request *req, struct evbuffer *databuf)
evhttp_send_continue	http.c	/^evhttp_send_continue(struct evhttp_connection *evcon,$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_send_continue_done	http.c	/^evhttp_send_continue_done(struct evhttp_connection *evcon, void *arg)$/;"	f	file:	signature:(struct evhttp_connection *evcon, void *arg)
evhttp_send_done	http.c	/^evhttp_send_done(struct evhttp_connection *evcon, void *arg)$/;"	f	file:	signature:(struct evhttp_connection *evcon, void *arg)
evhttp_send_error	http.c	/^evhttp_send_error(struct evhttp_request *req, int error, const char *reason)$/;"	f	signature:(struct evhttp_request *req, int error, const char *reason)
evhttp_send_error	include/event2/http.h	/^void evhttp_send_error(struct evhttp_request *req, int error,$/;"	p	signature:(struct evhttp_request *req, int error, const char *reason)
evhttp_send_page	http-internal.h	/^void evhttp_send_page(struct evhttp_request *, struct evbuffer *);$/;"	p	signature:(struct evhttp_request *, struct evbuffer *)
evhttp_send_page	http.c	/^evhttp_send_page(struct evhttp_request *req, struct evbuffer *databuf)$/;"	f	signature:(struct evhttp_request *req, struct evbuffer *databuf)
evhttp_send_reply	http.c	/^evhttp_send_reply(struct evhttp_request *req, int code, const char *reason,$/;"	f	signature:(struct evhttp_request *req, int code, const char *reason, struct evbuffer *databuf)
evhttp_send_reply	include/event2/http.h	/^void evhttp_send_reply(struct evhttp_request *req, int code,$/;"	p	signature:(struct evhttp_request *req, int code, const char *reason, struct evbuffer *databuf)
evhttp_send_reply_chunk	http.c	/^evhttp_send_reply_chunk(struct evhttp_request *req, struct evbuffer *databuf)$/;"	f	signature:(struct evhttp_request *req, struct evbuffer *databuf)
evhttp_send_reply_chunk	include/event2/http.h	/^void evhttp_send_reply_chunk(struct evhttp_request *req,$/;"	p	signature:(struct evhttp_request *req, struct evbuffer *databuf)
evhttp_send_reply_end	http.c	/^evhttp_send_reply_end(struct evhttp_request *req)$/;"	f	signature:(struct evhttp_request *req)
evhttp_send_reply_end	include/event2/http.h	/^void evhttp_send_reply_end(struct evhttp_request *req);$/;"	p	signature:(struct evhttp_request *req)
evhttp_send_reply_start	http.c	/^evhttp_send_reply_start(struct evhttp_request *req, int code,$/;"	f	signature:(struct evhttp_request *req, int code, const char *reason)
evhttp_send_reply_start	include/event2/http.h	/^void evhttp_send_reply_start(struct evhttp_request *req, int code,$/;"	p	signature:(struct evhttp_request *req, int code, const char *reason)
evhttp_server_alias	http-internal.h	/^struct evhttp_server_alias {$/;"	s
evhttp_server_alias::alias	http-internal.h	/^	char *alias; \/* the server alias. *\/$/;"	m	struct:evhttp_server_alias	access:public
evhttp_server_alias::next	http-internal.h	/^	TAILQ_ENTRY(evhttp_server_alias) next;$/;"	m	struct:evhttp_server_alias	access:public
evhttp_set_allowed_methods	http.c	/^evhttp_set_allowed_methods(struct evhttp* http, ev_uint16_t methods)$/;"	f	signature:(struct evhttp* http, ev_uint16_t methods)
evhttp_set_allowed_methods	include/event2/http.h	/^void evhttp_set_allowed_methods(struct evhttp* http, ev_uint16_t methods);$/;"	p	signature:(struct evhttp* http, ev_uint16_t methods)
evhttp_set_cb	http.c	/^evhttp_set_cb(struct evhttp *http, const char *uri,$/;"	f	signature:(struct evhttp *http, const char *uri, void (*cb)(struct evhttp_request *, void *), void *cbarg)
evhttp_set_cb	include/event2/http.h	/^int evhttp_set_cb(struct evhttp *http, const char *path,$/;"	p	signature:(struct evhttp *http, const char *path, void (*cb)(struct evhttp_request *, void *), void *cb_arg)
evhttp_set_gencb	http.c	/^evhttp_set_gencb(struct evhttp *http,$/;"	f	signature:(struct evhttp *http, void (*cb)(struct evhttp_request *, void *), void *cbarg)
evhttp_set_gencb	include/event2/http.h	/^void evhttp_set_gencb(struct evhttp *http,$/;"	p	signature:(struct evhttp *http, void (*cb)(struct evhttp_request *, void *), void *arg)
evhttp_set_max_body_size	http.c	/^evhttp_set_max_body_size(struct evhttp* http, ev_ssize_t max_body_size)$/;"	f	signature:(struct evhttp* http, ev_ssize_t max_body_size)
evhttp_set_max_body_size	include/event2/http.h	/^void evhttp_set_max_body_size(struct evhttp* http, ev_ssize_t max_body_size);$/;"	p	signature:(struct evhttp* http, ev_ssize_t max_body_size)
evhttp_set_max_headers_size	http.c	/^evhttp_set_max_headers_size(struct evhttp* http, ev_ssize_t max_headers_size)$/;"	f	signature:(struct evhttp* http, ev_ssize_t max_headers_size)
evhttp_set_max_headers_size	include/event2/http.h	/^void evhttp_set_max_headers_size(struct evhttp* http, ev_ssize_t max_headers_size);$/;"	p	signature:(struct evhttp* http, ev_ssize_t max_headers_size)
evhttp_set_timeout	http.c	/^evhttp_set_timeout(struct evhttp* http, int timeout_in_secs)$/;"	f	signature:(struct evhttp* http, int timeout_in_secs)
evhttp_set_timeout	include/event2/http.h	/^void evhttp_set_timeout(struct evhttp *http, int timeout_in_secs);$/;"	p	signature:(struct evhttp *http, int timeout_in_secs)
evhttp_start	http.c	/^evhttp_start(const char *address, unsigned short port)$/;"	f	signature:(const char *address, unsigned short port)
evhttp_start	include/event2/http_compat.h	/^struct evhttp *evhttp_start(const char *address, unsigned short port);$/;"	p	signature:(const char *address, unsigned short port)
evhttp_start_read	http-internal.h	/^void evhttp_start_read(struct evhttp_connection *);$/;"	p	signature:(struct evhttp_connection *)
evhttp_start_read	http.c	/^evhttp_start_read(struct evhttp_connection *evcon)$/;"	f	signature:(struct evhttp_connection *evcon)
evhttp_uri	http.c	/^struct evhttp_uri {$/;"	s	file:
evhttp_uri::flags	http.c	/^	unsigned flags;$/;"	m	struct:evhttp_uri	file:	access:public
evhttp_uri::fragment	http.c	/^	char *fragment; \/* fragment or NULL *\/$/;"	m	struct:evhttp_uri	file:	access:public
evhttp_uri::host	http.c	/^	char *host; \/* hostname, IP address, or NULL *\/$/;"	m	struct:evhttp_uri	file:	access:public
evhttp_uri::path	http.c	/^	char *path; \/* path, or "". *\/$/;"	m	struct:evhttp_uri	file:	access:public
evhttp_uri::port	http.c	/^	int port; \/* port, or zero *\/$/;"	m	struct:evhttp_uri	file:	access:public
evhttp_uri::query	http.c	/^	char *query; \/* query, or NULL *\/$/;"	m	struct:evhttp_uri	file:	access:public
evhttp_uri::scheme	http.c	/^	char *scheme; \/* scheme; e.g http, ftp etc *\/$/;"	m	struct:evhttp_uri	file:	access:public
evhttp_uri::userinfo	http.c	/^	char *userinfo; \/* userinfo (typically username:pass), or NULL *\/$/;"	m	struct:evhttp_uri	file:	access:public
evhttp_uri_free	http.c	/^evhttp_uri_free(struct evhttp_uri *uri)$/;"	f	signature:(struct evhttp_uri *uri)
evhttp_uri_free	include/event2/http.h	/^void evhttp_uri_free(struct evhttp_uri *uri);$/;"	p	signature:(struct evhttp_uri *uri)
evhttp_uri_get_fragment	http.c	/^evhttp_uri_get_fragment(const struct evhttp_uri *uri)$/;"	f	signature:(const struct evhttp_uri *uri)
evhttp_uri_get_fragment	include/event2/http.h	/^const char *evhttp_uri_get_fragment(const struct evhttp_uri *uri);$/;"	p	signature:(const struct evhttp_uri *uri)
evhttp_uri_get_host	http.c	/^evhttp_uri_get_host(const struct evhttp_uri *uri)$/;"	f	signature:(const struct evhttp_uri *uri)
evhttp_uri_get_host	include/event2/http.h	/^const char *evhttp_uri_get_host(const struct evhttp_uri *uri);$/;"	p	signature:(const struct evhttp_uri *uri)
evhttp_uri_get_path	http.c	/^evhttp_uri_get_path(const struct evhttp_uri *uri)$/;"	f	signature:(const struct evhttp_uri *uri)
evhttp_uri_get_path	include/event2/http.h	/^const char *evhttp_uri_get_path(const struct evhttp_uri *uri);$/;"	p	signature:(const struct evhttp_uri *uri)
evhttp_uri_get_port	http.c	/^evhttp_uri_get_port(const struct evhttp_uri *uri)$/;"	f	signature:(const struct evhttp_uri *uri)
evhttp_uri_get_port	include/event2/http.h	/^int evhttp_uri_get_port(const struct evhttp_uri *uri);$/;"	p	signature:(const struct evhttp_uri *uri)
evhttp_uri_get_query	http.c	/^evhttp_uri_get_query(const struct evhttp_uri *uri)$/;"	f	signature:(const struct evhttp_uri *uri)
evhttp_uri_get_query	include/event2/http.h	/^const char *evhttp_uri_get_query(const struct evhttp_uri *uri);$/;"	p	signature:(const struct evhttp_uri *uri)
evhttp_uri_get_scheme	http.c	/^evhttp_uri_get_scheme(const struct evhttp_uri *uri)$/;"	f	signature:(const struct evhttp_uri *uri)
evhttp_uri_get_scheme	include/event2/http.h	/^const char *evhttp_uri_get_scheme(const struct evhttp_uri *uri);$/;"	p	signature:(const struct evhttp_uri *uri)
evhttp_uri_get_userinfo	http.c	/^evhttp_uri_get_userinfo(const struct evhttp_uri *uri)$/;"	f	signature:(const struct evhttp_uri *uri)
evhttp_uri_get_userinfo	include/event2/http.h	/^const char *evhttp_uri_get_userinfo(const struct evhttp_uri *uri);$/;"	p	signature:(const struct evhttp_uri *uri)
evhttp_uri_join	http.c	/^evhttp_uri_join(struct evhttp_uri *uri, char *buf, size_t limit)$/;"	f	signature:(struct evhttp_uri *uri, char *buf, size_t limit)
evhttp_uri_join	include/event2/http.h	/^char *evhttp_uri_join(struct evhttp_uri *uri, char *buf, size_t limit);$/;"	p	signature:(struct evhttp_uri *uri, char *buf, size_t limit)
evhttp_uri_new	http.c	/^evhttp_uri_new(void)$/;"	f	signature:(void)
evhttp_uri_new	include/event2/http.h	/^struct evhttp_uri *evhttp_uri_new(void);$/;"	p	signature:(void)
evhttp_uri_parse	http.c	/^evhttp_uri_parse(const char *source_uri)$/;"	f	signature:(const char *source_uri)
evhttp_uri_parse	include/event2/http.h	/^struct evhttp_uri *evhttp_uri_parse(const char *source_uri);$/;"	p	signature:(const char *source_uri)
evhttp_uri_parse_with_flags	http.c	/^evhttp_uri_parse_with_flags(const char *source_uri, unsigned flags)$/;"	f	signature:(const char *source_uri, unsigned flags)
evhttp_uri_parse_with_flags	include/event2/http.h	/^struct evhttp_uri *evhttp_uri_parse_with_flags(const char *source_uri,$/;"	p	signature:(const char *source_uri, unsigned flags)
evhttp_uri_set_flags	http.c	/^evhttp_uri_set_flags(struct evhttp_uri *uri, unsigned flags)$/;"	f	signature:(struct evhttp_uri *uri, unsigned flags)
evhttp_uri_set_flags	include/event2/http.h	/^void evhttp_uri_set_flags(struct evhttp_uri *uri, unsigned flags);$/;"	p	signature:(struct evhttp_uri *uri, unsigned flags)
evhttp_uri_set_fragment	http.c	/^evhttp_uri_set_fragment(struct evhttp_uri *uri, const char *fragment)$/;"	f	signature:(struct evhttp_uri *uri, const char *fragment)
evhttp_uri_set_fragment	include/event2/http.h	/^int evhttp_uri_set_fragment(struct evhttp_uri *uri, const char *fragment);$/;"	p	signature:(struct evhttp_uri *uri, const char *fragment)
evhttp_uri_set_host	http.c	/^evhttp_uri_set_host(struct evhttp_uri *uri, const char *host)$/;"	f	signature:(struct evhttp_uri *uri, const char *host)
evhttp_uri_set_host	include/event2/http.h	/^int evhttp_uri_set_host(struct evhttp_uri *uri, const char *host);$/;"	p	signature:(struct evhttp_uri *uri, const char *host)
evhttp_uri_set_path	http.c	/^evhttp_uri_set_path(struct evhttp_uri *uri, const char *path)$/;"	f	signature:(struct evhttp_uri *uri, const char *path)
evhttp_uri_set_path	include/event2/http.h	/^int evhttp_uri_set_path(struct evhttp_uri *uri, const char *path);$/;"	p	signature:(struct evhttp_uri *uri, const char *path)
evhttp_uri_set_port	http.c	/^evhttp_uri_set_port(struct evhttp_uri *uri, int port)$/;"	f	signature:(struct evhttp_uri *uri, int port)
evhttp_uri_set_port	include/event2/http.h	/^int evhttp_uri_set_port(struct evhttp_uri *uri, int port);$/;"	p	signature:(struct evhttp_uri *uri, int port)
evhttp_uri_set_query	http.c	/^evhttp_uri_set_query(struct evhttp_uri *uri, const char *query)$/;"	f	signature:(struct evhttp_uri *uri, const char *query)
evhttp_uri_set_query	include/event2/http.h	/^int evhttp_uri_set_query(struct evhttp_uri *uri, const char *query);$/;"	p	signature:(struct evhttp_uri *uri, const char *query)
evhttp_uri_set_scheme	http.c	/^evhttp_uri_set_scheme(struct evhttp_uri *uri, const char *scheme)$/;"	f	signature:(struct evhttp_uri *uri, const char *scheme)
evhttp_uri_set_scheme	include/event2/http.h	/^int evhttp_uri_set_scheme(struct evhttp_uri *uri, const char *scheme);$/;"	p	signature:(struct evhttp_uri *uri, const char *scheme)
evhttp_uri_set_userinfo	http.c	/^evhttp_uri_set_userinfo(struct evhttp_uri *uri, const char *userinfo)$/;"	f	signature:(struct evhttp_uri *uri, const char *userinfo)
evhttp_uri_set_userinfo	include/event2/http.h	/^int evhttp_uri_set_userinfo(struct evhttp_uri *uri, const char *userinfo);$/;"	p	signature:(struct evhttp_uri *uri, const char *userinfo)
evhttp_uridecode	http.c	/^evhttp_uridecode(const char *uri, int decode_plus, size_t *size_out)$/;"	f	signature:(const char *uri, int decode_plus, size_t *size_out)
evhttp_uridecode	include/event2/http.h	/^char *evhttp_uridecode(const char *uri, int decode_plus,$/;"	p	signature:(const char *uri, int decode_plus, size_t *size_out)
evhttp_uriencode	http.c	/^evhttp_uriencode(const char *uri, ev_ssize_t len, int space_as_plus)$/;"	f	signature:(const char *uri, ev_ssize_t len, int space_as_plus)
evhttp_uriencode	include/event2/http.h	/^char *evhttp_uriencode(const char *str, ev_ssize_t size, int space_to_plus);$/;"	p	signature:(const char *str, ev_ssize_t size, int space_to_plus)
evhttp_valid_response_code	http.c	/^evhttp_valid_response_code(int code)$/;"	f	file:	signature:(int code)
evhttp_write_buffer	http.c	/^evhttp_write_buffer(struct evhttp_connection *evcon,$/;"	f	file:	signature:(struct evhttp_connection *evcon, void (*cb)(struct evhttp_connection *, void *), void *arg)
evhttp_write_buffer	http.c	/^static void evhttp_write_buffer(struct evhttp_connection *,$/;"	p	file:	signature:(struct evhttp_connection *, void (*)(struct evhttp_connection *, void *), void *)
evhttp_write_cb	http.c	/^evhttp_write_cb(struct bufferevent *bufev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bufev, void *arg)
evhttp_write_cb	http.c	/^static void evhttp_write_cb(struct bufferevent *, void *);$/;"	p	file:	signature:(struct bufferevent *, void *)
evhttp_write_connectioncb	http.c	/^evhttp_write_connectioncb(struct evhttp_connection *evcon, void *arg)$/;"	f	file:	signature:(struct evhttp_connection *evcon, void *arg)
evkeyval	include/event2/keyvalq_struct.h	/^struct evkeyval {$/;"	s
evkeyval::key	include/event2/keyvalq_struct.h	/^	char *key;$/;"	m	struct:evkeyval	access:public
evkeyval::next	include/event2/keyvalq_struct.h	/^	TAILQ_ENTRY(evkeyval) next;$/;"	m	struct:evkeyval	access:public
evkeyval::value	include/event2/keyvalq_struct.h	/^	char *value;$/;"	m	struct:evkeyval	access:public
evmap_check_integrity	evmap-internal.h	/^void evmap_check_integrity(struct event_base *base);$/;"	p	signature:(struct event_base *base)
evmap_check_integrity	evmap.c	/^evmap_check_integrity(struct event_base *base)$/;"	f	signature:(struct event_base *base)
evmap_io	evmap.c	/^		struct evmap_io evmap_io;$/;"	m	union:event_map_entry::__anon6	typeref:struct:event_map_entry::__anon6::evmap_io	file:	access:public
evmap_io	evmap.c	/^struct evmap_io {$/;"	s	file:
evmap_io::events	evmap.c	/^	struct event_list events;$/;"	m	struct:evmap_io	typeref:struct:evmap_io::event_list	file:	access:public
evmap_io::nread	evmap.c	/^	ev_uint16_t nread;$/;"	m	struct:evmap_io	file:	access:public
evmap_io::nwrite	evmap.c	/^	ev_uint16_t nwrite;$/;"	m	struct:evmap_io	file:	access:public
evmap_io_active	evmap-internal.h	/^void evmap_io_active(struct event_base *base, evutil_socket_t fd, short events);$/;"	p	signature:(struct event_base *base, evutil_socket_t fd, short events)
evmap_io_active	evmap.c	/^evmap_io_active(struct event_base *base, evutil_socket_t fd, short events)$/;"	f	signature:(struct event_base *base, evutil_socket_t fd, short events)
evmap_io_add	evmap-internal.h	/^int evmap_io_add(struct event_base *base, evutil_socket_t fd, struct event *ev);$/;"	p	signature:(struct event_base *base, evutil_socket_t fd, struct event *ev)
evmap_io_add	evmap.c	/^evmap_io_add(struct event_base *base, evutil_socket_t fd, struct event *ev)$/;"	f	signature:(struct event_base *base, evutil_socket_t fd, struct event *ev)
evmap_io_clear	evmap-internal.h	/^void evmap_io_clear(struct event_io_map* ctx);$/;"	p	signature:(struct event_io_map* ctx)
evmap_io_clear	evmap.c	/^evmap_io_clear(struct event_io_map* ctx)$/;"	f	signature:(struct event_io_map* ctx)
evmap_io_clear	evmap.c	/^void evmap_io_clear(struct event_io_map *ctx)$/;"	f	signature:(struct event_io_map *ctx)
evmap_io_del	evmap-internal.h	/^int evmap_io_del(struct event_base *base, evutil_socket_t fd, struct event *ev);$/;"	p	signature:(struct event_base *base, evutil_socket_t fd, struct event *ev)
evmap_io_del	evmap.c	/^evmap_io_del(struct event_base *base, evutil_socket_t fd, struct event *ev)$/;"	f	signature:(struct event_base *base, evutil_socket_t fd, struct event *ev)
evmap_io_get_fdinfo	evmap-internal.h	/^void *evmap_io_get_fdinfo(struct event_io_map *ctx, evutil_socket_t fd);$/;"	p	signature:(struct event_io_map *ctx, evutil_socket_t fd)
evmap_io_get_fdinfo	evmap.c	/^evmap_io_get_fdinfo(struct event_io_map *map, evutil_socket_t fd)$/;"	f	signature:(struct event_io_map *map, evutil_socket_t fd)
evmap_io_init	evmap.c	/^evmap_io_init(struct evmap_io *entry)$/;"	f	file:	signature:(struct evmap_io *entry)
evmap_io_initmap	evmap-internal.h	/^void evmap_io_initmap(struct event_io_map* ctx);$/;"	p	signature:(struct event_io_map* ctx)
evmap_io_initmap	evmap.c	/^evmap_io_initmap(struct event_io_map* ctx)$/;"	f	signature:(struct event_io_map* ctx)
evmap_make_space	evmap.c	/^evmap_make_space(struct event_signal_map *map, int slot, int msize)$/;"	f	file:	signature:(struct event_signal_map *map, int slot, int msize)
evmap_signal	evmap.c	/^struct evmap_signal {$/;"	s	file:
evmap_signal::events	evmap.c	/^	struct event_list events;$/;"	m	struct:evmap_signal	typeref:struct:evmap_signal::event_list	file:	access:public
evmap_signal_active	evmap-internal.h	/^void evmap_signal_active(struct event_base *base, evutil_socket_t signum, int ncalls);$/;"	p	signature:(struct event_base *base, evutil_socket_t signum, int ncalls)
evmap_signal_active	evmap.c	/^evmap_signal_active(struct event_base *base, evutil_socket_t sig, int ncalls)$/;"	f	signature:(struct event_base *base, evutil_socket_t sig, int ncalls)
evmap_signal_add	evmap-internal.h	/^int evmap_signal_add(struct event_base *base, int signum, struct event *ev);$/;"	p	signature:(struct event_base *base, int signum, struct event *ev)
evmap_signal_add	evmap.c	/^evmap_signal_add(struct event_base *base, int sig, struct event *ev)$/;"	f	signature:(struct event_base *base, int sig, struct event *ev)
evmap_signal_clear	evmap-internal.h	/^void evmap_signal_clear(struct event_signal_map* ctx);$/;"	p	signature:(struct event_signal_map* ctx)
evmap_signal_clear	evmap.c	/^evmap_signal_clear(struct event_signal_map *ctx)$/;"	f	signature:(struct event_signal_map *ctx)
evmap_signal_del	evmap-internal.h	/^int evmap_signal_del(struct event_base *base, int signum, struct event *ev);$/;"	p	signature:(struct event_base *base, int signum, struct event *ev)
evmap_signal_del	evmap.c	/^evmap_signal_del(struct event_base *base, int sig, struct event *ev)$/;"	f	signature:(struct event_base *base, int sig, struct event *ev)
evmap_signal_init	evmap.c	/^evmap_signal_init(struct evmap_signal *entry)$/;"	f	file:	signature:(struct evmap_signal *entry)
evmap_signal_initmap	evmap-internal.h	/^void evmap_signal_initmap(struct event_signal_map* ctx);$/;"	p	signature:(struct event_signal_map* ctx)
evmap_signal_initmap	evmap.c	/^evmap_signal_initmap(struct event_signal_map *ctx)$/;"	f	signature:(struct event_signal_map *ctx)
evport_add	evport.c	/^evport_add(struct event_base *base, int fd, short old, short events, void *p)$/;"	f	file:	signature:(struct event_base *base, int fd, short old, short events, void *p)
evport_add	evport.c	/^static int evport_add(struct event_base *, int fd, short old, short events, void *);$/;"	p	file:	signature:(struct event_base *, int fd, short old, short events, void *)
evport_data	evport.c	/^struct evport_data {$/;"	s	file:
evport_data::ed_fds	evport.c	/^	struct fd_info *ed_fds;		\/* allocated fdi table		 *\/$/;"	m	struct:evport_data	typeref:struct:evport_data::fd_info	file:	access:public
evport_data::ed_nevents	evport.c	/^	int		ed_nevents;	\/* number of allocated fdi's	 *\/$/;"	m	struct:evport_data	file:	access:public
evport_data::ed_pending	evport.c	/^	int ed_pending[EVENTS_PER_GETN]; \/* fd's with pending events *\/$/;"	m	struct:evport_data	file:	access:public
evport_data::ed_port	evport.c	/^	int		ed_port;	\/* event port for system events  *\/$/;"	m	struct:evport_data	file:	access:public
evport_dealloc	evport.c	/^evport_dealloc(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
evport_dealloc	evport.c	/^static void	evport_dealloc(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
evport_del	evport.c	/^evport_del(struct event_base *base, int fd, short old, short events, void *p)$/;"	f	file:	signature:(struct event_base *base, int fd, short old, short events, void *p)
evport_del	evport.c	/^static int evport_del(struct event_base *, int fd, short old, short events, void *);$/;"	p	file:	signature:(struct event_base *, int fd, short old, short events, void *)
evport_dispatch	evport.c	/^evport_dispatch(struct event_base *base, struct timeval *tv)$/;"	f	file:	signature:(struct event_base *base, struct timeval *tv)
evport_dispatch	evport.c	/^static int	evport_dispatch(struct event_base *, struct timeval *);$/;"	p	file:	signature:(struct event_base *, struct timeval *)
evport_init	evport.c	/^evport_init(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
evport_init	evport.c	/^static void*	evport_init(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
evportops	evport.c	/^const struct eventop evportops = {$/;"	v	typeref:struct:eventop
evrpc	include/event2/rpc_struct.h	/^struct evrpc {$/;"	s
evrpc::base	include/event2/rpc_struct.h	/^	struct evrpc_base *base;$/;"	m	struct:evrpc	typeref:struct:evrpc::evrpc_base	access:public
evrpc::cb	include/event2/rpc_struct.h	/^	void (*cb)(struct evrpc_req_generic *, void *);$/;"	m	struct:evrpc	access:public
evrpc::cb_arg	include/event2/rpc_struct.h	/^	void *cb_arg;$/;"	m	struct:evrpc	access:public
evrpc::next	include/event2/rpc_struct.h	/^	TAILQ_ENTRY(evrpc) next;$/;"	m	struct:evrpc	access:public
evrpc::reply_complete	include/event2/rpc_struct.h	/^	int (*reply_complete)(void *);$/;"	m	struct:evrpc	access:public
evrpc::reply_free	include/event2/rpc_struct.h	/^	void (*reply_free)(void *);$/;"	m	struct:evrpc	access:public
evrpc::reply_marshal	include/event2/rpc_struct.h	/^	void (*reply_marshal)(struct evbuffer*, void *);$/;"	m	struct:evrpc	access:public
evrpc::reply_new	include/event2/rpc_struct.h	/^	void *(*reply_new)(void *);$/;"	m	struct:evrpc	access:public
evrpc::reply_new_arg	include/event2/rpc_struct.h	/^	void *reply_new_arg;$/;"	m	struct:evrpc	access:public
evrpc::request_free	include/event2/rpc_struct.h	/^	void (*request_free)(void *);$/;"	m	struct:evrpc	access:public
evrpc::request_new	include/event2/rpc_struct.h	/^	void *(*request_new)(void *);$/;"	m	struct:evrpc	access:public
evrpc::request_new_arg	include/event2/rpc_struct.h	/^	void *request_new_arg;$/;"	m	struct:evrpc	access:public
evrpc::request_unmarshal	include/event2/rpc_struct.h	/^	int (*request_unmarshal)(void *, struct evbuffer *);$/;"	m	struct:evrpc	access:public
evrpc::uri	include/event2/rpc_struct.h	/^	const char* uri;$/;"	m	struct:evrpc	access:public
evrpc_add_hook	evrpc.c	/^evrpc_add_hook(void *vbase,$/;"	f	signature:(void *vbase, enum EVRPC_HOOK_TYPE hook_type, int (*cb)(void *, struct evhttp_request *, struct evbuffer *, void *), void *cb_arg)
evrpc_add_hook	include/event2/rpc.h	/^void *evrpc_add_hook(void *vbase,$/;"	p	signature:(void *vbase, enum EVRPC_HOOK_TYPE hook_type, int (*cb)(void *, struct evhttp_request *, struct evbuffer *, void *), void *cb_arg)
evrpc_base	evrpc-internal.h	/^struct evrpc_base {$/;"	s
evrpc_base::common	evrpc-internal.h	/^	struct _evrpc_hooks common;$/;"	m	struct:evrpc_base	typeref:struct:evrpc_base::_evrpc_hooks	access:public
evrpc_base::http_server	evrpc-internal.h	/^	struct evhttp* http_server;$/;"	m	struct:evrpc_base	typeref:struct:evrpc_base::evhttp	access:public
evrpc_base::registered_rpcs	evrpc-internal.h	/^	TAILQ_HEAD(evrpc_list, evrpc) registered_rpcs;$/;"	m	struct:evrpc_base	access:public
evrpc_construct_uri	evrpc.c	/^evrpc_construct_uri(const char *uri)$/;"	f	file:	signature:(const char *uri)
evrpc_free	evrpc.c	/^evrpc_free(struct evrpc_base *base)$/;"	f	signature:(struct evrpc_base *base)
evrpc_free	include/event2/rpc.h	/^void evrpc_free(struct evrpc_base *base);$/;"	p	signature:(struct evrpc_base *base)
evrpc_get_reply	evrpc.c	/^evrpc_get_reply(struct evrpc_req_generic *req)$/;"	f	signature:(struct evrpc_req_generic *req)
evrpc_get_reply	include/event2/rpc.h	/^void *evrpc_get_reply(struct evrpc_req_generic *req);$/;"	p	signature:(struct evrpc_req_generic *req)
evrpc_get_request	evrpc.c	/^evrpc_get_request(struct evrpc_req_generic *req)$/;"	f	signature:(struct evrpc_req_generic *req)
evrpc_get_request	include/event2/rpc.h	/^void *evrpc_get_request(struct evrpc_req_generic *req);$/;"	p	signature:(struct evrpc_req_generic *req)
evrpc_hook	evrpc-internal.h	/^struct evrpc_hook {$/;"	s
evrpc_hook::next	evrpc-internal.h	/^	TAILQ_ENTRY(evrpc_hook) next;$/;"	m	struct:evrpc_hook	access:public
evrpc_hook::process	evrpc-internal.h	/^	int (*process)(void *, struct evhttp_request *,$/;"	m	struct:evrpc_hook	access:public
evrpc_hook::process_arg	evrpc-internal.h	/^	void *process_arg;$/;"	m	struct:evrpc_hook	access:public
evrpc_hook_add_meta	evrpc.c	/^evrpc_hook_add_meta(void *ctx, const char *key,$/;"	f	signature:(void *ctx, const char *key, const void *data, size_t data_size)
evrpc_hook_add_meta	include/event2/rpc.h	/^void evrpc_hook_add_meta(void *ctx, const char *key,$/;"	p	signature:(void *ctx, const char *key, const void *data, size_t data_size)
evrpc_hook_associate_meta	evrpc-internal.h	/^static void evrpc_hook_associate_meta(struct evrpc_hook_meta **pctx,$/;"	p	signature:(struct evrpc_hook_meta **pctx, struct evhttp_connection *evcon)
evrpc_hook_associate_meta	evrpc.c	/^evrpc_hook_associate_meta(struct evrpc_hook_meta **pctx,$/;"	f	file:	signature:(struct evrpc_hook_meta **pctx, struct evhttp_connection *evcon)
evrpc_hook_context_free	evrpc-internal.h	/^static void evrpc_hook_context_free(struct evrpc_hook_meta *ctx);$/;"	p	signature:(struct evrpc_hook_meta *ctx)
evrpc_hook_context_free	evrpc.c	/^evrpc_hook_context_free(struct evrpc_hook_meta *ctx)$/;"	f	file:	signature:(struct evrpc_hook_meta *ctx)
evrpc_hook_ctx	evrpc-internal.h	/^struct evrpc_hook_ctx {$/;"	s
evrpc_hook_ctx::cb	evrpc-internal.h	/^	void (*cb)(void *, enum EVRPC_HOOK_RESULT);$/;"	m	struct:evrpc_hook_ctx	access:public
evrpc_hook_ctx::ctx	evrpc-internal.h	/^	void *ctx;$/;"	m	struct:evrpc_hook_ctx	access:public
evrpc_hook_ctx::next	evrpc-internal.h	/^	TAILQ_ENTRY(evrpc_hook_ctx) next;$/;"	m	struct:evrpc_hook_ctx	access:public
evrpc_hook_find_meta	evrpc.c	/^evrpc_hook_find_meta(void *ctx, const char *key, void **data, size_t *data_size)$/;"	f	signature:(void *ctx, const char *key, void **data, size_t *data_size)
evrpc_hook_find_meta	include/event2/rpc.h	/^int evrpc_hook_find_meta(void *ctx, const char *key,$/;"	p	signature:(void *ctx, const char *key, void **data, size_t *data_size)
evrpc_hook_get_connection	evrpc.c	/^evrpc_hook_get_connection(void *ctx)$/;"	f	signature:(void *ctx)
evrpc_hook_get_connection	include/event2/rpc.h	/^struct evhttp_connection *evrpc_hook_get_connection(void *ctx);$/;"	p	signature:(void *ctx)
evrpc_hook_meta	evrpc-internal.h	/^struct evrpc_hook_meta {$/;"	s
evrpc_hook_meta::evcon	evrpc-internal.h	/^	struct evhttp_connection *evcon;$/;"	m	struct:evrpc_hook_meta	typeref:struct:evrpc_hook_meta::evhttp_connection	access:public
evrpc_hook_meta::meta_data	evrpc-internal.h	/^	struct evrpc_meta_list meta_data;$/;"	m	struct:evrpc_hook_meta	typeref:struct:evrpc_hook_meta::evrpc_meta_list	access:public
evrpc_hook_meta_new	evrpc-internal.h	/^static struct evrpc_hook_meta *evrpc_hook_meta_new(void);$/;"	p	signature:(void)
evrpc_hook_meta_new	evrpc.c	/^evrpc_hook_meta_new(void)$/;"	f	file:	signature:(void)
evrpc_init	evrpc.c	/^evrpc_init(struct evhttp *http_server)$/;"	f	signature:(struct evhttp *http_server)
evrpc_init	include/event2/rpc.h	/^struct evrpc_base *evrpc_init(struct evhttp *server);$/;"	p	signature:(struct evhttp *server)
evrpc_make_request	evrpc.c	/^evrpc_make_request(struct evrpc_request_wrapper *ctx)$/;"	f	signature:(struct evrpc_request_wrapper *ctx)
evrpc_make_request	include/event2/rpc.h	/^int evrpc_make_request(struct evrpc_request_wrapper *ctx);$/;"	p	signature:(struct evrpc_request_wrapper *ctx)
evrpc_make_request_ctx	evrpc.c	/^evrpc_make_request_ctx($/;"	f	signature:( struct evrpc_pool *pool, void *request, void *reply, const char *rpcname, void (*req_marshal)(struct evbuffer*, void *), void (*rpl_clear)(void *), int (*rpl_unmarshal)(void *, struct evbuffer *), void (*cb)(struct evrpc_status *, void *, void *, void *), void *cbarg)
evrpc_make_request_ctx	include/event2/rpc.h	/^struct evrpc_request_wrapper *evrpc_make_request_ctx($/;"	p	signature:( struct evrpc_pool *pool, void *request, void *reply, const char *rpcname, void (*req_marshal)(struct evbuffer*, void *), void (*rpl_clear)(void *), int (*rpl_unmarshal)(void *, struct evbuffer *), void (*cb)(struct evrpc_status *, void *, void *, void *), void *cbarg)
evrpc_meta	evrpc-internal.h	/^struct evrpc_meta {$/;"	s
evrpc_meta::data	evrpc-internal.h	/^	void *data;$/;"	m	struct:evrpc_meta	access:public
evrpc_meta::data_size	evrpc-internal.h	/^	size_t data_size;$/;"	m	struct:evrpc_meta	access:public
evrpc_meta::key	evrpc-internal.h	/^	char *key;$/;"	m	struct:evrpc_meta	access:public
evrpc_meta::next	evrpc-internal.h	/^	TAILQ_ENTRY(evrpc_meta) next;$/;"	m	struct:evrpc_meta	access:public
evrpc_meta_data_free	evrpc.c	/^evrpc_meta_data_free(struct evrpc_meta_list *meta_data)$/;"	f	file:	signature:(struct evrpc_meta_list *meta_data)
evrpc_pause_request	evrpc.c	/^evrpc_pause_request(void *vbase, void *ctx,$/;"	f	file:	signature:(void *vbase, void *ctx, void (*cb)(void *, enum EVRPC_HOOK_RESULT))
evrpc_pause_request	evrpc.c	/^static int evrpc_pause_request(void *vbase, void *ctx,$/;"	p	file:	signature:(void *vbase, void *ctx, void (*cb)(void *, enum EVRPC_HOOK_RESULT))
evrpc_pool	evrpc-internal.h	/^struct evrpc_pool {$/;"	s
evrpc_pool::TAILQ_HEAD	evrpc-internal.h	/^	TAILQ_HEAD(evrpc_requestq, evrpc_request_wrapper) (requests);$/;"	p	struct:evrpc_pool	access:public	signature:(evrpc_requestq, evrpc_request_wrapper)
evrpc_pool::base	evrpc-internal.h	/^	struct event_base *base;$/;"	m	struct:evrpc_pool	typeref:struct:evrpc_pool::event_base	access:public
evrpc_pool::common	evrpc-internal.h	/^	struct _evrpc_hooks common;$/;"	m	struct:evrpc_pool	typeref:struct:evrpc_pool::_evrpc_hooks	access:public
evrpc_pool::connections	evrpc-internal.h	/^	struct evconq connections;$/;"	m	struct:evrpc_pool	typeref:struct:evrpc_pool::evconq	access:public
evrpc_pool::timeout	evrpc-internal.h	/^	int timeout;$/;"	m	struct:evrpc_pool	access:public
evrpc_pool_add_connection	evrpc.c	/^evrpc_pool_add_connection(struct evrpc_pool *pool,$/;"	f	signature:(struct evrpc_pool *pool, struct evhttp_connection *connection)
evrpc_pool_add_connection	include/event2/rpc.h	/^void evrpc_pool_add_connection(struct evrpc_pool *pool,$/;"	p	signature:(struct evrpc_pool *pool, struct evhttp_connection *evcon)
evrpc_pool_find_connection	evrpc.c	/^evrpc_pool_find_connection(struct evrpc_pool *pool)$/;"	f	file:	signature:(struct evrpc_pool *pool)
evrpc_pool_free	evrpc.c	/^evrpc_pool_free(struct evrpc_pool *pool)$/;"	f	signature:(struct evrpc_pool *pool)
evrpc_pool_free	include/event2/rpc.h	/^void evrpc_pool_free(struct evrpc_pool *pool);$/;"	p	signature:(struct evrpc_pool *pool)
evrpc_pool_new	evrpc.c	/^evrpc_pool_new(struct event_base *base)$/;"	f	signature:(struct event_base *base)
evrpc_pool_new	include/event2/rpc.h	/^struct evrpc_pool *evrpc_pool_new(struct event_base *base);$/;"	p	signature:(struct event_base *base)
evrpc_pool_remove_connection	evrpc.c	/^evrpc_pool_remove_connection(struct evrpc_pool *pool,$/;"	f	signature:(struct evrpc_pool *pool, struct evhttp_connection *connection)
evrpc_pool_remove_connection	include/event2/rpc.h	/^void evrpc_pool_remove_connection(struct evrpc_pool *pool,$/;"	p	signature:(struct evrpc_pool *pool, struct evhttp_connection *evcon)
evrpc_pool_schedule	evrpc.c	/^evrpc_pool_schedule(struct evrpc_pool *pool)$/;"	f	file:	signature:(struct evrpc_pool *pool)
evrpc_pool_schedule	evrpc.c	/^static void evrpc_pool_schedule(struct evrpc_pool *pool);$/;"	p	file:	signature:(struct evrpc_pool *pool)
evrpc_pool_set_timeout	evrpc.c	/^evrpc_pool_set_timeout(struct evrpc_pool *pool, int timeout_in_secs)$/;"	f	signature:(struct evrpc_pool *pool, int timeout_in_secs)
evrpc_pool_set_timeout	include/event2/rpc.h	/^void evrpc_pool_set_timeout(struct evrpc_pool *pool, int timeout_in_secs);$/;"	p	signature:(struct evrpc_pool *pool, int timeout_in_secs)
evrpc_process_hooks	evrpc.c	/^evrpc_process_hooks(struct evrpc_hook_list *head, void *ctx,$/;"	f	file:	signature:(struct evrpc_hook_list *head, void *ctx, struct evhttp_request *req, struct evbuffer *evbuf)
evrpc_register_generic	evrpc.c	/^evrpc_register_generic(struct evrpc_base *base, const char *name,$/;"	f	signature:(struct evrpc_base *base, const char *name, void (*callback)(struct evrpc_req_generic *, void *), void *cbarg, void *(*req_new)(void *), void *req_new_arg, void (*req_free)(void *), int (*req_unmarshal)(void *, struct evbuffer *), void *(*rpl_new)(void *), void *rpl_new_arg, void (*rpl_free)(void *), int (*rpl_complete)(void *), void (*rpl_marshal)(struct evbuffer *, void *))
evrpc_register_generic	include/event2/rpc.h	/^evrpc_register_generic(struct evrpc_base *base, const char *name,$/;"	p	signature:(struct evrpc_base *base, const char *name, void (*callback)(struct evrpc_req_generic *, void *), void *cbarg, void *(*req_new)(void *), void *req_new_arg, void (*req_free)(void *), int (*req_unmarshal)(void *, struct evbuffer *), void *(*rpl_new)(void *), void *rpl_new_arg, void (*rpl_free)(void *), int (*rpl_complete)(void *), void (*rpl_marshal)(struct evbuffer *, void *))
evrpc_register_object	evrpc.c	/^evrpc_register_object(const char *name,$/;"	f	file:	signature:(const char *name, void *(*req_new)(void*), void *req_new_arg, void (*req_free)(void *), int (*req_unmarshal)(void *, struct evbuffer *), void *(*rpl_new)(void*), void *rpl_new_arg, void (*rpl_free)(void *), int (*rpl_complete)(void *), void (*rpl_marshal)(struct evbuffer *, void *))
evrpc_register_rpc	evrpc.c	/^evrpc_register_rpc(struct evrpc_base *base, struct evrpc *rpc,$/;"	f	signature:(struct evrpc_base *base, struct evrpc *rpc, void (*cb)(struct evrpc_req_generic *, void *), void *cb_arg)
evrpc_register_rpc	include/event2/rpc.h	/^int evrpc_register_rpc(struct evrpc_base *, struct evrpc *,$/;"	p	signature:(struct evrpc_base *, struct evrpc *, void (*)(struct evrpc_req_generic*, void *), void *)
evrpc_remove_hook	evrpc.c	/^evrpc_remove_hook(void *vbase, enum EVRPC_HOOK_TYPE hook_type, void *handle)$/;"	f	signature:(void *vbase, enum EVRPC_HOOK_TYPE hook_type, void *handle)
evrpc_remove_hook	include/event2/rpc.h	/^int evrpc_remove_hook(void *vbase,$/;"	p	signature:(void *vbase, enum EVRPC_HOOK_TYPE hook_type, void *handle)
evrpc_remove_hook_internal	evrpc.c	/^evrpc_remove_hook_internal(struct evrpc_hook_list *head, void *handle)$/;"	f	file:	signature:(struct evrpc_hook_list *head, void *handle)
evrpc_reply_done	evrpc.c	/^evrpc_reply_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
evrpc_reply_done	evrpc.c	/^static void evrpc_reply_done(struct evhttp_request *, void *);$/;"	p	file:	signature:(struct evhttp_request *, void *)
evrpc_reply_done_closure	evrpc.c	/^evrpc_reply_done_closure(void *, enum EVRPC_HOOK_RESULT);$/;"	p	file:	signature:(void *, enum EVRPC_HOOK_RESULT)
evrpc_reply_done_closure	evrpc.c	/^evrpc_reply_done_closure(void *arg, enum EVRPC_HOOK_RESULT hook_res)$/;"	f	file:	signature:(void *arg, enum EVRPC_HOOK_RESULT hook_res)
evrpc_req_generic	evrpc-internal.h	/^struct evrpc_req_generic {$/;"	s
evrpc_req_generic::hook_meta	evrpc-internal.h	/^	struct evrpc_hook_meta *hook_meta;$/;"	m	struct:evrpc_req_generic	typeref:struct:evrpc_req_generic::evrpc_hook_meta	access:public
evrpc_req_generic::http_req	evrpc-internal.h	/^	struct evhttp_request* http_req;$/;"	m	struct:evrpc_req_generic	typeref:struct:evrpc_req_generic::evhttp_request	access:public
evrpc_req_generic::reply	evrpc-internal.h	/^	void *reply;$/;"	m	struct:evrpc_req_generic	access:public
evrpc_req_generic::request	evrpc-internal.h	/^	void *request;$/;"	m	struct:evrpc_req_generic	access:public
evrpc_req_generic::rpc	evrpc-internal.h	/^	struct evrpc *rpc;$/;"	m	struct:evrpc_req_generic	typeref:struct:evrpc_req_generic::evrpc	access:public
evrpc_req_generic::rpc_data	evrpc-internal.h	/^	struct evbuffer* rpc_data;$/;"	m	struct:evrpc_req_generic	typeref:struct:evrpc_req_generic::evbuffer	access:public
evrpc_reqstate_free	evrpc-internal.h	/^void evrpc_reqstate_free(struct evrpc_req_generic* rpc_state);$/;"	p	signature:(struct evrpc_req_generic* rpc_state)
evrpc_reqstate_free	evrpc.c	/^evrpc_reqstate_free(struct evrpc_req_generic* rpc_state)$/;"	f	signature:(struct evrpc_req_generic* rpc_state)
evrpc_request_cb	evrpc.c	/^evrpc_request_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
evrpc_request_cb	evrpc.c	/^static void evrpc_request_cb(struct evhttp_request *, void *);$/;"	p	file:	signature:(struct evhttp_request *, void *)
evrpc_request_cb_closure	evrpc.c	/^evrpc_request_cb_closure(void *arg, enum EVRPC_HOOK_RESULT hook_res)$/;"	f	file:	signature:(void *arg, enum EVRPC_HOOK_RESULT hook_res)
evrpc_request_cb_closure	evrpc.c	/^static void evrpc_request_cb_closure(void *, enum EVRPC_HOOK_RESULT);$/;"	p	file:	signature:(void *, enum EVRPC_HOOK_RESULT)
evrpc_request_done	evrpc.c	/^evrpc_request_done(struct evrpc_req_generic *rpc_state)$/;"	f	signature:(struct evrpc_req_generic *rpc_state)
evrpc_request_done	include/event2/rpc.h	/^void evrpc_request_done(struct evrpc_req_generic *req);$/;"	p	signature:(struct evrpc_req_generic *req)
evrpc_request_done_closure	evrpc.c	/^evrpc_request_done_closure(void *, enum EVRPC_HOOK_RESULT);$/;"	p	file:	signature:(void *, enum EVRPC_HOOK_RESULT)
evrpc_request_done_closure	evrpc.c	/^evrpc_request_done_closure(void *arg, enum EVRPC_HOOK_RESULT hook_res)$/;"	f	file:	signature:(void *arg, enum EVRPC_HOOK_RESULT hook_res)
evrpc_request_get_pool	evrpc.c	/^evrpc_request_get_pool(struct evrpc_request_wrapper *ctx)$/;"	f	signature:(struct evrpc_request_wrapper *ctx)
evrpc_request_get_pool	include/event2/rpc.h	/^struct evrpc_pool* evrpc_request_get_pool(struct evrpc_request_wrapper *ctx);$/;"	p	signature:(struct evrpc_request_wrapper *ctx)
evrpc_request_set_cb	evrpc.c	/^evrpc_request_set_cb(struct evrpc_request_wrapper *ctx,$/;"	f	signature:(struct evrpc_request_wrapper *ctx, void (*cb)(struct evrpc_status*, void *request, void *reply, void *arg), void *cb_arg)
evrpc_request_set_cb	include/event2/rpc.h	/^void evrpc_request_set_cb(struct evrpc_request_wrapper *ctx,$/;"	p	signature:(struct evrpc_request_wrapper *ctx, void (*cb)(struct evrpc_status*, void *request, void *reply, void *arg), void *cb_arg)
evrpc_request_set_pool	evrpc.c	/^evrpc_request_set_pool(struct evrpc_request_wrapper *ctx,$/;"	f	signature:(struct evrpc_request_wrapper *ctx, struct evrpc_pool *pool)
evrpc_request_set_pool	include/event2/rpc.h	/^void evrpc_request_set_pool(struct evrpc_request_wrapper *ctx,$/;"	p	signature:(struct evrpc_request_wrapper *ctx, struct evrpc_pool *pool)
evrpc_request_timeout	evrpc.c	/^evrpc_request_timeout(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
evrpc_request_timeout	evrpc.c	/^static void evrpc_request_timeout(evutil_socket_t, short, void *);$/;"	p	file:	signature:(evutil_socket_t, short, void *)
evrpc_request_wrapper	evrpc-internal.h	/^struct evrpc_request_wrapper {$/;"	s
evrpc_request_wrapper::cb	evrpc-internal.h	/^	void (*cb)(struct evrpc_status*, void *request, void *reply, void *arg);$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::cb_arg	evrpc-internal.h	/^	void *cb_arg;$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::ev_timeout	evrpc-internal.h	/^	struct event ev_timeout;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::event	access:public
evrpc_request_wrapper::evcon	evrpc-internal.h	/^	struct evhttp_connection *evcon;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::evhttp_connection	access:public
evrpc_request_wrapper::hook_meta	evrpc-internal.h	/^	struct evrpc_hook_meta *hook_meta;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::evrpc_hook_meta	access:public
evrpc_request_wrapper::name	evrpc-internal.h	/^	char *name;$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::next	evrpc-internal.h	/^	TAILQ_ENTRY(evrpc_request_wrapper) next;$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::pool	evrpc-internal.h	/^	struct evrpc_pool *pool;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::evrpc_pool	access:public
evrpc_request_wrapper::reply	evrpc-internal.h	/^	void *reply;$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::reply_clear	evrpc-internal.h	/^	void (*reply_clear)(void *);$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::reply_unmarshal	evrpc-internal.h	/^	int (*reply_unmarshal)(void *, struct evbuffer*);$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::req	evrpc-internal.h	/^	struct evhttp_request *req;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::evhttp_request	access:public
evrpc_request_wrapper::request	evrpc-internal.h	/^	void *request;$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::request_marshal	evrpc-internal.h	/^	void (*request_marshal)(struct evbuffer *, void *);$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper_free	evrpc.c	/^evrpc_request_wrapper_free(struct evrpc_request_wrapper *request)$/;"	f	file:	signature:(struct evrpc_request_wrapper *request)
evrpc_resume_request	evrpc.c	/^evrpc_resume_request(void *vbase, void *ctx, enum EVRPC_HOOK_RESULT res)$/;"	f	signature:(void *vbase, void *ctx, enum EVRPC_HOOK_RESULT res)
evrpc_resume_request	include/event2/rpc.h	/^evrpc_resume_request(void *vbase, void *ctx, enum EVRPC_HOOK_RESULT res);$/;"	p	signature:(void *vbase, void *ctx, enum EVRPC_HOOK_RESULT res)
evrpc_schedule_request	evrpc.c	/^evrpc_schedule_request(struct evhttp_connection *connection,$/;"	f	file:	signature:(struct evhttp_connection *connection, struct evrpc_request_wrapper *ctx)
evrpc_schedule_request	evrpc.c	/^static int evrpc_schedule_request(struct evhttp_connection *connection,$/;"	p	file:	signature:(struct evhttp_connection *connection, struct evrpc_request_wrapper *ctx)
evrpc_schedule_request_closure	evrpc.c	/^evrpc_schedule_request_closure(void *arg, enum EVRPC_HOOK_RESULT hook_res)$/;"	f	file:	signature:(void *arg, enum EVRPC_HOOK_RESULT hook_res)
evrpc_schedule_request_closure	evrpc.c	/^static void evrpc_schedule_request_closure(void *ctx, enum EVRPC_HOOK_RESULT);$/;"	p	file:	signature:(void *ctx, enum EVRPC_HOOK_RESULT)
evrpc_send_request_generic	evrpc.c	/^evrpc_send_request_generic(struct evrpc_pool *pool,$/;"	f	signature:(struct evrpc_pool *pool, void *request, void *reply, void (*cb)(struct evrpc_status *, void *, void *, void *), void *cb_arg, const char *rpcname, void (*req_marshal)(struct evbuffer *, void *), void (*rpl_clear)(void *), int (*rpl_unmarshal)(void *, struct evbuffer *))
evrpc_send_request_generic	include/event2/rpc.h	/^int evrpc_send_request_generic(struct evrpc_pool *pool,$/;"	p	signature:(struct evrpc_pool *pool, void *request, void *reply, void (*cb)(struct evrpc_status *, void *, void *, void *), void *cb_arg, const char *rpcname, void (*req_marshal)(struct evbuffer *, void *), void (*rpl_clear)(void *), int (*rpl_unmarshal)(void *, struct evbuffer *))
evrpc_status	include/event2/rpc_struct.h	/^struct evrpc_status {$/;"	s
evrpc_status::error	include/event2/rpc_struct.h	/^	int error;$/;"	m	struct:evrpc_status	access:public
evrpc_status::http_req	include/event2/rpc_struct.h	/^	struct evhttp_request *http_req;$/;"	m	struct:evrpc_status	typeref:struct:evrpc_status::evhttp_request	access:public
evrpc_unregister_rpc	evrpc.c	/^evrpc_unregister_rpc(struct evrpc_base *base, const char *name)$/;"	f	signature:(struct evrpc_base *base, const char *name)
evrpc_unregister_rpc	include/event2/rpc.h	/^int evrpc_unregister_rpc(struct evrpc_base *base, const char *name);$/;"	p	signature:(struct evrpc_base *base, const char *name)
evsel	event-internal.h	/^	const struct eventop *evsel;$/;"	m	struct:event_base	typeref:struct:event_base::eventop	access:public
evsig_add	signal.c	/^evsig_add(struct event_base *base, evutil_socket_t evsignal, short old, short events, void *p)$/;"	f	file:	signature:(struct event_base *base, evutil_socket_t evsignal, short old, short events, void *p)
evsig_add	signal.c	/^static int evsig_add(struct event_base *, evutil_socket_t, short, short, void *);$/;"	p	file:	signature:(struct event_base *, evutil_socket_t, short, short, void *)
evsig_base	signal.c	/^static struct event_base *evsig_base = NULL;$/;"	v	typeref:struct:event_base	file:
evsig_base_fd	signal.c	/^static evutil_socket_t evsig_base_fd = -1;$/;"	v	file:
evsig_base_lock	signal.c	/^static void *evsig_base_lock = NULL;$/;"	v	file:
evsig_base_n_signals_added	signal.c	/^static int evsig_base_n_signals_added = 0;$/;"	v	file:
evsig_cb	signal.c	/^evsig_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
evsig_dealloc	evsignal-internal.h	/^void evsig_dealloc(struct event_base *);$/;"	p	signature:(struct event_base *)
evsig_dealloc	signal.c	/^evsig_dealloc(struct event_base *base)$/;"	f	signature:(struct event_base *base)
evsig_del	signal.c	/^evsig_del(struct event_base *base, evutil_socket_t evsignal, short old, short events, void *p)$/;"	f	file:	signature:(struct event_base *base, evutil_socket_t evsignal, short old, short events, void *p)
evsig_del	signal.c	/^static int evsig_del(struct event_base *, evutil_socket_t, short, short, void *);$/;"	p	file:	signature:(struct event_base *, evutil_socket_t, short, short, void *)
evsig_global_setup_locks_	evthread-internal.h	/^int evsig_global_setup_locks_(const int enable_locks);$/;"	p	signature:(const int enable_locks)
evsig_global_setup_locks_	signal.c	/^evsig_global_setup_locks_(const int enable_locks)$/;"	f	signature:(const int enable_locks)
evsig_handler	signal.c	/^evsig_handler(int sig)$/;"	f	file:	signature:(int sig)
evsig_handler	signal.c	/^static void __cdecl evsig_handler(int sig);$/;"	p	file:	signature:(int sig)
evsig_info	evsignal-internal.h	/^struct evsig_info {$/;"	s
evsig_info::ev_n_signals_added	evsignal-internal.h	/^	int ev_n_signals_added;$/;"	m	struct:evsig_info	access:public
evsig_info::ev_signal	evsignal-internal.h	/^	struct event ev_signal;$/;"	m	struct:evsig_info	typeref:struct:evsig_info::event	access:public
evsig_info::ev_signal_added	evsignal-internal.h	/^	int ev_signal_added;$/;"	m	struct:evsig_info	access:public
evsig_info::ev_signal_pair	evsignal-internal.h	/^	evutil_socket_t ev_signal_pair[2];$/;"	m	struct:evsig_info	access:public
evsig_info::sh_old	evsignal-internal.h	/^	ev_sighandler_t **sh_old;$/;"	m	struct:evsig_info	access:public
evsig_info::sh_old	evsignal-internal.h	/^	struct sigaction **sh_old;$/;"	m	struct:evsig_info	typeref:struct:evsig_info::sigaction	access:public
evsig_info::sh_old_max	evsignal-internal.h	/^	int sh_old_max;$/;"	m	struct:evsig_info	access:public
evsig_init	evsignal-internal.h	/^int evsig_init(struct event_base *);$/;"	p	signature:(struct event_base *)
evsig_init	signal.c	/^evsig_init(struct event_base *base)$/;"	f	signature:(struct event_base *base)
evsig_set_base	evsignal-internal.h	/^void evsig_set_base(struct event_base *base);$/;"	p	signature:(struct event_base *base)
evsig_set_base	signal.c	/^evsig_set_base(struct event_base *base)$/;"	f	signature:(struct event_base *base)
evsignal_add	include/event2/event.h	769;"	d
evsignal_assign	include/event2/event.h	770;"	d
evsignal_del	include/event2/event.h	774;"	d
evsignal_initialized	include/event2/event.h	776;"	d
evsignal_new	include/event2/event.h	772;"	d
evsignal_pending	include/event2/event.h	775;"	d
evsignal_set	include/event2/event_compat.h	177;"	d
evsigops	signal.c	/^static const struct eventop evsigops = {$/;"	v	typeref:struct:eventop	file:
evsigsel	event-internal.h	/^	const struct eventop *evsigsel;$/;"	m	struct:event_base	typeref:struct:event_base::eventop	access:public
evtag_consume	event_tagging.c	/^evtag_consume(struct evbuffer *evbuf)$/;"	f	signature:(struct evbuffer *evbuf)
evtag_consume	include/event2/tag.h	/^int evtag_consume(struct evbuffer *evbuf);$/;"	p	signature:(struct evbuffer *evbuf)
evtag_decode_int	event_tagging.c	/^evtag_decode_int(ev_uint32_t *pnumber, struct evbuffer *evbuf)$/;"	f	signature:(ev_uint32_t *pnumber, struct evbuffer *evbuf)
evtag_decode_int	event_tagging.c	/^int evtag_decode_int(ev_uint32_t *pnumber, struct evbuffer *evbuf);$/;"	p	file:	signature:(ev_uint32_t *pnumber, struct evbuffer *evbuf)
evtag_decode_int	test/regress.c	/^int evtag_decode_int(ev_uint32_t *pnumber, struct evbuffer *evbuf);$/;"	p	file:	signature:(ev_uint32_t *pnumber, struct evbuffer *evbuf)
evtag_decode_int64	event_tagging.c	/^evtag_decode_int64(ev_uint64_t *pnumber, struct evbuffer *evbuf)$/;"	f	signature:(ev_uint64_t *pnumber, struct evbuffer *evbuf)
evtag_decode_int64	event_tagging.c	/^int evtag_decode_int64(ev_uint64_t *pnumber, struct evbuffer *evbuf);$/;"	p	file:	signature:(ev_uint64_t *pnumber, struct evbuffer *evbuf)
evtag_decode_int64	test/regress.c	/^int evtag_decode_int64(ev_uint64_t *pnumber, struct evbuffer *evbuf);$/;"	p	file:	signature:(ev_uint64_t *pnumber, struct evbuffer *evbuf)
evtag_decode_tag	event_tagging.c	/^evtag_decode_tag(ev_uint32_t *ptag, struct evbuffer *evbuf)$/;"	f	signature:(ev_uint32_t *ptag, struct evbuffer *evbuf)
evtag_decode_tag	event_tagging.c	/^int evtag_decode_tag(ev_uint32_t *ptag, struct evbuffer *evbuf);$/;"	p	file:	signature:(ev_uint32_t *ptag, struct evbuffer *evbuf)
evtag_decode_tag	test/regress.c	/^int evtag_decode_tag(ev_uint32_t *pnumber, struct evbuffer *evbuf);$/;"	p	file:	signature:(ev_uint32_t *pnumber, struct evbuffer *evbuf)
evtag_encode_int	event_tagging.c	/^evtag_encode_int(struct evbuffer *evbuf, ev_uint32_t number)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t number)
evtag_encode_int	include/event2/tag.h	/^void evtag_encode_int(struct evbuffer *evbuf, ev_uint32_t number);$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t number)
evtag_encode_int64	event_tagging.c	/^evtag_encode_int64(struct evbuffer *evbuf, ev_uint64_t number)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint64_t number)
evtag_encode_int64	include/event2/tag.h	/^void evtag_encode_int64(struct evbuffer *evbuf, ev_uint64_t number);$/;"	p	signature:(struct evbuffer *evbuf, ev_uint64_t number)
evtag_encode_tag	event_tagging.c	/^evtag_encode_tag(struct evbuffer *evbuf, ev_uint32_t tag)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t tag)
evtag_encode_tag	event_tagging.c	/^int evtag_encode_tag(struct evbuffer *evbuf, ev_uint32_t tag);$/;"	p	file:	signature:(struct evbuffer *evbuf, ev_uint32_t tag)
evtag_encode_tag	test/regress.c	/^int evtag_encode_tag(struct evbuffer *evbuf, ev_uint32_t number);$/;"	p	file:	signature:(struct evbuffer *evbuf, ev_uint32_t number)
evtag_fuzz	test/regress.c	/^evtag_fuzz(void *ptr)$/;"	f	file:	signature:(void *ptr)
evtag_init	event_tagging.c	/^evtag_init(void)$/;"	f	signature:(void)
evtag_init	include/event2/tag.h	/^void evtag_init(void);$/;"	p	signature:(void)
evtag_int_test	test/regress.c	/^evtag_int_test(void *ptr)$/;"	f	file:	signature:(void *ptr)
evtag_marshal	event_tagging.c	/^evtag_marshal(struct evbuffer *evbuf, ev_uint32_t tag,$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t tag, const void *data, ev_uint32_t len)
evtag_marshal	include/event2/tag.h	/^void evtag_marshal(struct evbuffer *evbuf, ev_uint32_t tag, const void *data,$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t tag, const void *data, ev_uint32_t len)
evtag_marshal_buffer	event_tagging.c	/^evtag_marshal_buffer(struct evbuffer *evbuf, ev_uint32_t tag,$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t tag, struct evbuffer *data)
evtag_marshal_buffer	include/event2/tag.h	/^void evtag_marshal_buffer(struct evbuffer *evbuf, ev_uint32_t tag,$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t tag, struct evbuffer *data)
evtag_marshal_int	event_tagging.c	/^evtag_marshal_int(struct evbuffer *evbuf, ev_uint32_t tag, ev_uint32_t integer)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t tag, ev_uint32_t integer)
evtag_marshal_int	include/event2/tag.h	/^void evtag_marshal_int(struct evbuffer *evbuf, ev_uint32_t tag,$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t tag, ev_uint32_t integer)
evtag_marshal_int64	event_tagging.c	/^evtag_marshal_int64(struct evbuffer *evbuf, ev_uint32_t tag,$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t tag, ev_uint64_t integer)
evtag_marshal_int64	include/event2/tag.h	/^void evtag_marshal_int64(struct evbuffer *evbuf, ev_uint32_t tag,$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t tag, ev_uint64_t integer)
evtag_marshal_string	event_tagging.c	/^evtag_marshal_string(struct evbuffer *buf, ev_uint32_t tag, const char *string)$/;"	f	signature:(struct evbuffer *buf, ev_uint32_t tag, const char *string)
evtag_marshal_string	include/event2/tag.h	/^void evtag_marshal_string(struct evbuffer *buf, ev_uint32_t tag,$/;"	p	signature:(struct evbuffer *buf, ev_uint32_t tag, const char *string)
evtag_marshal_timeval	event_tagging.c	/^evtag_marshal_timeval(struct evbuffer *evbuf, ev_uint32_t tag, struct timeval *tv)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t tag, struct timeval *tv)
evtag_marshal_timeval	include/event2/tag.h	/^void evtag_marshal_timeval(struct evbuffer *evbuf, ev_uint32_t tag,$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t tag, struct timeval *tv)
evtag_payload_length	event_tagging.c	/^evtag_payload_length(struct evbuffer *evbuf, ev_uint32_t *plength)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t *plength)
evtag_payload_length	include/event2/tag.h	/^int evtag_payload_length(struct evbuffer *evbuf, ev_uint32_t *plength);$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t *plength)
evtag_peek	event_tagging.c	/^evtag_peek(struct evbuffer *evbuf, ev_uint32_t *ptag)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t *ptag)
evtag_peek	include/event2/tag.h	/^int evtag_peek(struct evbuffer *evbuf, ev_uint32_t *ptag);$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t *ptag)
evtag_peek_length	event_tagging.c	/^evtag_peek_length(struct evbuffer *evbuf, ev_uint32_t *plength)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t *plength)
evtag_peek_length	include/event2/tag.h	/^int evtag_peek_length(struct evbuffer *evbuf, ev_uint32_t *plength);$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t *plength)
evtag_tag_encoding	test/regress.c	/^evtag_tag_encoding(void *ptr)$/;"	f	file:	signature:(void *ptr)
evtag_test_peek	test/regress.c	/^evtag_test_peek(void *ptr)$/;"	f	file:	signature:(void *ptr)
evtag_testcases	test/regress.c	/^struct testcase_t evtag_testcases[] = {$/;"	v	typeref:struct:testcase_t
evtag_unmarshal	event_tagging.c	/^evtag_unmarshal(struct evbuffer *src, ev_uint32_t *ptag, struct evbuffer *dst)$/;"	f	signature:(struct evbuffer *src, ev_uint32_t *ptag, struct evbuffer *dst)
evtag_unmarshal	include/event2/tag.h	/^int evtag_unmarshal(struct evbuffer *src, ev_uint32_t *ptag,$/;"	p	signature:(struct evbuffer *src, ev_uint32_t *ptag, struct evbuffer *dst)
evtag_unmarshal_fixed	event_tagging.c	/^evtag_unmarshal_fixed(struct evbuffer *src, ev_uint32_t need_tag, void *data,$/;"	f	signature:(struct evbuffer *src, ev_uint32_t need_tag, void *data, size_t len)
evtag_unmarshal_fixed	include/event2/tag.h	/^int evtag_unmarshal_fixed(struct evbuffer *src, ev_uint32_t need_tag,$/;"	p	signature:(struct evbuffer *src, ev_uint32_t need_tag, void *data, size_t len)
evtag_unmarshal_header	event_tagging.c	/^evtag_unmarshal_header(struct evbuffer *evbuf, ev_uint32_t *ptag)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t *ptag)
evtag_unmarshal_header	include/event2/tag.h	/^int evtag_unmarshal_header(struct evbuffer *evbuf, ev_uint32_t *ptag);$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t *ptag)
evtag_unmarshal_int	event_tagging.c	/^evtag_unmarshal_int(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t need_tag, ev_uint32_t *pinteger)
evtag_unmarshal_int	include/event2/tag.h	/^int evtag_unmarshal_int(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t need_tag, ev_uint32_t *pinteger)
evtag_unmarshal_int64	event_tagging.c	/^evtag_unmarshal_int64(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t need_tag, ev_uint64_t *pinteger)
evtag_unmarshal_int64	include/event2/tag.h	/^int evtag_unmarshal_int64(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t need_tag, ev_uint64_t *pinteger)
evtag_unmarshal_string	event_tagging.c	/^evtag_unmarshal_string(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t need_tag, char **pstring)
evtag_unmarshal_string	include/event2/tag.h	/^int evtag_unmarshal_string(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t need_tag, char **pstring)
evtag_unmarshal_timeval	event_tagging.c	/^evtag_unmarshal_timeval(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t need_tag, struct timeval *ptv)
evtag_unmarshal_timeval	include/event2/tag.h	/^int evtag_unmarshal_timeval(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t need_tag, struct timeval *ptv)
evthread_condition_callbacks	include/event2/thread.h	/^struct evthread_condition_callbacks {$/;"	s
evthread_condition_callbacks::alloc_condition	include/event2/thread.h	/^	void *(*alloc_condition)(unsigned condtype);$/;"	m	struct:evthread_condition_callbacks	access:public
evthread_condition_callbacks::condition_api_version	include/event2/thread.h	/^	int condition_api_version;$/;"	m	struct:evthread_condition_callbacks	access:public
evthread_condition_callbacks::free_condition	include/event2/thread.h	/^	void (*free_condition)(void *cond);$/;"	m	struct:evthread_condition_callbacks	access:public
evthread_condition_callbacks::signal_condition	include/event2/thread.h	/^	int (*signal_condition)(void *cond, int broadcast);$/;"	m	struct:evthread_condition_callbacks	access:public
evthread_condition_callbacks::wait_condition	include/event2/thread.h	/^	int (*wait_condition)(void *cond, void *lock,$/;"	m	struct:evthread_condition_callbacks	access:public
evthread_debug_lock_mark_locked	evthread.c	/^evthread_debug_lock_mark_locked(unsigned mode, struct debug_lock *lock)$/;"	f	file:	signature:(unsigned mode, struct debug_lock *lock)
evthread_debug_lock_mark_unlocked	evthread.c	/^evthread_debug_lock_mark_unlocked(unsigned mode, struct debug_lock *lock)$/;"	f	file:	signature:(unsigned mode, struct debug_lock *lock)
evthread_enable_lock_debuging	evthread.c	/^evthread_enable_lock_debuging(void)$/;"	f	signature:(void)
evthread_enable_lock_debuging	include/event2/thread.h	/^void evthread_enable_lock_debuging(void);$/;"	p	signature:(void)
evthread_lock_callbacks	include/event2/thread.h	/^struct evthread_lock_callbacks {$/;"	s
evthread_lock_callbacks::alloc	include/event2/thread.h	/^	void *(*alloc)(unsigned locktype);$/;"	m	struct:evthread_lock_callbacks	access:public
evthread_lock_callbacks::free	include/event2/thread.h	/^	void (*free)(void *lock, unsigned locktype);$/;"	m	struct:evthread_lock_callbacks	access:public
evthread_lock_callbacks::lock	include/event2/thread.h	/^	int (*lock)(unsigned mode, void *lock);$/;"	m	struct:evthread_lock_callbacks	access:public
evthread_lock_callbacks::lock_api_version	include/event2/thread.h	/^	int lock_api_version;$/;"	m	struct:evthread_lock_callbacks	access:public
evthread_lock_callbacks::supported_locktypes	include/event2/thread.h	/^	unsigned supported_locktypes;$/;"	m	struct:evthread_lock_callbacks	access:public
evthread_lock_callbacks::unlock	include/event2/thread.h	/^	int (*unlock)(unsigned mode, void *lock);$/;"	m	struct:evthread_lock_callbacks	access:public
evthread_make_base_notifiable	event.c	/^evthread_make_base_notifiable(struct event_base *base)$/;"	f	signature:(struct event_base *base)
evthread_make_base_notifiable	include/event2/thread.h	/^int evthread_make_base_notifiable(struct event_base *base);$/;"	p	signature:(struct event_base *base)
evthread_notify_base	event.c	/^evthread_notify_base(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
evthread_notify_base	event.c	/^static int	evthread_notify_base(struct event_base *base);$/;"	p	file:	signature:(struct event_base *base)
evthread_notify_base_default	event.c	/^evthread_notify_base_default(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
evthread_notify_base_eventfd	event.c	/^evthread_notify_base_eventfd(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
evthread_notify_drain_default	event.c	/^evthread_notify_drain_default(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
evthread_notify_drain_eventfd	event.c	/^evthread_notify_drain_eventfd(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
evthread_posix_cond_alloc	evthread_pthread.c	/^evthread_posix_cond_alloc(unsigned condflags)$/;"	f	file:	signature:(unsigned condflags)
evthread_posix_cond_free	evthread_pthread.c	/^evthread_posix_cond_free(void *_cond)$/;"	f	file:	signature:(void *_cond)
evthread_posix_cond_signal	evthread_pthread.c	/^evthread_posix_cond_signal(void *_cond, int broadcast)$/;"	f	file:	signature:(void *_cond, int broadcast)
evthread_posix_cond_wait	evthread_pthread.c	/^evthread_posix_cond_wait(void *_cond, void *_lock, const struct timeval *tv)$/;"	f	file:	signature:(void *_cond, void *_lock, const struct timeval *tv)
evthread_posix_get_id	evthread_pthread.c	/^evthread_posix_get_id(void)$/;"	f	file:	signature:(void)
evthread_posix_lock	evthread_pthread.c	/^evthread_posix_lock(unsigned mode, void *_lock)$/;"	f	file:	signature:(unsigned mode, void *_lock)
evthread_posix_lock_alloc	evthread_pthread.c	/^evthread_posix_lock_alloc(unsigned locktype)$/;"	f	file:	signature:(unsigned locktype)
evthread_posix_lock_free	evthread_pthread.c	/^evthread_posix_lock_free(void *_lock, unsigned locktype)$/;"	f	file:	signature:(void *_lock, unsigned locktype)
evthread_posix_unlock	evthread_pthread.c	/^evthread_posix_unlock(unsigned mode, void *_lock)$/;"	f	file:	signature:(unsigned mode, void *_lock)
evthread_set_condition_callbacks	evthread.c	/^evthread_set_condition_callbacks(const struct evthread_condition_callbacks *cbs)$/;"	f	signature:(const struct evthread_condition_callbacks *cbs)
evthread_set_condition_callbacks	include/event2/thread.h	/^int evthread_set_condition_callbacks($/;"	p	signature:( const struct evthread_condition_callbacks *)
evthread_set_id_callback	evthread.c	/^evthread_set_id_callback(unsigned long (*id_fn)(void))$/;"	f	signature:(unsigned long (*id_fn)(void))
evthread_set_id_callback	include/event2/thread.h	/^void evthread_set_id_callback($/;"	p	signature:( unsigned long (*id_fn)(void))
evthread_set_lock_callbacks	evthread.c	/^evthread_set_lock_callbacks(const struct evthread_lock_callbacks *cbs)$/;"	f	signature:(const struct evthread_lock_callbacks *cbs)
evthread_set_lock_callbacks	include/event2/thread.h	/^int evthread_set_lock_callbacks(const struct evthread_lock_callbacks *);$/;"	p	signature:(const struct evthread_lock_callbacks *)
evthread_setup_global_lock_	evthread-internal.h	/^void *evthread_setup_global_lock_(void *lock_, unsigned locktype,$/;"	p	signature:(void *lock_, unsigned locktype, int enable_locks)
evthread_setup_global_lock_	evthread.c	/^evthread_setup_global_lock_(void *lock_, unsigned locktype, int enable_locks)$/;"	f	signature:(void *lock_, unsigned locktype, int enable_locks)
evthread_use_pthreads	evthread_pthread.c	/^evthread_use_pthreads(void)$/;"	f	signature:(void)
evthread_use_pthreads	include/event2/thread.h	/^int evthread_use_pthreads(void);$/;"	p	signature:(void)
evthread_use_windows_threads	evthread_win32.c	/^evthread_use_windows_threads(void)$/;"	f	signature:(void)
evthread_use_windows_threads	include/event2/thread.h	/^int evthread_use_windows_threads(void);$/;"	p	signature:(void)
evthread_win32_cond	evthread_win32.c	/^struct evthread_win32_cond {$/;"	s	file:
evthread_win32_cond::event	evthread_win32.c	/^	HANDLE event;$/;"	m	struct:evthread_win32_cond	file:	access:public
evthread_win32_cond::generation	evthread_win32.c	/^	int generation;$/;"	m	struct:evthread_win32_cond	file:	access:public
evthread_win32_cond::lock	evthread_win32.c	/^	CRITICAL_SECTION lock;$/;"	m	struct:evthread_win32_cond	file:	access:public
evthread_win32_cond::n_to_wake	evthread_win32.c	/^	int n_to_wake;$/;"	m	struct:evthread_win32_cond	file:	access:public
evthread_win32_cond::n_waiting	evthread_win32.c	/^	int n_waiting;$/;"	m	struct:evthread_win32_cond	file:	access:public
evthread_win32_cond_alloc	evthread_win32.c	/^evthread_win32_cond_alloc(unsigned flags)$/;"	f	file:	signature:(unsigned flags)
evthread_win32_cond_free	evthread_win32.c	/^evthread_win32_cond_free(void *_cond)$/;"	f	file:	signature:(void *_cond)
evthread_win32_cond_signal	evthread_win32.c	/^evthread_win32_cond_signal(void *_cond, int broadcast)$/;"	f	file:	signature:(void *_cond, int broadcast)
evthread_win32_cond_wait	evthread_win32.c	/^evthread_win32_cond_wait(void *_cond, void *_lock, const struct timeval *tv)$/;"	f	file:	signature:(void *_cond, void *_lock, const struct timeval *tv)
evthread_win32_condvar_alloc	evthread_win32.c	/^evthread_win32_condvar_alloc(unsigned condflags)$/;"	f	file:	signature:(unsigned condflags)
evthread_win32_condvar_free	evthread_win32.c	/^evthread_win32_condvar_free(void *_cond)$/;"	f	file:	signature:(void *_cond)
evthread_win32_condvar_init	evthread_win32.c	/^evthread_win32_condvar_init(void)$/;"	f	file:	signature:(void)
evthread_win32_condvar_signal	evthread_win32.c	/^evthread_win32_condvar_signal(void *_cond, int broadcast)$/;"	f	file:	signature:(void *_cond, int broadcast)
evthread_win32_condvar_wait	evthread_win32.c	/^evthread_win32_condvar_wait(void *_cond, void *_lock, const struct timeval *tv)$/;"	f	file:	signature:(void *_cond, void *_lock, const struct timeval *tv)
evthread_win32_get_id	evthread_win32.c	/^evthread_win32_get_id(void)$/;"	f	file:	signature:(void)
evthread_win32_lock	evthread_win32.c	/^evthread_win32_lock(unsigned mode, void *_lock)$/;"	f	file:	signature:(unsigned mode, void *_lock)
evthread_win32_lock_create	evthread_win32.c	/^evthread_win32_lock_create(unsigned locktype)$/;"	f	file:	signature:(unsigned locktype)
evthread_win32_lock_free	evthread_win32.c	/^evthread_win32_lock_free(void *_lock, unsigned locktype)$/;"	f	file:	signature:(void *_lock, unsigned locktype)
evthread_win32_unlock	evthread_win32.c	/^evthread_win32_unlock(unsigned mode, void *_lock)$/;"	f	file:	signature:(unsigned mode, void *_lock)
evtimer_add	include/event2/event.h	757;"	d
evtimer_assign	include/event2/event.h	754;"	d
evtimer_del	include/event2/event.h	758;"	d
evtimer_initialized	include/event2/event.h	760;"	d
evtimer_new	include/event2/event.h	756;"	d
evtimer_pending	include/event2/event.h	759;"	d
evtimer_set	include/event2/event_compat.h	176;"	d
evutil_addrinfo	include/event2/util.h	/^struct evutil_addrinfo {$/;"	s
evutil_addrinfo	include/event2/util.h	506;"	d
evutil_addrinfo::ai_addr	include/event2/util.h	/^	struct sockaddr  *ai_addr; \/* binary address *\/$/;"	m	struct:evutil_addrinfo	typeref:struct:evutil_addrinfo::sockaddr	access:public
evutil_addrinfo::ai_addrlen	include/event2/util.h	/^	size_t  ai_addrlen;   \/* length of ai_addr *\/$/;"	m	struct:evutil_addrinfo	access:public
evutil_addrinfo::ai_canonname	include/event2/util.h	/^	char   *ai_canonname; \/* canonical name for nodename *\/$/;"	m	struct:evutil_addrinfo	access:public
evutil_addrinfo::ai_family	include/event2/util.h	/^	int     ai_family;    \/* PF_xxx *\/$/;"	m	struct:evutil_addrinfo	access:public
evutil_addrinfo::ai_flags	include/event2/util.h	/^	int     ai_flags;     \/* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST *\/$/;"	m	struct:evutil_addrinfo	access:public
evutil_addrinfo::ai_next	include/event2/util.h	/^	struct evutil_addrinfo  *ai_next; \/* next structure in linked list *\/$/;"	m	struct:evutil_addrinfo	typeref:struct:evutil_addrinfo::evutil_addrinfo	access:public
evutil_addrinfo::ai_protocol	include/event2/util.h	/^	int     ai_protocol;  \/* 0 or IPPROTO_xxx for IPv4 and IPv6 *\/$/;"	m	struct:evutil_addrinfo	access:public
evutil_addrinfo::ai_socktype	include/event2/util.h	/^	int     ai_socktype;  \/* SOCK_xxx *\/$/;"	m	struct:evutil_addrinfo	access:public
evutil_addrinfo_append	evutil.c	/^evutil_addrinfo_append(struct evutil_addrinfo *first,$/;"	f	signature:(struct evutil_addrinfo *first, struct evutil_addrinfo *append)
evutil_addrinfo_append	util-internal.h	/^struct evutil_addrinfo *evutil_addrinfo_append(struct evutil_addrinfo *first,$/;"	p	signature:(struct evutil_addrinfo *first, struct evutil_addrinfo *append)
evutil_adjust_hints_for_addrconfig	evutil.c	/^evutil_adjust_hints_for_addrconfig(struct evutil_addrinfo *hints)$/;"	f	signature:(struct evutil_addrinfo *hints)
evutil_adjust_hints_for_addrconfig	util-internal.h	/^void evutil_adjust_hints_for_addrconfig(struct evutil_addrinfo *hints);$/;"	p	signature:(struct evutil_addrinfo *hints)
evutil_ascii_strcasecmp	evutil.c	/^evutil_ascii_strcasecmp(const char *s1, const char *s2)$/;"	f	signature:(const char *s1, const char *s2)
evutil_ascii_strcasecmp	include/event2/util.h	/^int evutil_ascii_strcasecmp(const char *str1, const char *str2);$/;"	p	signature:(const char *str1, const char *str2)
evutil_ascii_strncasecmp	evutil.c	/^int evutil_ascii_strncasecmp(const char *s1, const char *s2, size_t n)$/;"	f	signature:(const char *s1, const char *s2, size_t n)
evutil_ascii_strncasecmp	include/event2/util.h	/^int evutil_ascii_strncasecmp(const char *str1, const char *str2, size_t n);$/;"	p	signature:(const char *str1, const char *str2, size_t n)
evutil_check_interfaces	evutil.c	/^evutil_check_interfaces(int force_recheck)$/;"	f	file:	signature:(int force_recheck)
evutil_closesocket	evutil.c	/^evutil_closesocket(evutil_socket_t sock)$/;"	f	signature:(evutil_socket_t sock)
evutil_closesocket	include/event2/util.h	/^int evutil_closesocket(evutil_socket_t sock);$/;"	p	signature:(evutil_socket_t sock)
evutil_ersatz_socketpair	evutil.c	/^evutil_ersatz_socketpair(int family, int type, int protocol,$/;"	f	signature:(int family, int type, int protocol, evutil_socket_t fd[2])
evutil_ersatz_socketpair	util-internal.h	/^int evutil_ersatz_socketpair(int, int , int, evutil_socket_t[]);$/;"	p	signature:(int, int , int, evutil_socket_t[])
evutil_format_sockaddr_port	evutil.c	/^evutil_format_sockaddr_port(const struct sockaddr *sa, char *out, size_t outlen)$/;"	f	signature:(const struct sockaddr *sa, char *out, size_t outlen)
evutil_format_sockaddr_port	util-internal.h	/^const char *evutil_format_sockaddr_port(const struct sockaddr *sa, char *out, size_t outlen);$/;"	p	signature:(const struct sockaddr *sa, char *out, size_t outlen)
evutil_freeaddrinfo	evutil.c	/^evutil_freeaddrinfo(struct evutil_addrinfo *ai)$/;"	f	signature:(struct evutil_addrinfo *ai)
evutil_freeaddrinfo	include/event2/util.h	/^void evutil_freeaddrinfo(struct evutil_addrinfo *ai);$/;"	p	signature:(struct evutil_addrinfo *ai)
evutil_gai_strerror	evutil.c	/^evutil_gai_strerror(int err)$/;"	f	signature:(int err)
evutil_gai_strerror	include/event2/util.h	/^const char *evutil_gai_strerror(int err);$/;"	p	signature:(int err)
evutil_getaddrinfo	evutil.c	/^evutil_getaddrinfo(const char *nodename, const char *servname,$/;"	f	signature:(const char *nodename, const char *servname, const struct evutil_addrinfo *hints_in, struct evutil_addrinfo **res)
evutil_getaddrinfo	include/event2/util.h	/^int evutil_getaddrinfo(const char *nodename, const char *servname,$/;"	p	signature:(const char *nodename, const char *servname, const struct evutil_addrinfo *hints_in, struct evutil_addrinfo **res)
evutil_getaddrinfo_async	evutil.c	/^evutil_getaddrinfo_async(struct evdns_base *dns_base,$/;"	f	signature:(struct evdns_base *dns_base, const char *nodename, const char *servname, const struct evutil_addrinfo *hints_in, void (*cb)(int, struct evutil_addrinfo *, void *), void *arg)
evutil_getaddrinfo_async	util-internal.h	/^int evutil_getaddrinfo_async(struct evdns_base *dns_base,$/;"	p	signature:(struct evdns_base *dns_base, const char *nodename, const char *servname, const struct evutil_addrinfo *hints_in, void (*cb)(int, struct evutil_addrinfo *, void *), void *arg)
evutil_getaddrinfo_common	evutil.c	/^evutil_getaddrinfo_common(const char *nodename, const char *servname,$/;"	f	signature:(const char *nodename, const char *servname, struct evutil_addrinfo *hints, struct evutil_addrinfo **res, int *portnum)
evutil_getaddrinfo_common	util-internal.h	/^int evutil_getaddrinfo_common(const char *nodename, const char *servname,$/;"	p	signature:(const char *nodename, const char *servname, struct evutil_addrinfo *hints, struct evutil_addrinfo **res, int *portnum)
evutil_getaddrinfo_infer_protocols	evutil.c	/^evutil_getaddrinfo_infer_protocols(struct evutil_addrinfo *hints)$/;"	f	file:	signature:(struct evutil_addrinfo *hints)
evutil_getenv	evutil.c	/^evutil_getenv(const char *varname)$/;"	f	signature:(const char *varname)
evutil_getenv	util-internal.h	/^const char *evutil_getenv(const char *name);$/;"	p	signature:(const char *name)
evutil_gettimeofday	evutil.c	/^evutil_gettimeofday(struct timeval *tv, struct timezone *tz)$/;"	f	signature:(struct timeval *tv, struct timezone *tz)
evutil_gettimeofday	include/event2/util.h	/^int evutil_gettimeofday(struct timeval *tv, struct timezone *tz);$/;"	p	signature:(struct timeval *tv, struct timezone *tz)
evutil_gettimeofday	include/event2/util.h	435;"	d
evutil_hex_char_to_int	evutil.c	/^evutil_hex_char_to_int(char c)$/;"	f	signature:(char c)
evutil_hex_char_to_int	util-internal.h	/^int evutil_hex_char_to_int(char c);$/;"	p	signature:(char c)
evutil_inet_ntop	evutil.c	/^evutil_inet_ntop(int af, const void *src, char *dst, size_t len)$/;"	f	signature:(int af, const void *src, char *dst, size_t len)
evutil_inet_ntop	include/event2/util.h	/^const char *evutil_inet_ntop(int af, const void *src, char *dst, size_t len);$/;"	p	signature:(int af, const void *src, char *dst, size_t len)
evutil_inet_pton	evutil.c	/^evutil_inet_pton(int af, const char *src, void *dst)$/;"	f	signature:(int af, const char *src, void *dst)
evutil_inet_pton	include/event2/util.h	/^int evutil_inet_pton(int af, const char *src, void *dst);$/;"	p	signature:(int af, const char *src, void *dst)
evutil_issetugid	evutil.c	/^evutil_issetugid(void)$/;"	f	file:	signature:(void)
evutil_load_windows_system_library	evutil.c	/^evutil_load_windows_system_library(const TCHAR *library_name)$/;"	f	signature:(const TCHAR *library_name)
evutil_load_windows_system_library	util-internal.h	/^HANDLE evutil_load_windows_system_library(const TCHAR *library_name);$/;"	p	signature:(const TCHAR *library_name)
evutil_make_listen_socket_reuseable	evutil.c	/^evutil_make_listen_socket_reuseable(evutil_socket_t sock)$/;"	f	signature:(evutil_socket_t sock)
evutil_make_listen_socket_reuseable	include/event2/util.h	/^int evutil_make_listen_socket_reuseable(evutil_socket_t sock);$/;"	p	signature:(evutil_socket_t sock)
evutil_make_socket_closeonexec	evutil.c	/^evutil_make_socket_closeonexec(evutil_socket_t fd)$/;"	f	signature:(evutil_socket_t fd)
evutil_make_socket_closeonexec	include/event2/util.h	/^int evutil_make_socket_closeonexec(evutil_socket_t sock);$/;"	p	signature:(evutil_socket_t sock)
evutil_make_socket_nonblocking	evutil.c	/^evutil_make_socket_nonblocking(evutil_socket_t fd)$/;"	f	signature:(evutil_socket_t fd)
evutil_make_socket_nonblocking	include/event2/util.h	/^int evutil_make_socket_nonblocking(evutil_socket_t sock);$/;"	p	signature:(evutil_socket_t sock)
evutil_memclear_	evutil.c	/^evutil_memclear_(void *mem, size_t len)$/;"	f	signature:(void *mem, size_t len)
evutil_memclear_	util-internal.h	/^void evutil_memclear_(void *mem, size_t len);$/;"	p	signature:(void *mem, size_t len)
evutil_memset_volatile_	evutil.c	/^void * (*volatile evutil_memset_volatile_)(void *, int, size_t) = memset;$/;"	v
evutil_new_addrinfo	evutil.c	/^evutil_new_addrinfo(struct sockaddr *sa, ev_socklen_t socklen,$/;"	f	signature:(struct sockaddr *sa, ev_socklen_t socklen, const struct evutil_addrinfo *hints)
evutil_new_addrinfo	util-internal.h	/^struct evutil_addrinfo *evutil_new_addrinfo(struct sockaddr *sa,$/;"	p	signature:(struct sockaddr *sa, ev_socklen_t socklen, const struct evutil_addrinfo *hints)
evutil_offsetof	include/event2/util.h	424;"	d
evutil_offsetof	include/event2/util.h	426;"	d
evutil_open_closeonexec	evutil.c	/^evutil_open_closeonexec(const char *pathname, int flags, unsigned mode)$/;"	f	signature:(const char *pathname, int flags, unsigned mode)
evutil_open_closeonexec	util-internal.h	/^int evutil_open_closeonexec(const char *pathname, int flags, unsigned mode);$/;"	p	signature:(const char *pathname, int flags, unsigned mode)
evutil_parse_servname	evutil.c	/^evutil_parse_servname(const char *servname, const char *protocol,$/;"	f	file:	signature:(const char *servname, const char *protocol, const struct evutil_addrinfo *hints)
evutil_parse_sockaddr_port	evutil.c	/^evutil_parse_sockaddr_port(const char *ip_as_string, struct sockaddr *out, int *outlen)$/;"	f	signature:(const char *ip_as_string, struct sockaddr *out, int *outlen)
evutil_parse_sockaddr_port	include/event2/util.h	/^int evutil_parse_sockaddr_port(const char *str, struct sockaddr *out, int *outlen);$/;"	p	signature:(const char *str, struct sockaddr *out, int *outlen)
evutil_read_file	evutil.c	/^evutil_read_file(const char *filename, char **content_out, size_t *len_out,$/;"	f	signature:(const char *filename, char **content_out, size_t *len_out, int is_binary)
evutil_read_file	util-internal.h	/^int evutil_read_file(const char *filename, char **content_out, size_t *len_out,$/;"	p	signature:(const char *filename, char **content_out, size_t *len_out, int is_binary)
evutil_resolve	util-internal.h	/^int evutil_resolve(int family, const char *hostname, struct sockaddr *sa,$/;"	p	signature:(int family, const char *hostname, struct sockaddr *sa, ev_socklen_t *socklen, int port)
evutil_secure_rng_add_bytes	evutil_rand.c	/^evutil_secure_rng_add_bytes(const char *buf, size_t n)$/;"	f	signature:(const char *buf, size_t n)
evutil_secure_rng_add_bytes	include/event2/util.h	/^void evutil_secure_rng_add_bytes(const char *dat, size_t datlen);$/;"	p	signature:(const char *dat, size_t datlen)
evutil_secure_rng_get_bytes	evutil_rand.c	/^evutil_secure_rng_get_bytes(void *buf, size_t n)$/;"	f	signature:(void *buf, size_t n)
evutil_secure_rng_get_bytes	include/event2/util.h	/^void evutil_secure_rng_get_bytes(void *buf, size_t n);$/;"	p	signature:(void *buf, size_t n)
evutil_secure_rng_global_setup_locks_	evthread-internal.h	/^int evutil_secure_rng_global_setup_locks_(const int enable_locks);$/;"	p	signature:(const int enable_locks)
evutil_secure_rng_global_setup_locks_	evutil_rand.c	/^evutil_secure_rng_global_setup_locks_(const int enable_locks)$/;"	f	signature:(const int enable_locks)
evutil_secure_rng_init	evutil_rand.c	/^evutil_secure_rng_init(void)$/;"	f	signature:(void)
evutil_secure_rng_init	include/event2/util.h	/^int evutil_secure_rng_init(void);$/;"	p	signature:(void)
evutil_secure_rng_set_urandom_device_file	evutil_rand.c	/^evutil_secure_rng_set_urandom_device_file(char *fname)$/;"	f	signature:(char *fname)
evutil_secure_rng_set_urandom_device_file	include/event2/util.h	/^int evutil_secure_rng_set_urandom_device_file(char *fname);$/;"	p	signature:(char *fname)
evutil_set_evdns_getaddrinfo_fn	evutil.c	/^evutil_set_evdns_getaddrinfo_fn(evdns_getaddrinfo_fn fn)$/;"	f	signature:(evdns_getaddrinfo_fn fn)
evutil_set_evdns_getaddrinfo_fn	util-internal.h	/^void evutil_set_evdns_getaddrinfo_fn(evdns_getaddrinfo_fn fn);$/;"	p	signature:(evdns_getaddrinfo_fn fn)
evutil_snprintf	evutil.c	/^evutil_snprintf(char *buf, size_t buflen, const char *format, ...)$/;"	f	signature:(char *buf, size_t buflen, const char *format, ...)
evutil_snprintf	include/event2/util.h	/^int evutil_snprintf(char *buf, size_t buflen, const char *format, ...)$/;"	p	signature:(char *buf, size_t buflen, const char *format, ...)
evutil_sockaddr_cmp	evutil.c	/^evutil_sockaddr_cmp(const struct sockaddr *sa1, const struct sockaddr *sa2,$/;"	f	signature:(const struct sockaddr *sa1, const struct sockaddr *sa2, int include_port)
evutil_sockaddr_cmp	include/event2/util.h	/^int evutil_sockaddr_cmp(const struct sockaddr *sa1, const struct sockaddr *sa2,$/;"	p	signature:(const struct sockaddr *sa1, const struct sockaddr *sa2, int include_port)
evutil_sockaddr_is_loopback	evutil.c	/^evutil_sockaddr_is_loopback(const struct sockaddr *addr)$/;"	f	signature:(const struct sockaddr *addr)
evutil_sockaddr_is_loopback	util-internal.h	/^int evutil_sockaddr_is_loopback(const struct sockaddr *sa);$/;"	p	signature:(const struct sockaddr *sa)
evutil_socket_connect	evutil.c	/^evutil_socket_connect(evutil_socket_t *fd_ptr, struct sockaddr *sa, int socklen)$/;"	f	signature:(evutil_socket_t *fd_ptr, struct sockaddr *sa, int socklen)
evutil_socket_connect	util-internal.h	/^int evutil_socket_connect(evutil_socket_t *fd_ptr, struct sockaddr *sa, int socklen);$/;"	p	signature:(evutil_socket_t *fd_ptr, struct sockaddr *sa, int socklen)
evutil_socket_error_to_string	evutil.c	/^evutil_socket_error_to_string(int errcode)$/;"	f	signature:(int errcode)
evutil_socket_error_to_string	include/event2/util.h	/^const char *evutil_socket_error_to_string(int errcode);$/;"	p	signature:(int errcode)
evutil_socket_error_to_string	include/event2/util.h	359;"	d
evutil_socket_error_to_string	include/event2/util.h	366;"	d
evutil_socket_finished_connecting	evutil.c	/^evutil_socket_finished_connecting(evutil_socket_t fd)$/;"	f	signature:(evutil_socket_t fd)
evutil_socket_finished_connecting	util-internal.h	/^int evutil_socket_finished_connecting(evutil_socket_t fd);$/;"	p	signature:(evutil_socket_t fd)
evutil_socket_geterror	evutil.c	/^evutil_socket_geterror(evutil_socket_t sock)$/;"	f	signature:(evutil_socket_t sock)
evutil_socket_geterror	include/event2/util.h	/^int evutil_socket_geterror(evutil_socket_t sock);$/;"	p	signature:(evutil_socket_t sock)
evutil_socket_geterror	include/event2/util.h	357;"	d
evutil_socket_geterror	include/event2/util.h	365;"	d
evutil_socket_t	include/event2/util.h	272;"	d
evutil_socket_t	include/event2/util.h	274;"	d
evutil_socketpair	evutil.c	/^evutil_socketpair(int family, int type, int protocol, evutil_socket_t fd[2])$/;"	f	signature:(int family, int type, int protocol, evutil_socket_t fd[2])
evutil_socketpair	include/event2/util.h	/^int evutil_socketpair(int d, int type, int protocol, evutil_socket_t sv[2]);$/;"	p	signature:(int d, int type, int protocol, evutil_socket_t sv[2])
evutil_strtoll	evutil.c	/^evutil_strtoll(const char *s, char **endptr, int base)$/;"	f	signature:(const char *s, char **endptr, int base)
evutil_strtoll	include/event2/util.h	/^ev_int64_t evutil_strtoll(const char *s, char **endptr, int base);$/;"	p	signature:(const char *s, char **endptr, int base)
evutil_timeradd	include/event2/util.h	379;"	d
evutil_timeradd	include/event2/util.h	382;"	d
evutil_timerclear	include/event2/util.h	403;"	d
evutil_timerclear	include/event2/util.h	405;"	d
evutil_timercmp	include/event2/util.h	411;"	d
evutil_timerisset	include/event2/util.h	417;"	d
evutil_timerisset	include/event2/util.h	419;"	d
evutil_timersub	include/event2/util.h	380;"	d
evutil_timersub	include/event2/util.h	391;"	d
evutil_tv_to_msec	evutil.c	/^evutil_tv_to_msec(const struct timeval *tv)$/;"	f	signature:(const struct timeval *tv)
evutil_tv_to_msec	util-internal.h	/^long evutil_tv_to_msec(const struct timeval *tv);$/;"	p	signature:(const struct timeval *tv)
evutil_unparse_protoname	evutil.c	/^evutil_unparse_protoname(int proto)$/;"	f	file:	signature:(int proto)
evutil_vsnprintf	evutil.c	/^evutil_vsnprintf(char *buf, size_t buflen, const char *format, va_list ap)$/;"	f	signature:(char *buf, size_t buflen, const char *format, va_list ap)
evutil_vsnprintf	include/event2/util.h	/^int evutil_vsnprintf(char *buf, size_t buflen, const char *format, va_list ap)$/;"	p	signature:(char *buf, size_t buflen, const char *format, va_list ap)
example_struct	test/regress_util.c	/^struct example_struct {$/;"	s	file:
example_struct::a	test/regress_util.c	/^	const char *a;$/;"	m	struct:example_struct	file:	access:public
example_struct::b	test/regress_util.c	/^	const char *b;$/;"	m	struct:example_struct	file:	access:public
example_struct::c	test/regress_util.c	/^	long c;$/;"	m	struct:example_struct	file:	access:public
exec_prefix	Makefile	/^exec_prefix = ${prefix}$/;"	m
exec_prefix	include/Makefile	/^exec_prefix = ${prefix}$/;"	m
exec_prefix	sample/Makefile	/^exec_prefix = ${prefix}$/;"	m
exec_prefix	test/Makefile	/^exec_prefix = ${prefix}$/;"	m
exit_base	test/regress_dns.c	/^static struct event_base *exit_base;$/;"	v	typeref:struct:event_base	file:
exit_base	test/regress_http.c	/^static struct event_base *exit_base;$/;"	v	typeref:struct:event_base	file:
exit_base	test/regress_ssl.c	/^static struct event_base *exit_base = NULL;$/;"	v	typeref:struct:event_base	file:
exit_base_on_no_pending_results	test/regress_dns.c	/^static struct event_base *exit_base_on_no_pending_results = NULL;$/;"	v	typeref:struct:event_base	file:
exit_failed	test/rpcgen_wrapper.sh	/^exit_failed() {$/;"	f
exit_reuse	test/rpcgen_wrapper.sh	/^exit_reuse() {$/;"	f
exit_updated	test/rpcgen_wrapper.sh	/^exit_updated() {$/;"	f
exset_out	win32select.c	/^	struct win_fd_set *exset_out;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
extension	sample/http-server.c	/^	const char *extension;$/;"	m	struct:table_entry	file:	access:public
extension_fns_initialized	event_iocp.c	/^static int extension_fns_initialized = 0;$/;"	v	file:
extra	evbuffer-internal.h	/^	void *extra;$/;"	m	struct:evbuffer_chain_reference	access:public
fail_cb	test/regress.c	/^fail_cb(evutil_socket_t fd, short events, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short events, void *arg)
fail_server_cb	test/regress_dns.c	/^fail_server_cb(struct evdns_server_request *req, void *data)$/;"	f	file:	signature:(struct evdns_server_request *req, void *data)
failed_times	evdns.c	/^	int failed_times;  \/* number of times which we have given this server a chance *\/$/;"	m	struct:nameserver	file:	access:public
failing_malloc	test/regress_buffer.c	/^failing_malloc(size_t how_much)$/;"	f	file:	signature:(size_t how_much)
fake_getnameinfo	http.c	/^fake_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,$/;"	f	file:	signature:(const struct sockaddr *sa, size_t salen, char *host, size_t hostlen, char *serv, size_t servlen, int flags)
family	listener.c	/^	ev_uint8_t family;$/;"	m	struct:accepting_socket	file:	access:public
fatal_fn	log.c	/^static event_fatal_cb fatal_fn = NULL;$/;"	v	file:
fatal_want_message	test/regress_util.c	/^static const char *fatal_want_message = NULL;$/;"	v	file:
fatal_want_severity	test/regress_util.c	/^static int fatal_want_severity = 0;$/;"	v	file:
fatalfn	test/regress_util.c	/^fatalfn(int exitcode)$/;"	f	file:	signature:(int exitcode)
fd	buffer_iocp.c	/^	evutil_socket_t fd;$/;"	m	struct:evbuffer_overlapped	file:	access:public
fd	bufferevent-internal.h	/^	evutil_socket_t fd;$/;"	m	union:bufferevent_ctrl_data	access:public
fd	changelist-internal.h	/^	evutil_socket_t fd;$/;"	m	struct:event_change	access:public
fd	evbuffer-internal.h	/^	int fd;	\/**< the fd associated with this chain *\/$/;"	m	struct:evbuffer_chain_fd	access:public
fd	evmap.c	/^	evutil_socket_t fd;$/;"	m	struct:event_map_entry	file:	access:public
fd	http-internal.h	/^	evutil_socket_t fd;$/;"	m	struct:evhttp_connection	access:public
fd	listener.c	/^	evutil_socket_t fd;$/;"	m	struct:evconnlistener_iocp	file:	access:public
fd	test/regress_http.c	/^	evutil_socket_t fd;$/;"	m	struct:terminate_state	file:	access:public
fd_array	win32select.c	/^	SOCKET fd_array[1];$/;"	m	struct:win_fd_set	file:	access:public
fd_count	win32select.c	/^	u_int fd_count;$/;"	m	struct:win_fd_set	file:	access:public
fd_info	evport.c	/^struct fd_info {$/;"	s	file:
fd_info::fdi_what	evport.c	/^	short fdi_what;		\/* combinations of EV_READ and EV_WRITE *\/$/;"	m	struct:fd_info	file:	access:public
fd_is_set	bufferevent_openssl.c	/^	unsigned fd_is_set : 1;$/;"	m	struct:bufferevent_openssl	file:	access:public
fd_mask	select.c	/^typedef unsigned long fd_mask;$/;"	t	file:
fd_set_copy	win32select.c	/^fd_set_copy(struct win_fd_set *out, const struct win_fd_set *in)$/;"	f	file:	signature:(struct win_fd_set *out, const struct win_fd_set *in)
fdi_what	evport.c	/^	short fdi_what;		\/* combinations of EV_READ and EV_WRITE *\/$/;"	m	struct:fd_info	file:	access:public
fdinfo_len	event-internal.h	/^	size_t fdinfo_len;$/;"	m	struct:eventop	access:public
features	event-internal.h	/^	enum event_method_feature features;$/;"	m	struct:eventop	typeref:enum:eventop::event_method_feature	access:public
fifo_read	sample/event-test.c	/^fifo_read(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
filetime_diff	test/test-changelist.c	/^filetime_diff(const FILETIME *ftStart, const FILETIME *ftEnd)$/;"	f	file:	signature:(const FILETIME *ftStart, const FILETIME *ftEnd)
filetime_to_100nsec	test/test-changelist.c	/^filetime_to_100nsec(const FILETIME *ft)$/;"	f	file:	signature:(const FILETIME *ft)
find_eol_char	buffer.c	/^find_eol_char(char *s, size_t len)$/;"	f	file:	signature:(char *s, size_t len)
find_hosts_entry	evdns.c	/^find_hosts_entry(struct evdns_base *base, const char *hostname,$/;"	f	file:	signature:(struct evdns_base *base, const char *hostname, struct hosts_entry *find_after)
fired	test/bench.c	/^static int count, writes, fired;$/;"	v	file:
fired	test/bench_cascade.c	/^static int fired;$/;"	v	file:
first	evbuffer-internal.h	/^	struct evbuffer_chain *first;$/;"	m	struct:evbuffer	typeref:struct:evbuffer::evbuffer_chain	access:public
first_pinned	buffer_iocp.c	/^	struct evbuffer_chain *first_pinned;$/;"	m	struct:evbuffer_overlapped	typeref:struct:evbuffer_overlapped::evbuffer_chain	file:	access:public
flags	evbuffer-internal.h	/^	ev_uint32_t flags;$/;"	m	struct:evbuffer	access:public
flags	evbuffer-internal.h	/^	ev_uint32_t flags;$/;"	m	struct:evbuffer_cb_entry	access:public
flags	evbuffer-internal.h	/^	unsigned flags;$/;"	m	struct:evbuffer_chain	access:public
flags	event-internal.h	/^	enum event_base_config_flag flags;$/;"	m	struct:event_base	typeref:enum:event_base::event_base_config_flag	access:public
flags	event-internal.h	/^	enum event_base_config_flag flags;$/;"	m	struct:event_config	typeref:enum:event_config::event_base_config_flag	access:public
flags	http-internal.h	/^	int flags;$/;"	m	struct:evhttp_connection	access:public
flags	http.c	/^	unsigned flags;$/;"	m	struct:evhttp_uri	file:	access:public
flags	include/event2/dns_struct.h	/^	int flags;$/;"	m	struct:evdns_server_request	access:public
flags	include/event2/http_struct.h	/^	int flags;$/;"	m	struct:evhttp_request	access:public
flags	listener.c	/^	unsigned flags;$/;"	m	struct:evconnlistener	file:	access:public
flags	test/tinytest.h	/^	unsigned long flags; \/**< Bitfield of TT_* flags. *\/$/;"	m	struct:testcase_t	access:public
flush	bufferevent-internal.h	/^	int (*flush)(struct bufferevent *, short, enum bufferevent_flush_mode);$/;"	m	struct:bufferevent_ops	access:public
fn	test/tinytest.h	/^	testcase_fn fn; \/**< The function to run to implement this case. *\/$/;"	m	struct:testcase_t	access:public
fragment	http.c	/^	char *fragment; \/* fragment or NULL *\/$/;"	m	struct:evhttp_uri	file:	access:public
free	include/event2/thread.h	/^	void (*free)(void *lock, unsigned locktype);$/;"	m	struct:evthread_lock_callbacks	access:public
free_and_unlock_accepting_socket	listener.c	/^free_and_unlock_accepting_socket(struct accepting_socket *as)$/;"	f	file:	signature:(struct accepting_socket *as)
free_condition	include/event2/thread.h	/^	void (*free_condition)(void *cond);$/;"	m	struct:evthread_condition_callbacks	access:public
free_context	bufferevent_filter.c	/^	void (*free_context)(void *);$/;"	m	struct:bufferevent_filtered	file:	access:public
free_getaddrinfo_request	evdns.c	/^free_getaddrinfo_request(struct evdns_getaddrinfo_request *data)$/;"	f	file:	signature:(struct evdns_getaddrinfo_request *data)
free_on_cb	listener.c	/^	unsigned free_on_cb:1;$/;"	m	struct:accepting_socket	file:	access:public
freeze_end	evbuffer-internal.h	/^	unsigned freeze_end : 1;$/;"	m	struct:evbuffer	access:public
freeze_start	evbuffer-internal.h	/^	unsigned freeze_start : 1;$/;"	m	struct:evbuffer	access:public
frob_socket	test/bench_httpclient.c	/^frob_socket(evutil_socket_t sock)$/;"	f	file:	signature:(evutil_socket_t sock)
fstat	evutil.c	86;"	d	file:
fstat	sample/http-server.c	52;"	d	file:
func_append	config.status	/^func_append ()\\$/;"	f
func_append	configure	/^func_append ()\\$/;"	f
func_append	libtool	/^func_append ()$/;"	f
func_append	ltmain.sh	/^func_append ()$/;"	f
func_append_quoted	config.status	/^func_append_quoted ()\\$/;"	f
func_append_quoted	configure	/^func_append_quoted ()\\$/;"	f
func_append_quoted	libtool	/^func_append_quoted ()$/;"	f
func_append_quoted	ltmain.sh	/^func_append_quoted ()$/;"	f
func_arith	config.status	/^func_arith ()\\$/;"	f
func_arith	configure	/^func_arith ()\\$/;"	f
func_arith	libtool	/^func_arith ()$/;"	f
func_arith	ltmain.sh	/^func_arith ()$/;"	f
func_basename	config.status	/^func_basename ()\\$/;"	f
func_basename	configure	/^func_basename ()\\$/;"	f
func_basename	libtool	/^func_basename ()$/;"	f
func_basename	ltmain.sh	/^func_basename ()$/;"	f
func_check_version_match	libtool	/^func_check_version_match ()$/;"	f
func_check_version_match	ltmain.sh	/^func_check_version_match ()$/;"	f
func_config	libtool	/^func_config ()$/;"	f
func_config	ltmain.sh	/^func_config ()$/;"	f
func_convert_core_file_wine_to_w32	libtool	/^func_convert_core_file_wine_to_w32 ()$/;"	f
func_convert_core_file_wine_to_w32	ltmain.sh	/^func_convert_core_file_wine_to_w32 ()$/;"	f
func_convert_core_msys_to_w32	libtool	/^func_convert_core_msys_to_w32 ()$/;"	f
func_convert_core_msys_to_w32	ltmain.sh	/^func_convert_core_msys_to_w32 ()$/;"	f
func_convert_core_path_wine_to_w32	libtool	/^func_convert_core_path_wine_to_w32 ()$/;"	f
func_convert_core_path_wine_to_w32	ltmain.sh	/^func_convert_core_path_wine_to_w32 ()$/;"	f
func_convert_file_check	libtool	/^func_convert_file_check ()$/;"	f
func_convert_file_check	ltmain.sh	/^func_convert_file_check ()$/;"	f
func_convert_file_cygwin_to_w32	libtool	/^func_convert_file_cygwin_to_w32 ()$/;"	f
func_convert_file_cygwin_to_w32	ltmain.sh	/^func_convert_file_cygwin_to_w32 ()$/;"	f
func_convert_file_msys_to_cygwin	libtool	/^func_convert_file_msys_to_cygwin ()$/;"	f
func_convert_file_msys_to_cygwin	ltmain.sh	/^func_convert_file_msys_to_cygwin ()$/;"	f
func_convert_file_msys_to_w32	libtool	/^func_convert_file_msys_to_w32 ()$/;"	f
func_convert_file_msys_to_w32	ltmain.sh	/^func_convert_file_msys_to_w32 ()$/;"	f
func_convert_file_nix_to_cygwin	libtool	/^func_convert_file_nix_to_cygwin ()$/;"	f
func_convert_file_nix_to_cygwin	ltmain.sh	/^func_convert_file_nix_to_cygwin ()$/;"	f
func_convert_file_nix_to_w32	libtool	/^func_convert_file_nix_to_w32 ()$/;"	f
func_convert_file_nix_to_w32	ltmain.sh	/^func_convert_file_nix_to_w32 ()$/;"	f
func_convert_file_noop	libtool	/^func_convert_file_noop ()$/;"	f
func_convert_file_noop	ltmain.sh	/^func_convert_file_noop ()$/;"	f
func_convert_path_check	libtool	/^func_convert_path_check ()$/;"	f
func_convert_path_check	ltmain.sh	/^func_convert_path_check ()$/;"	f
func_convert_path_cygwin_to_w32	libtool	/^func_convert_path_cygwin_to_w32 ()$/;"	f
func_convert_path_cygwin_to_w32	ltmain.sh	/^func_convert_path_cygwin_to_w32 ()$/;"	f
func_convert_path_front_back_pathsep	libtool	/^func_convert_path_front_back_pathsep ()$/;"	f
func_convert_path_front_back_pathsep	ltmain.sh	/^func_convert_path_front_back_pathsep ()$/;"	f
func_convert_path_msys_to_cygwin	libtool	/^func_convert_path_msys_to_cygwin ()$/;"	f
func_convert_path_msys_to_cygwin	ltmain.sh	/^func_convert_path_msys_to_cygwin ()$/;"	f
func_convert_path_msys_to_w32	libtool	/^func_convert_path_msys_to_w32 ()$/;"	f
func_convert_path_msys_to_w32	ltmain.sh	/^func_convert_path_msys_to_w32 ()$/;"	f
func_convert_path_nix_to_cygwin	libtool	/^func_convert_path_nix_to_cygwin ()$/;"	f
func_convert_path_nix_to_cygwin	ltmain.sh	/^func_convert_path_nix_to_cygwin ()$/;"	f
func_convert_path_nix_to_w32	libtool	/^func_convert_path_nix_to_w32 ()$/;"	f
func_convert_path_nix_to_w32	ltmain.sh	/^func_convert_path_nix_to_w32 ()$/;"	f
func_convert_path_noop	libtool	/^func_convert_path_noop ()$/;"	f
func_convert_path_noop	ltmain.sh	/^func_convert_path_noop ()$/;"	f
func_cygming_dll_for_implib	libtool	/^func_cygming_dll_for_implib ()$/;"	f
func_cygming_dll_for_implib	ltmain.sh	/^func_cygming_dll_for_implib ()$/;"	f
func_cygming_dll_for_implib_fallback	libtool	/^func_cygming_dll_for_implib_fallback ()$/;"	f
func_cygming_dll_for_implib_fallback	ltmain.sh	/^func_cygming_dll_for_implib_fallback ()$/;"	f
func_cygming_dll_for_implib_fallback_core	libtool	/^func_cygming_dll_for_implib_fallback_core ()$/;"	f
func_cygming_dll_for_implib_fallback_core	ltmain.sh	/^func_cygming_dll_for_implib_fallback_core ()$/;"	f
func_cygming_gnu_implib_p	libtool	/^func_cygming_gnu_implib_p ()$/;"	f
func_cygming_gnu_implib_p	ltmain.sh	/^func_cygming_gnu_implib_p ()$/;"	f
func_cygming_ms_implib_p	libtool	/^func_cygming_ms_implib_p ()$/;"	f
func_cygming_ms_implib_p	ltmain.sh	/^func_cygming_ms_implib_p ()$/;"	f
func_cygpath	libtool	/^func_cygpath ()$/;"	f
func_cygpath	ltmain.sh	/^func_cygpath ()$/;"	f
func_dirname	config.status	/^func_dirname ()\\$/;"	f
func_dirname	configure	/^func_dirname ()\\$/;"	f
func_dirname	libtool	/^func_dirname ()$/;"	f
func_dirname	ltmain.sh	/^func_dirname ()$/;"	f
func_dirname_and_basename	config.status	/^func_dirname_and_basename ()\\$/;"	f
func_dirname_and_basename	configure	/^func_dirname_and_basename ()\\$/;"	f
func_dirname_and_basename	libtool	/^func_dirname_and_basename ()$/;"	f
func_dirname_and_basename	ltmain.sh	/^func_dirname_and_basename ()$/;"	f
func_echo	libtool	/^func_echo ()$/;"	f
func_echo	ltmain.sh	/^func_echo ()$/;"	f
func_echo_all	configure	/^func_echo_all ()$/;"	f
func_echo_all	libtool	/^func_echo_all ()$/;"	f
func_echo_all	ltmain.sh	/^func_echo_all ()$/;"	f
func_emit_cwrapperexe_src	libtool	/^func_emit_cwrapperexe_src ()$/;"	f
func_emit_cwrapperexe_src	ltmain.sh	/^func_emit_cwrapperexe_src ()$/;"	f
func_emit_wrapper	libtool	/^func_emit_wrapper ()$/;"	f
func_emit_wrapper	ltmain.sh	/^func_emit_wrapper ()$/;"	f
func_enable_tag	libtool	/^func_enable_tag ()$/;"	f
func_enable_tag	ltmain.sh	/^func_enable_tag ()$/;"	f
func_error	libtool	/^func_error ()$/;"	f
func_error	ltmain.sh	/^func_error ()$/;"	f
func_exec_program	libtool	/^func_exec_program ()$/;"	f
func_exec_program	ltmain.sh	/^func_exec_program ()$/;"	f
func_exec_program	sample/dns-example	/^func_exec_program ()$/;"	f
func_exec_program	sample/event-test	/^func_exec_program ()$/;"	f
func_exec_program	sample/hello-world	/^func_exec_program ()$/;"	f
func_exec_program	sample/http-server	/^func_exec_program ()$/;"	f
func_exec_program	sample/signal-test	/^func_exec_program ()$/;"	f
func_exec_program	sample/time-test	/^func_exec_program ()$/;"	f
func_exec_program	test/bench	/^func_exec_program ()$/;"	f
func_exec_program	test/bench_cascade	/^func_exec_program ()$/;"	f
func_exec_program	test/bench_http	/^func_exec_program ()$/;"	f
func_exec_program	test/bench_httpclient	/^func_exec_program ()$/;"	f
func_exec_program	test/regress	/^func_exec_program ()$/;"	f
func_exec_program	test/test-changelist	/^func_exec_program ()$/;"	f
func_exec_program	test/test-eof	/^func_exec_program ()$/;"	f
func_exec_program	test/test-init	/^func_exec_program ()$/;"	f
func_exec_program	test/test-ratelim	/^func_exec_program ()$/;"	f
func_exec_program	test/test-time	/^func_exec_program ()$/;"	f
func_exec_program	test/test-weof	/^func_exec_program ()$/;"	f
func_exec_program_core	libtool	/^func_exec_program_core ()$/;"	f
func_exec_program_core	ltmain.sh	/^func_exec_program_core ()$/;"	f
func_exec_program_core	sample/dns-example	/^func_exec_program_core ()$/;"	f
func_exec_program_core	sample/event-test	/^func_exec_program_core ()$/;"	f
func_exec_program_core	sample/hello-world	/^func_exec_program_core ()$/;"	f
func_exec_program_core	sample/http-server	/^func_exec_program_core ()$/;"	f
func_exec_program_core	sample/signal-test	/^func_exec_program_core ()$/;"	f
func_exec_program_core	sample/time-test	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test/bench	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test/bench_cascade	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test/bench_http	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test/bench_httpclient	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test/regress	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test/test-changelist	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test/test-eof	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test/test-init	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test/test-ratelim	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test/test-time	/^func_exec_program_core ()$/;"	f
func_exec_program_core	test/test-weof	/^func_exec_program_core ()$/;"	f
func_execute_cmds	libtool	/^func_execute_cmds ()$/;"	f
func_execute_cmds	ltmain.sh	/^func_execute_cmds ()$/;"	f
func_extract_an_archive	libtool	/^func_extract_an_archive ()$/;"	f
func_extract_an_archive	ltmain.sh	/^func_extract_an_archive ()$/;"	f
func_extract_archives	libtool	/^func_extract_archives ()$/;"	f
func_extract_archives	ltmain.sh	/^func_extract_archives ()$/;"	f
func_fallback_echo	config.status	/^func_fallback_echo ()$/;"	f
func_fallback_echo	configure	/^  func_fallback_echo ()$/;"	f
func_fallback_echo	configure	/^func_fallback_echo ()$/;"	f
func_fallback_echo	libtool	/^func_fallback_echo ()$/;"	f
func_fallback_echo	ltmain.sh	/^func_fallback_echo ()$/;"	f
func_fallback_echo	sample/dns-example	/^func_fallback_echo ()$/;"	f
func_fallback_echo	sample/event-test	/^func_fallback_echo ()$/;"	f
func_fallback_echo	sample/hello-world	/^func_fallback_echo ()$/;"	f
func_fallback_echo	sample/http-server	/^func_fallback_echo ()$/;"	f
func_fallback_echo	sample/signal-test	/^func_fallback_echo ()$/;"	f
func_fallback_echo	sample/time-test	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test/bench	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test/bench_cascade	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test/bench_http	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test/bench_httpclient	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test/regress	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test/test-changelist	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test/test-eof	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test/test-init	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test/test-ratelim	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test/test-time	/^func_fallback_echo ()$/;"	f
func_fallback_echo	test/test-weof	/^func_fallback_echo ()$/;"	f
func_fatal_configuration	libtool	/^func_fatal_configuration ()$/;"	f
func_fatal_configuration	ltmain.sh	/^func_fatal_configuration ()$/;"	f
func_fatal_error	libtool	/^func_fatal_error ()$/;"	f
func_fatal_error	ltmain.sh	/^func_fatal_error ()$/;"	f
func_fatal_help	libtool	/^func_fatal_help ()$/;"	f
func_fatal_help	ltmain.sh	/^func_fatal_help ()$/;"	f
func_features	libtool	/^func_features ()$/;"	f
func_features	ltmain.sh	/^func_features ()$/;"	f
func_generate_dlsyms	libtool	/^func_generate_dlsyms ()$/;"	f
func_generate_dlsyms	ltmain.sh	/^func_generate_dlsyms ()$/;"	f
func_grep	libtool	/^func_grep ()$/;"	f
func_grep	ltmain.sh	/^func_grep ()$/;"	f
func_help	libtool	/^func_help ()$/;"	f
func_help	ltmain.sh	/^func_help ()$/;"	f
func_infer_tag	libtool	/^func_infer_tag ()$/;"	f
func_infer_tag	ltmain.sh	/^func_infer_tag ()$/;"	f
func_init_to_host_path_cmd	libtool	/^func_init_to_host_path_cmd ()$/;"	f
func_init_to_host_path_cmd	ltmain.sh	/^func_init_to_host_path_cmd ()$/;"	f
func_lalib_p	libtool	/^func_lalib_p ()$/;"	f
func_lalib_p	ltmain.sh	/^func_lalib_p ()$/;"	f
func_lalib_unsafe_p	libtool	/^func_lalib_unsafe_p ()$/;"	f
func_lalib_unsafe_p	ltmain.sh	/^func_lalib_unsafe_p ()$/;"	f
func_len	config.status	/^func_len ()\\$/;"	f
func_len	configure	/^func_len ()\\$/;"	f
func_len	libtool	/^func_len ()$/;"	f
func_len	ltmain.sh	/^func_len ()$/;"	f
func_lo2o	config.status	/^func_lo2o ()\\$/;"	f
func_lo2o	configure	/^func_lo2o ()\\$/;"	f
func_lo2o	libtool	/^func_lo2o ()$/;"	f
func_lo2o	ltmain.sh	/^func_lo2o ()$/;"	f
func_lt_dump_args	libtool	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	ltmain.sh	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	sample/dns-example	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	sample/event-test	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	sample/hello-world	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	sample/http-server	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	sample/signal-test	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	sample/time-test	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test/bench	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test/bench_cascade	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test/bench_http	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test/bench_httpclient	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test/regress	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test/test-changelist	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test/test-eof	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test/test-init	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test/test-ratelim	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test/test-time	/^func_lt_dump_args ()$/;"	f
func_lt_dump_args	test/test-weof	/^func_lt_dump_args ()$/;"	f
func_ltwrapper_executable_p	libtool	/^func_ltwrapper_executable_p ()$/;"	f
func_ltwrapper_executable_p	ltmain.sh	/^func_ltwrapper_executable_p ()$/;"	f
func_ltwrapper_p	libtool	/^func_ltwrapper_p ()$/;"	f
func_ltwrapper_p	ltmain.sh	/^func_ltwrapper_p ()$/;"	f
func_ltwrapper_script_p	libtool	/^func_ltwrapper_script_p ()$/;"	f
func_ltwrapper_script_p	ltmain.sh	/^func_ltwrapper_script_p ()$/;"	f
func_ltwrapper_scriptname	libtool	/^func_ltwrapper_scriptname ()$/;"	f
func_ltwrapper_scriptname	ltmain.sh	/^func_ltwrapper_scriptname ()$/;"	f
func_missing_arg	libtool	/^func_missing_arg ()$/;"	f
func_missing_arg	ltmain.sh	/^func_missing_arg ()$/;"	f
func_mkdir_p	libtool	/^func_mkdir_p ()$/;"	f
func_mkdir_p	ltmain.sh	/^func_mkdir_p ()$/;"	f
func_mktempdir	libtool	/^func_mktempdir ()$/;"	f
func_mktempdir	ltmain.sh	/^func_mktempdir ()$/;"	f
func_mode_compile	libtool	/^func_mode_compile ()$/;"	f
func_mode_compile	ltmain.sh	/^func_mode_compile ()$/;"	f
func_mode_execute	libtool	/^func_mode_execute ()$/;"	f
func_mode_execute	ltmain.sh	/^func_mode_execute ()$/;"	f
func_mode_finish	libtool	/^func_mode_finish ()$/;"	f
func_mode_finish	ltmain.sh	/^func_mode_finish ()$/;"	f
func_mode_help	libtool	/^func_mode_help ()$/;"	f
func_mode_help	ltmain.sh	/^func_mode_help ()$/;"	f
func_mode_install	libtool	/^func_mode_install ()$/;"	f
func_mode_install	ltmain.sh	/^func_mode_install ()$/;"	f
func_mode_link	libtool	/^func_mode_link ()$/;"	f
func_mode_link	ltmain.sh	/^func_mode_link ()$/;"	f
func_mode_uninstall	libtool	/^func_mode_uninstall ()$/;"	f
func_mode_uninstall	ltmain.sh	/^func_mode_uninstall ()$/;"	f
func_normal_abspath	libtool	/^func_normal_abspath ()$/;"	f
func_normal_abspath	ltmain.sh	/^func_normal_abspath ()$/;"	f
func_parse_lt_options	libtool	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	ltmain.sh	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	sample/dns-example	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	sample/event-test	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	sample/hello-world	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	sample/http-server	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	sample/signal-test	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	sample/time-test	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test/bench	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test/bench_cascade	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test/bench_http	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test/bench_httpclient	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test/regress	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test/test-changelist	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test/test-eof	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test/test-init	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test/test-ratelim	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test/test-time	/^func_parse_lt_options ()$/;"	f
func_parse_lt_options	test/test-weof	/^func_parse_lt_options ()$/;"	f
func_quote_for_eval	libtool	/^func_quote_for_eval ()$/;"	f
func_quote_for_eval	ltmain.sh	/^func_quote_for_eval ()$/;"	f
func_quote_for_expand	libtool	/^func_quote_for_expand ()$/;"	f
func_quote_for_expand	ltmain.sh	/^func_quote_for_expand ()$/;"	f
func_relative_path	libtool	/^func_relative_path ()$/;"	f
func_relative_path	ltmain.sh	/^func_relative_path ()$/;"	f
func_replace_sysroot	libtool	/^func_replace_sysroot ()$/;"	f
func_replace_sysroot	ltmain.sh	/^func_replace_sysroot ()$/;"	f
func_resolve_sysroot	libtool	/^func_resolve_sysroot ()$/;"	f
func_resolve_sysroot	ltmain.sh	/^func_resolve_sysroot ()$/;"	f
func_show_eval	libtool	/^func_show_eval ()$/;"	f
func_show_eval	ltmain.sh	/^func_show_eval ()$/;"	f
func_show_eval_locale	libtool	/^func_show_eval_locale ()$/;"	f
func_show_eval_locale	ltmain.sh	/^func_show_eval_locale ()$/;"	f
func_source	libtool	/^func_source ()$/;"	f
func_source	ltmain.sh	/^func_source ()$/;"	f
func_split_long_opt	config.status	/^func_split_long_opt ()\\$/;"	f
func_split_long_opt	configure	/^func_split_long_opt ()\\$/;"	f
func_split_long_opt	libtool	/^func_split_long_opt ()$/;"	f
func_split_long_opt	ltmain.sh	/^func_split_long_opt ()$/;"	f
func_split_short_opt	config.status	/^func_split_short_opt ()\\$/;"	f
func_split_short_opt	configure	/^func_split_short_opt ()\\$/;"	f
func_split_short_opt	libtool	/^func_split_short_opt ()$/;"	f
func_split_short_opt	ltmain.sh	/^func_split_short_opt ()$/;"	f
func_stripname	config.status	/^func_stripname ()\\$/;"	f
func_stripname	configure	/^func_stripname ()\\$/;"	f
func_stripname	libtool	/^func_stripname ()$/;"	f
func_stripname	ltmain.sh	/^func_stripname ()$/;"	f
func_to_host_file	libtool	/^func_to_host_file ()$/;"	f
func_to_host_file	ltmain.sh	/^func_to_host_file ()$/;"	f
func_to_host_path	libtool	/^func_to_host_path ()$/;"	f
func_to_host_path	ltmain.sh	/^func_to_host_path ()$/;"	f
func_to_tool_file	libtool	/^func_to_tool_file ()$/;"	f
func_to_tool_file	ltmain.sh	/^func_to_tool_file ()$/;"	f
func_tr_sh	libtool	/^func_tr_sh ()$/;"	f
func_tr_sh	ltmain.sh	/^func_tr_sh ()$/;"	f
func_usage	libtool	/^func_usage ()$/;"	f
func_usage	ltmain.sh	/^func_usage ()$/;"	f
func_verbose	libtool	/^func_verbose ()$/;"	f
func_verbose	ltmain.sh	/^func_verbose ()$/;"	f
func_version	libtool	/^func_version ()$/;"	f
func_version	ltmain.sh	/^func_version ()$/;"	f
func_warning	libtool	/^func_warning ()$/;"	f
func_warning	ltmain.sh	/^func_warning ()$/;"	f
func_win32_import_lib_p	libtool	/^func_win32_import_lib_p ()$/;"	f
func_win32_import_lib_p	ltmain.sh	/^func_win32_import_lib_p ()$/;"	f
func_win32_libid	libtool	/^func_win32_libid ()$/;"	f
func_win32_libid	ltmain.sh	/^func_win32_libid ()$/;"	f
func_write_libtool_object	libtool	/^func_write_libtool_object ()$/;"	f
func_write_libtool_object	ltmain.sh	/^func_write_libtool_object ()$/;"	f
func_xform	config.status	/^func_xform ()\\$/;"	f
func_xform	configure	/^func_xform ()\\$/;"	f
func_xform	libtool	/^func_xform ()$/;"	f
func_xform	ltmain.sh	/^func_xform ()$/;"	f
gai_callback	sample/dns-example.c	/^gai_callback(int err, struct evutil_addrinfo *ai, void *arg)$/;"	f	file:	signature:(int err, struct evutil_addrinfo *ai, void *arg)
gai_cb	test/regress_dns.c	/^gai_cb(int err, struct evutil_addrinfo *res, void *ptr)$/;"	f	file:	signature:(int err, struct evutil_addrinfo *res, void *ptr)
gai_outcome	test/regress_dns.c	/^struct gai_outcome {$/;"	s	file:
gai_outcome::ai	test/regress_dns.c	/^	struct evutil_addrinfo *ai;$/;"	m	struct:gai_outcome	typeref:struct:gai_outcome::evutil_addrinfo	file:	access:public
gai_outcome::err	test/regress_dns.c	/^	int err;$/;"	m	struct:gai_outcome	file:	access:public
gaic_cancel_request_cb	test/regress_dns.c	/^gaic_cancel_request_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
gaic_getaddrinfo_cb	test/regress_dns.c	/^gaic_getaddrinfo_cb(int result, struct evutil_addrinfo *res, void *arg)$/;"	f	file:	signature:(int result, struct evutil_addrinfo *res, void *arg)
gaic_launch	test/regress_dns.c	/^gaic_launch(struct event_base *base, struct evdns_base *dns_base)$/;"	f	file:	signature:(struct event_base *base, struct evdns_base *dns_base)
gaic_request_status	test/regress_dns.c	/^struct gaic_request_status {$/;"	s	file:
gaic_request_status::base	test/regress_dns.c	/^	struct event_base *base;$/;"	m	struct:gaic_request_status	typeref:struct:gaic_request_status::event_base	file:	access:public
gaic_request_status::cancel_event	test/regress_dns.c	/^	struct event cancel_event;$/;"	m	struct:gaic_request_status	typeref:struct:gaic_request_status::event	file:	access:public
gaic_request_status::canceled	test/regress_dns.c	/^	int canceled;$/;"	m	struct:gaic_request_status	file:	access:public
gaic_request_status::dns_base	test/regress_dns.c	/^	struct evdns_base *dns_base;$/;"	m	struct:gaic_request_status	typeref:struct:gaic_request_status::evdns_base	file:	access:public
gaic_request_status::magic	test/regress_dns.c	/^	int magic;$/;"	m	struct:gaic_request_status	file:	access:public
gaic_request_status::request	test/regress_dns.c	/^	struct evdns_getaddrinfo_request *request;$/;"	m	struct:gaic_request_status	typeref:struct:gaic_request_status::evdns_getaddrinfo_request	file:	access:public
gaic_server_cb	test/regress_dns.c	/^gaic_server_cb(struct evdns_server_request *req, void *arg)$/;"	f	file:	signature:(struct evdns_server_request *req, void *arg)
gencb	http-internal.h	/^	void (*gencb)(struct evhttp_request *req, void *);$/;"	m	struct:evhttp	access:public
gencbarg	http-internal.h	/^	void *gencbarg;$/;"	m	struct:evhttp	access:public
generation	evthread_win32.c	/^	int generation;$/;"	m	struct:evthread_win32_cond	file:	access:public
generic_dns_callback	test/regress_dns.c	/^generic_dns_callback(int result, char type, int count, int ttl, void *addresses,$/;"	f	file:	signature:(int result, char type, int count, int ttl, void *addresses, void *arg)
generic_dns_callback_result	test/regress_dns.c	/^struct generic_dns_callback_result {$/;"	s	file:
generic_dns_callback_result::addrs	test/regress_dns.c	/^	void *addrs;$/;"	m	struct:generic_dns_callback_result	file:	access:public
generic_dns_callback_result::addrs_buf	test/regress_dns.c	/^	char addrs_buf[256];$/;"	m	struct:generic_dns_callback_result	file:	access:public
generic_dns_callback_result::addrs_len	test/regress_dns.c	/^	size_t addrs_len;$/;"	m	struct:generic_dns_callback_result	file:	access:public
generic_dns_callback_result::count	test/regress_dns.c	/^	int count;$/;"	m	struct:generic_dns_callback_result	file:	access:public
generic_dns_callback_result::result	test/regress_dns.c	/^	int result;$/;"	m	struct:generic_dns_callback_result	file:	access:public
generic_dns_callback_result::ttl	test/regress_dns.c	/^	int ttl;$/;"	m	struct:generic_dns_callback_result	file:	access:public
generic_dns_callback_result::type	test/regress_dns.c	/^	char type;$/;"	m	struct:generic_dns_callback_result	file:	access:public
get_common_timeout_list	event.c	/^get_common_timeout_list(struct event_base *base, const struct timeval *tv)$/;"	f	file:	signature:(struct event_base *base, const struct timeval *tv)
get_cpu_usage	test/test-changelist.c	/^get_cpu_usage(struct cpu_usage_timer *timer, double *secElapsedOut,$/;"	f	file:	signature:(struct cpu_usage_timer *timer, double *secElapsedOut, double *secUsedOut, double *usageOut)
get_deferred_queue	http.c	1036;"	d	file:
get_extension_function	event_iocp.c	/^get_extension_function(SOCKET s, const GUID *which_fn)$/;"	f	file:	signature:(SOCKET s, const GUID *which_fn)
get_n_bytes_readable_on_socket	buffer.c	/^get_n_bytes_readable_on_socket(evutil_socket_t fd)$/;"	f	file:	signature:(evutil_socket_t fd)
get_ssl_ctx	test/regress_ssl.c	/^get_ssl_ctx(void)$/;"	f	file:	signature:(void)
getaddrinfo_ipv4_answered	evdns.c	/^	int getaddrinfo_ipv4_answered;$/;"	m	struct:evdns_base	file:	access:public
getaddrinfo_ipv4_timeouts	evdns.c	/^	int getaddrinfo_ipv4_timeouts;$/;"	m	struct:evdns_base	file:	access:public
getaddrinfo_ipv6_answered	evdns.c	/^	int getaddrinfo_ipv6_answered;$/;"	m	struct:evdns_base	file:	access:public
getaddrinfo_ipv6_timeouts	evdns.c	/^	int getaddrinfo_ipv6_timeouts;$/;"	m	struct:evdns_base	file:	access:public
getaddrinfo_merge_err	evdns.c	/^getaddrinfo_merge_err(int e1, int e2)$/;"	f	file:	signature:(int e1, int e2)
getaddrinfo_subrequest	evdns.c	/^struct getaddrinfo_subrequest {$/;"	s	file:
getaddrinfo_subrequest::r	evdns.c	/^	struct evdns_request *r;$/;"	m	struct:getaddrinfo_subrequest	typeref:struct:getaddrinfo_subrequest::evdns_request	file:	access:public
getaddrinfo_subrequest::type	evdns.c	/^	ev_uint32_t type;$/;"	m	struct:getaddrinfo_subrequest	file:	access:public
getbase	listener.c	/^	struct event_base *(*getbase)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	typeref:struct:evconnlistener_ops::getbase	file:	access:public
getcert	test/regress_ssl.c	/^getcert(void)$/;"	f	file:	signature:(void)
getfd	listener.c	/^	evutil_socket_t (*getfd)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	file:	access:public
getkey	test/regress_ssl.c	/^getkey(void)$/;"	f	file:	signature:(void)
getpid	arc4random.c	83;"	d	file:
getstate	test/regress_zlib.c	/^getstate(enum bufferevent_flush_mode state)$/;"	f	file:	signature:(enum bufferevent_flush_mode state)
gettime	event.c	/^gettime(struct event_base *base, struct timeval *tp)$/;"	f	file:	signature:(struct event_base *base, struct timeval *tp)
global_base	test/regress.c	/^struct event_base *global_base;$/;"	v	typeref:struct:event_base
global_getaddrinfo_allow_skew	evdns.c	/^	struct timeval global_getaddrinfo_allow_skew;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::timeval	file:	access:public
global_good_nameservers	evdns.c	/^	int global_good_nameservers;$/;"	m	struct:evdns_base	file:	access:public
global_max_nameserver_timeout	evdns.c	/^	int global_max_nameserver_timeout;$/;"	m	struct:evdns_base	file:	access:public
global_max_reissues	evdns.c	/^	int global_max_reissues;  \/* a reissue occurs when we get some errors from the server *\/$/;"	m	struct:evdns_base	file:	access:public
global_max_requests_inflight	evdns.c	/^	int global_max_requests_inflight;$/;"	m	struct:evdns_base	file:	access:public
global_max_retransmits	evdns.c	/^	int global_max_retransmits;  \/* number of times we'll retransmit a request which timed out *\/$/;"	m	struct:evdns_base	file:	access:public
global_nameserver_probe_initial_timeout	evdns.c	/^	struct timeval global_nameserver_probe_initial_timeout;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::timeval	file:	access:public
global_outgoing_address	evdns.c	/^	struct sockaddr_storage global_outgoing_address;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::sockaddr_storage	file:	access:public
global_outgoing_addrlen	evdns.c	/^	ev_socklen_t global_outgoing_addrlen;$/;"	m	struct:evdns_base	file:	access:public
global_randomize_case	evdns.c	/^	int global_randomize_case;$/;"	m	struct:evdns_base	file:	access:public
global_requests_inflight	evdns.c	/^	int global_requests_inflight;$/;"	m	struct:evdns_base	file:	access:public
global_requests_waiting	evdns.c	/^	int global_requests_waiting;$/;"	m	struct:evdns_base	file:	access:public
global_search_state	evdns.c	/^	struct search_state *global_search_state;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::search_state	file:	access:public
global_timeout	evdns.c	/^	struct timeval global_timeout;	\/* 5 seconds by default *\/$/;"	m	struct:evdns_base	typeref:struct:evdns_base::timeval	file:	access:public
got_close	test/regress_ssl.c	/^static int got_close = 0;$/;"	v	file:
got_eof	bufferevent_filter.c	/^	unsigned got_eof;$/;"	m	struct:bufferevent_filtered	file:	access:public
got_error	test/regress_ssl.c	/^static int got_error = 0;$/;"	v	file:
got_readcb	test/regress_iocp.c	/^static int got_readcb = 0;$/;"	v	file:
got_sigchld	test/regress_thread.c	/^static int got_sigchld = 0;$/;"	v	file:
gotclosecb	test/regress_http.c	/^	int gotclosecb: 1;$/;"	m	struct:terminate_state	file:	access:public
group	bufferevent-internal.h	/^	struct bufferevent_rate_limit_group *group;$/;"	m	struct:bufferevent_rate_limit	typeref:struct:bufferevent_rate_limit::bufferevent_rate_limit_group	access:public
group_bucket_cfg	test/test-ratelim.c	/^static struct ev_token_bucket_cfg *group_bucket_cfg = NULL;$/;"	v	typeref:struct:ev_token_bucket_cfg	file:
grow	evport.c	/^grow(struct evport_data *epdp, int factor)$/;"	f	file:	signature:(struct evport_data *epdp, int factor)
grow_fd_sets	win32select.c	/^grow_fd_sets(struct win32op *op, unsigned new_num_fds)$/;"	f	file:	signature:(struct win32op *op, unsigned new_num_fds)
guess_content_type	sample/http-server.c	/^guess_content_type(const char *path)$/;"	f	file:	signature:(const char *path)
had_ipv4_address	evutil.c	/^static int have_checked_interfaces, had_ipv4_address, had_ipv6_address;$/;"	v	file:
had_ipv6_address	evutil.c	/^static int have_checked_interfaces, had_ipv4_address, had_ipv6_address;$/;"	v	file:
handle	evdns.c	/^	struct evdns_request *handle;$/;"	m	struct:deferred_reply_callback	typeref:struct:deferred_reply_callback::evdns_request	file:	access:public
handle	evdns.c	/^	struct evdns_request *handle;$/;"	m	struct:request	typeref:struct:request::evdns_request	file:	access:public
handle_entry	event_iocp.c	/^handle_entry(OVERLAPPED *o, ULONG_PTR completion_key, DWORD nBytes, int ok)$/;"	f	file:	signature:(OVERLAPPED *o, ULONG_PTR completion_key, DWORD nBytes, int ok)
handle_option	test/test-ratelim.c	/^handle_option(int argc, char **argv, int *i, const struct option *opt)$/;"	f	file:	signature:(int argc, char **argv, int *i, const struct option *opt)
hash_debug_entry	event.c	/^hash_debug_entry(const struct event_debug_entry *e)$/;"	f	file:	signature:(const struct event_debug_entry *e)
hashsocket	evmap.c	/^hashsocket(struct event_map_entry *e)$/;"	f	file:	signature:(struct event_map_entry *e)
have_answer	evdns.c	/^	unsigned int have_answer : 1;$/;"	m	struct:reply	file:	access:public
have_checked_interfaces	evutil.c	/^static int have_checked_interfaces, had_ipv4_address, had_ipv6_address;$/;"	v	file:
have_closed	test/regress.c	/^static int have_closed = 0;$/;"	v	file:
have_reply	evdns.c	/^	u8 have_reply;$/;"	m	struct:deferred_reply_callback	file:	access:public
head	evdns.c	/^	struct search_domain *head;$/;"	m	struct:search_state	typeref:struct:search_state::search_domain	file:	access:public
headerdirect	event_rpcgen.py	/^headerdirect = []$/;"	v
headers_size	include/event2/http_struct.h	/^	size_t headers_size;$/;"	m	struct:evhttp_request	access:public
held_by	evthread.c	/^	unsigned long held_by;$/;"	m	struct:debug_lock	file:	access:public
hello_world_DEPENDENCIES	sample/Makefile	/^hello_world_DEPENDENCIES = $(am__DEPENDENCIES_1) ..\/libevent.la$/;"	m
hello_world_LDADD	sample/Makefile	/^hello_world_LDADD = $(LDADD)$/;"	m
hello_world_OBJECTS	sample/Makefile	/^hello_world_OBJECTS = $(am_hello_world_OBJECTS)$/;"	m
hello_world_SOURCES	sample/Makefile	/^hello_world_SOURCES = hello-world.c$/;"	m
high	include/event2/bufferevent_struct.h	/^	size_t high;$/;"	m	struct:event_watermark	access:public
hints	evdns.c	/^	struct evutil_addrinfo hints;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::evutil_addrinfo	file:	access:public
hook_meta	evrpc-internal.h	/^	struct evrpc_hook_meta *hook_meta;$/;"	m	struct:evrpc_req_generic	typeref:struct:evrpc_req_generic::evrpc_hook_meta	access:public
hook_meta	evrpc-internal.h	/^	struct evrpc_hook_meta *hook_meta;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::evrpc_hook_meta	access:public
hook_pause_cb_called	test/regress_rpc.c	/^static int hook_pause_cb_called=0;$/;"	v	file:
host	Makefile	/^host = i686-pc-linux-gnu$/;"	m
host	http.c	/^	char *host; \/* hostname, IP address, or NULL *\/$/;"	m	struct:evhttp_uri	file:	access:public
host	include/Makefile	/^host = i686-pc-linux-gnu$/;"	m
host	sample/Makefile	/^host = i686-pc-linux-gnu$/;"	m
host	test/Makefile	/^host = i686-pc-linux-gnu$/;"	m
host_alias	Makefile	/^host_alias = $/;"	m
host_alias	include/Makefile	/^host_alias = $/;"	m
host_alias	sample/Makefile	/^host_alias = $/;"	m
host_alias	test/Makefile	/^host_alias = $/;"	m
host_cache	include/event2/http_struct.h	/^	char *host_cache;$/;"	m	struct:evhttp_request	access:public
host_cpu	Makefile	/^host_cpu = i686$/;"	m
host_cpu	include/Makefile	/^host_cpu = i686$/;"	m
host_cpu	sample/Makefile	/^host_cpu = i686$/;"	m
host_cpu	test/Makefile	/^host_cpu = i686$/;"	m
host_os	Makefile	/^host_os = linux-gnu$/;"	m
host_os	include/Makefile	/^host_os = linux-gnu$/;"	m
host_os	sample/Makefile	/^host_os = linux-gnu$/;"	m
host_os	test/Makefile	/^host_os = linux-gnu$/;"	m
host_triplet	Makefile	/^host_triplet = i686-pc-linux-gnu$/;"	m
host_triplet	include/Makefile	/^host_triplet = i686-pc-linux-gnu$/;"	m
host_triplet	sample/Makefile	/^host_triplet = i686-pc-linux-gnu$/;"	m
host_triplet	test/Makefile	/^host_triplet = i686-pc-linux-gnu$/;"	m
host_vendor	Makefile	/^host_vendor = pc$/;"	m
host_vendor	include/Makefile	/^host_vendor = pc$/;"	m
host_vendor	sample/Makefile	/^host_vendor = pc$/;"	m
host_vendor	test/Makefile	/^host_vendor = pc$/;"	m
hostname	evdns.c	/^	char hostname[1];$/;"	m	struct:hosts_entry	file:	access:public
hosts_entry	evdns.c	/^struct hosts_entry {$/;"	s	file:
hosts_entry::TAILQ_ENTRY	evdns.c	/^	TAILQ_ENTRY(hosts_entry) next;$/;"	p	struct:hosts_entry	file:	access:public
hosts_entry::__anon12::sa	evdns.c	/^		struct sockaddr sa;$/;"	m	union:hosts_entry::__anon12	typeref:struct:hosts_entry::__anon12::sockaddr	file:	access:public
hosts_entry::__anon12::sin	evdns.c	/^		struct sockaddr_in sin;$/;"	m	union:hosts_entry::__anon12	typeref:struct:hosts_entry::__anon12::sockaddr_in	file:	access:public
hosts_entry::__anon12::sin6	evdns.c	/^		struct sockaddr_in6 sin6;$/;"	m	union:hosts_entry::__anon12	typeref:struct:hosts_entry::__anon12::sockaddr_in6	file:	access:public
hosts_entry::addr	evdns.c	/^	} addr;$/;"	m	struct:hosts_entry	typeref:union:hosts_entry::__anon12	file:	access:public
hosts_entry::addrlen	evdns.c	/^	int addrlen;$/;"	m	struct:hosts_entry	file:	access:public
hosts_entry::hostname	evdns.c	/^	char hostname[1];$/;"	m	struct:hosts_entry	file:	access:public
ht_improve_hash	ht-internal.h	/^ht_improve_hash(unsigned h)$/;"	f	signature:(unsigned h)
ht_string_hash	ht-internal.h	/^ht_string_hash(const char *s)$/;"	f	signature:(const char *s)
html_replace	http.c	/^html_replace(const char ch, const char **escaped)$/;"	f	file:	signature:(const char ch, const char **escaped)
htmldir	Makefile	/^htmldir = ${docdir}$/;"	m
htmldir	include/Makefile	/^htmldir = ${docdir}$/;"	m
htmldir	sample/Makefile	/^htmldir = ${docdir}$/;"	m
htmldir	test/Makefile	/^htmldir = ${docdir}$/;"	m
http	test/regress_http.c	/^static struct evhttp *http;$/;"	v	typeref:struct:evhttp	file:
http_allowed_methods_eventcb	test/regress_http.c	/^http_allowed_methods_eventcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *arg)
http_allowed_methods_test	test/regress_http.c	/^http_allowed_methods_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_bad_header_test	test/regress_http.c	/^http_bad_header_test(void *ptr)$/;"	f	file:	signature:(void *ptr)
http_bad_request_test	test/regress_http.c	/^http_bad_request_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_badreq_cb	test/regress_http.c	/^http_badreq_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_badreq_cb	test/regress_http.c	/^static void http_badreq_cb(struct evhttp_request *req, void *arg);$/;"	p	file:	signature:(struct evhttp_request *req, void *arg)
http_badreq_errorcb	test/regress_http.c	/^http_badreq_errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *arg)
http_badreq_readcb	test/regress_http.c	/^http_badreq_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
http_badreq_successcb	test/regress_http.c	/^http_badreq_successcb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
http_base_test	test/regress_http.c	/^http_base_test(void *ptr)$/;"	f	file:	signature:(void *ptr)
http_basic_cb	test/bench_http.c	/^http_basic_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_basic_cb	test/bench_http.c	/^static void http_basic_cb(struct evhttp_request *req, void *arg);$/;"	p	file:	signature:(struct evhttp_request *req, void *arg)
http_basic_cb	test/regress_http.c	/^http_basic_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_basic_cb	test/regress_http.c	/^static void http_basic_cb(struct evhttp_request *req, void *arg);$/;"	p	file:	signature:(struct evhttp_request *req, void *arg)
http_basic_test	test/regress_http.c	/^http_basic_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_bind	test/regress_http.c	/^http_bind(struct evhttp *myhttp, ev_uint16_t *pport)$/;"	f	file:	signature:(struct evhttp *myhttp, ev_uint16_t *pport)
http_cancel_test	test/regress_http.c	/^http_cancel_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_chunk_out_test	test/regress_http.c	/^http_chunk_out_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_chunked_cb	test/regress_http.c	/^http_chunked_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_chunked_cb	test/regress_http.c	/^static void http_chunked_cb(struct evhttp_request *req, void *arg);$/;"	p	file:	signature:(struct evhttp_request *req, void *arg)
http_chunked_errorcb	test/regress_http.c	/^http_chunked_errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *arg)
http_chunked_readcb	test/regress_http.c	/^http_chunked_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
http_chunked_request_done	test/regress_http.c	/^http_chunked_request_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_chunked_trickle_cb	test/regress_http.c	/^http_chunked_trickle_cb(evutil_socket_t fd, short events, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short events, void *arg)
http_chunked_writecb	test/regress_http.c	/^http_chunked_writecb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
http_close_detection_delay_test	test/regress_http.c	/^http_close_detection_delay_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_close_detection_test	test/regress_http.c	/^http_close_detection_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_complete_write	test/regress_http.c	/^http_complete_write(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
http_connect	test/regress_http.c	/^http_connect(const char *address, u_short port)$/;"	f	file:	signature:(const char *address, u_short port)
http_connection_async_test	test/regress_http.c	/^http_connection_async_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_connection_fail_done	test/regress_http.c	/^http_connection_fail_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_connection_fail_test	test/regress_http.c	/^http_connection_fail_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_connection_retry_done	test/regress_http.c	/^http_connection_retry_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_connection_retry_test	test/regress_http.c	/^http_connection_retry_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_connection_test	test/regress_http.c	/^http_connection_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_data_length_constraints_test	test/regress_http.c	/^http_data_length_constraints_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_data_length_constraints_test_done	test/regress_http.c	/^http_data_length_constraints_test_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_delay_cb	test/regress_http.c	/^http_delay_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_delay_cb	test/regress_http.c	/^static void http_delay_cb(struct evhttp_request *req, void *arg);$/;"	p	file:	signature:(struct evhttp_request *req, void *arg)
http_delay_reply	test/regress_http.c	/^http_delay_reply(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
http_delete_cb	test/regress_http.c	/^http_delete_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_delete_cb	test/regress_http.c	/^static void http_delete_cb(struct evhttp_request *req, void *arg);$/;"	p	file:	signature:(struct evhttp_request *req, void *arg)
http_delete_test	test/regress_http.c	/^http_delete_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_dispatcher_cb	test/regress_http.c	/^http_dispatcher_cb(struct evhttp_request *req, void *arg)$/;"	f	signature:(struct evhttp_request *req, void *arg)
http_dispatcher_cb	test/regress_http.c	/^static void http_dispatcher_cb(struct evhttp_request *req, void *arg);$/;"	p	file:	signature:(struct evhttp_request *req, void *arg)
http_dispatcher_test	test/regress_http.c	/^http_dispatcher_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_dispatcher_test_done	test/regress_http.c	/^http_dispatcher_test_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_do_cancel	test/regress_http.c	/^http_do_cancel(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
http_errorcb	test/regress_http.c	/^http_errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *arg)
http_failure_readcb	test/regress_http.c	/^http_failure_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
http_failure_test	test/regress_http.c	/^http_failure_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_highport_test	test/regress_http.c	/^http_highport_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_incomplete_errorcb	test/regress_http.c	/^http_incomplete_errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *arg)
http_incomplete_readcb	test/regress_http.c	/^http_incomplete_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
http_incomplete_test	test/regress_http.c	/^http_incomplete_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_incomplete_timeout_test	test/regress_http.c	/^http_incomplete_timeout_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_incomplete_writecb	test/regress_http.c	/^http_incomplete_writecb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
http_large_delay_cb	test/regress_http.c	/^http_large_delay_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_large_delay_cb	test/regress_http.c	/^static void http_large_delay_cb(struct evhttp_request *req, void *arg);$/;"	p	file:	signature:(struct evhttp_request *req, void *arg)
http_large_entity_test_done	test/regress_http.c	/^http_large_entity_test_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_make_web_server	test/regress_http.c	/^http_make_web_server(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
http_make_web_server_base	test/regress_http.c	/^static struct event_base *http_make_web_server_base=NULL;$/;"	v	typeref:struct:event_base	file:
http_multi_line_header_test	test/regress_http.c	/^http_multi_line_header_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_negative_content_length_test	test/regress_http.c	/^http_negative_content_length_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_parse_query_test	test/regress_http.c	/^http_parse_query_test(void *ptr)$/;"	f	file:	signature:(void *ptr)
http_parse_uri_test	test/regress_http.c	/^http_parse_uri_test(void *ptr)$/;"	f	file:	signature:(void *ptr)
http_persist_connection_test	test/regress_http.c	/^http_persist_connection_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_post_cb	test/regress_http.c	/^http_post_cb(struct evhttp_request *req, void *arg)$/;"	f	signature:(struct evhttp_request *req, void *arg)
http_post_cb	test/regress_http.c	/^static void http_post_cb(struct evhttp_request *req, void *arg);$/;"	p	file:	signature:(struct evhttp_request *req, void *arg)
http_post_test	test/regress_http.c	/^http_post_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_postrequest_done	test/regress_http.c	/^http_postrequest_done(struct evhttp_request *req, void *arg)$/;"	f	signature:(struct evhttp_request *req, void *arg)
http_postrequest_done	test/regress_http.c	/^void http_postrequest_done(struct evhttp_request *, void *);$/;"	p	file:	signature:(struct evhttp_request *, void *)
http_primitives	test/regress_http.c	/^http_primitives(void *ptr)$/;"	f	file:	signature:(void *ptr)
http_put_cb	test/regress_http.c	/^http_put_cb(struct evhttp_request *req, void *arg)$/;"	f	signature:(struct evhttp_request *req, void *arg)
http_put_cb	test/regress_http.c	/^static void http_put_cb(struct evhttp_request *req, void *arg);$/;"	p	file:	signature:(struct evhttp_request *req, void *arg)
http_put_test	test/regress_http.c	/^http_put_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_putrequest_done	test/regress_http.c	/^http_putrequest_done(struct evhttp_request *req, void *arg)$/;"	f	signature:(struct evhttp_request *req, void *arg)
http_putrequest_done	test/regress_http.c	/^void http_putrequest_done(struct evhttp_request *, void *);$/;"	p	file:	signature:(struct evhttp_request *, void *)
http_readcb	test/regress_http.c	/^http_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
http_ref_cb	test/bench_http.c	/^http_ref_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_req	evrpc-internal.h	/^	struct evhttp_request* http_req;$/;"	m	struct:evrpc_req_generic	typeref:struct:evrpc_req_generic::evhttp_request	access:public
http_req	include/event2/rpc_struct.h	/^	struct evhttp_request *http_req;$/;"	m	struct:evrpc_status	typeref:struct:evrpc_status::evhttp_request	access:public
http_request_bad	test/regress_http.c	/^http_request_bad(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_request_done	test/regress_http.c	/^http_request_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_request_done	test/regress_http.c	/^static void http_request_done(struct evhttp_request *, void *);$/;"	p	file:	signature:(struct evhttp_request *, void *)
http_request_empty_done	test/regress_http.c	/^http_request_empty_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_request_empty_done	test/regress_http.c	/^static void http_request_empty_done(struct evhttp_request *, void *);$/;"	p	file:	signature:(struct evhttp_request *, void *)
http_request_expect_error	test/regress_http.c	/^http_request_expect_error(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_request_never_call	test/regress_http.c	/^http_request_never_call(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_server	evrpc-internal.h	/^	struct evhttp* http_server;$/;"	m	struct:evrpc_base	typeref:struct:evrpc_base::evhttp	access:public
http_server	http-internal.h	/^	struct evhttp *http_server;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::evhttp	access:public
http_server_DEPENDENCIES	sample/Makefile	/^http_server_DEPENDENCIES = $(am__DEPENDENCIES_1) ..\/libevent.la$/;"	m
http_server_LDADD	sample/Makefile	/^http_server_LDADD = $(LDADD)$/;"	m
http_server_OBJECTS	sample/Makefile	/^http_server_OBJECTS = $(am_http_server_OBJECTS)$/;"	m
http_server_SOURCES	sample/Makefile	/^http_server_SOURCES = http-server.c$/;"	m
http_setup	test/regress_http.c	/^http_setup(ev_uint16_t *pport, struct event_base *base)$/;"	f	file:	signature:(ev_uint16_t *pport, struct event_base *base)
http_setup	test/regress_rpc.c	/^http_setup(ev_uint16_t *pport)$/;"	f	file:	signature:(ev_uint16_t *pport)
http_stream_in_cancel_chunk	test/regress_http.c	/^http_stream_in_cancel_chunk(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_stream_in_cancel_done	test/regress_http.c	/^http_stream_in_cancel_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_stream_in_cancel_test	test/regress_http.c	/^http_stream_in_cancel_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_stream_in_chunk	test/regress_http.c	/^http_stream_in_chunk(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_stream_in_done	test/regress_http.c	/^http_stream_in_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_stream_in_test	test/regress_http.c	/^http_stream_in_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_stream_out_test	test/regress_http.c	/^http_stream_out_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_terminate_chunked_test	test/regress_http.c	/^http_terminate_chunked_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_testcases	test/regress_http.c	/^struct testcase_t http_testcases[] = {$/;"	v	typeref:struct:testcase_t
http_uriencode_test	test/regress_http.c	/^http_uriencode_test(void *ptr)$/;"	f	file:	signature:(void *ptr)
http_virtual_host_test	test/regress_http.c	/^http_virtual_host_test(void *arg)$/;"	f	file:	signature:(void *arg)
http_writecb	test/regress_http.c	/^http_writecb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
i	arc4random.c	/^	unsigned char i;$/;"	m	struct:arc4_stream	file:	access:public
i	test/regress_http.c	/^	int i;$/;"	m	struct:chunk_req_state	file:	access:public
idx_info	win32select.c	/^struct idx_info {$/;"	s	file:
idx_info::read_pos_plus1	win32select.c	/^	int read_pos_plus1;$/;"	m	struct:idx_info	file:	access:public
idx_info::write_pos_plus1	win32select.c	/^	int write_pos_plus1;$/;"	m	struct:idx_info	file:	access:public
idxplus1	evmap.c	/^	int idxplus1; \/* this is the index +1, so that memset(0) will make it$/;"	m	struct:event_changelist_fdinfo	file:	access:public
idxplus1	poll.c	/^	int idxplus1;$/;"	m	struct:pollidx	file:	access:public
ignore_log_cb	test/regress_main.c	/^ignore_log_cb(int s, const char *msg)$/;"	f	file:	signature:(int s, const char *msg)
in6_addr	ipv6-internal.h	/^struct in6_addr {$/;"	s
in6_addr::s6_addr	ipv6-internal.h	/^	ev_uint8_t s6_addr[16];$/;"	m	struct:in6_addr	access:public
in_hooks	evrpc-internal.h	/^	struct evrpc_hook_list in_hooks;$/;"	m	struct:_evrpc_hooks	typeref:struct:_evrpc_hooks::evrpc_hook_list	access:public
in_legacy_test_wrapper	test/regress_main.c	/^int in_legacy_test_wrapper = 0;$/;"	v
in_tinytest_main	test/tinytest.c	/^static int in_tinytest_main = 0; \/**< true if we're in tinytest_main().*\/$/;"	v	file:
include_HEADERS	Makefile	/^include_HEADERS = $(EVENT1_HDRS)$/;"	m
includedir	Makefile	/^includedir = ${prefix}\/include$/;"	m
includedir	include/Makefile	/^includedir = ${prefix}\/include$/;"	m
includedir	sample/Makefile	/^includedir = ${prefix}\/include$/;"	m
includedir	test/Makefile	/^includedir = ${prefix}\/include$/;"	m
incref_and_lock	bufferevent_pair.c	/^incref_and_lock(struct bufferevent *b)$/;"	f	file:	signature:(struct bufferevent *b)
infilter_calls	test/regress_zlib.c	/^static int infilter_calls;$/;"	v	file:
infodir	Makefile	/^infodir = ${datarootdir}\/info$/;"	m
infodir	include/Makefile	/^infodir = ${datarootdir}\/info$/;"	m
infodir	sample/Makefile	/^infodir = ${datarootdir}\/info$/;"	m
infodir	test/Makefile	/^infodir = ${datarootdir}\/info$/;"	m
informational_phrases	http.c	/^static const char *informational_phrases[] = {$/;"	v	file:
init	event-internal.h	/^	void *(*init)(struct event_base *);$/;"	m	struct:eventop	access:public
init_bio_counts	bufferevent_openssl.c	/^init_bio_counts(struct bufferevent_openssl *bev_ssl)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl)
init_extension_functions	event_iocp.c	/^init_extension_functions(struct win32_extension_fns *ext)$/;"	f	file:	signature:(struct win32_extension_fns *ext)
init_ssl	test/regress_ssl.c	/^init_ssl(void)$/;"	f	file:	signature:(void)
inline	util-internal.h	49;"	d
input	include/event2/bufferevent_struct.h	/^	struct evbuffer *input;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::evbuffer	access:public
input_buffer	include/event2/http_struct.h	/^	struct evbuffer *input_buffer;	\/* read data *\/$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evbuffer	access:public
input_headers	include/event2/http_struct.h	/^	struct evkeyvalq *input_headers;$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evkeyvalq	access:public
input_hooks	evrpc-internal.h	67;"	d
insert_common_timeout_inorder	event.c	/^insert_common_timeout_inorder(struct common_timeout_list *ctl,$/;"	f	file:	signature:(struct common_timeout_list *ctl, struct event *ev)
install_sh	Makefile	/^install_sh = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/install-sh$/;"	m
install_sh	include/Makefile	/^install_sh = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/install-sh$/;"	m
install_sh	sample/Makefile	/^install_sh = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/install-sh$/;"	m
install_sh	test/Makefile	/^install_sh = ${SHELL} \/home\/lhh\/workspace\/lhh\/3rd\/libevent\/install-sh$/;"	m
install_sh_DATA	Makefile	/^install_sh_DATA = $(install_sh) -c -m 644$/;"	m
install_sh_DATA	include/Makefile	/^install_sh_DATA = $(install_sh) -c -m 644$/;"	m
install_sh_DATA	sample/Makefile	/^install_sh_DATA = $(install_sh) -c -m 644$/;"	m
install_sh_DATA	test/Makefile	/^install_sh_DATA = $(install_sh) -c -m 644$/;"	m
install_sh_PROGRAM	Makefile	/^install_sh_PROGRAM = $(install_sh) -c$/;"	m
install_sh_PROGRAM	include/Makefile	/^install_sh_PROGRAM = $(install_sh) -c$/;"	m
install_sh_PROGRAM	sample/Makefile	/^install_sh_PROGRAM = $(install_sh) -c$/;"	m
install_sh_PROGRAM	test/Makefile	/^install_sh_PROGRAM = $(install_sh) -c$/;"	m
install_sh_SCRIPT	Makefile	/^install_sh_SCRIPT = $(install_sh) -c$/;"	m
install_sh_SCRIPT	include/Makefile	/^install_sh_SCRIPT = $(install_sh) -c$/;"	m
install_sh_SCRIPT	sample/Makefile	/^install_sh_SCRIPT = $(install_sh) -c$/;"	m
install_sh_SCRIPT	test/Makefile	/^install_sh_SCRIPT = $(install_sh) -c$/;"	m
internal_error_table	test/regress_dns.c	/^static struct regress_dns_server_table internal_error_table[] = {$/;"	v	typeref:struct:regress_dns_server_table	file:
io	event-internal.h	/^	struct event_io_map io;$/;"	m	struct:event_base	typeref:struct:event_base::event_io_map	access:public
iocp	event-internal.h	/^	struct event_iocp_port *iocp;$/;"	m	struct:event_base	typeref:struct:event_base::event_iocp_port	access:public
iocp_callback	iocp-internal.h	/^typedef void (*iocp_callback)(struct event_overlapped *, ev_uintptr_t, ev_ssize_t, int success);$/;"	t
iocp_listener_destroy	listener.c	/^iocp_listener_destroy(struct evconnlistener *lev)$/;"	f	file:	signature:(struct evconnlistener *lev)
iocp_listener_disable	listener.c	/^iocp_listener_disable(struct evconnlistener *lev)$/;"	f	file:	signature:(struct evconnlistener *lev)
iocp_listener_disable_impl	listener.c	/^iocp_listener_disable_impl(struct evconnlistener *lev, int shutdown)$/;"	f	file:	signature:(struct evconnlistener *lev, int shutdown)
iocp_listener_enable	listener.c	/^iocp_listener_enable(struct evconnlistener *lev)$/;"	f	file:	signature:(struct evconnlistener *lev)
iocp_listener_event_add	listener.c	/^iocp_listener_event_add(struct evconnlistener_iocp *lev)$/;"	f	file:	signature:(struct evconnlistener_iocp *lev)
iocp_listener_event_del	listener.c	/^iocp_listener_event_del(struct evconnlistener_iocp *lev)$/;"	f	file:	signature:(struct evconnlistener_iocp *lev)
iocp_listener_getbase	listener.c	/^iocp_listener_getbase(struct evconnlistener *lev)$/;"	f	file:	signature:(struct evconnlistener *lev)
iocp_listener_getfd	listener.c	/^iocp_listener_getfd(struct evconnlistener *lev)$/;"	f	file:	signature:(struct evconnlistener *lev)
iocp_testcases	test/regress_iocp.c	/^struct testcase_t iocp_testcases[] = {$/;"	v	typeref:struct:testcase_t
iov_base	include/event2/buffer.h	/^	void *iov_base;$/;"	m	struct:evbuffer_iovec	access:public
iov_len	include/event2/buffer.h	/^	size_t iov_len;$/;"	m	struct:evbuffer_iovec	access:public
ipv4_entries	test/regress_util.c	/^} ipv4_entries[] = {$/;"	v	typeref:struct:ipv4_entry	file:
ipv4_entry	test/regress_util.c	/^static struct ipv4_entry {$/;"	s	file:
ipv4_entry::addr	test/regress_util.c	/^	const char *addr;$/;"	m	struct:ipv4_entry	file:	access:public
ipv4_entry::res	test/regress_util.c	/^	ev_uint32_t res;$/;"	m	struct:ipv4_entry	file:	access:public
ipv4_entry::status	test/regress_util.c	/^	enum entry_status status;$/;"	m	struct:ipv4_entry	typeref:enum:ipv4_entry::entry_status	file:	access:public
ipv4_request	evdns.c	/^	struct getaddrinfo_subrequest ipv4_request;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::getaddrinfo_subrequest	file:	access:public
ipv6_entries	test/regress_util.c	/^} ipv6_entries[] = {$/;"	v	typeref:struct:ipv6_entry	file:
ipv6_entry	test/regress_util.c	/^static struct ipv6_entry {$/;"	s	file:
ipv6_entry::addr	test/regress_util.c	/^	const char *addr;$/;"	m	struct:ipv6_entry	file:	access:public
ipv6_entry::res	test/regress_util.c	/^	ev_uint32_t res[4];$/;"	m	struct:ipv6_entry	file:	access:public
ipv6_entry::status	test/regress_util.c	/^	enum entry_status status;$/;"	m	struct:ipv6_entry	typeref:enum:ipv6_entry::entry_status	file:	access:public
ipv6_request	evdns.c	/^	struct getaddrinfo_subrequest ipv6_request;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::getaddrinfo_subrequest	file:	access:public
is_common_timeout	event.c	/^is_common_timeout(const struct timeval *tv,$/;"	f	file:	signature:(const struct timeval *tv, const struct event_base *base)
is_loopback	test/regress_util.c	/^	int is_loopback;$/;"	m	struct:sa_pred_ent	file:	access:public
is_name	evdns.c	/^	char is_name; \/* True iff data is a label *\/$/;"	m	struct:server_reply_item	file:	access:public
is_notify_pending	event-internal.h	/^	int is_notify_pending;$/;"	m	struct:event_base	access:public
is_overlapped	evbuffer-internal.h	/^	unsigned is_overlapped : 1;$/;"	m	struct:evbuffer	access:public
is_same_common_timeout	event.c	/^is_same_common_timeout(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	file:	signature:(const struct timeval *tv1, const struct timeval *tv2)
isbool	test/test-ratelim.c	/^	const char *name; int *ptr; int min; int isbool;$/;"	m	struct:option	file:	access:public
j	arc4random.c	/^	unsigned char j;$/;"	m	struct:arc4_stream	file:	access:public
kerneltimeBegin	test/test-changelist.c	/^	FILETIME kerneltimeBegin;$/;"	m	struct:cpu_usage_timer	file:	access:public
key	evrpc-internal.h	/^	char *key;$/;"	m	struct:evrpc_meta	access:public
key	include/event2/keyvalq_struct.h	/^	char *key;$/;"	m	struct:evkeyval	access:public
keys	test/regress_iocp.c	/^	uintptr_t keys[MAX_CALLS];$/;"	m	struct:dummy_overlapped	file:	access:public
kind	include/event2/http_struct.h	/^	enum evhttp_request_kind kind;$/;"	m	struct:evhttp_request	typeref:enum:evhttp_request::evhttp_request_kind	access:public
kq	kqueue.c	/^	int kq;$/;"	m	struct:kqop	file:	access:public
kq_build_changes_list	kqueue.c	/^kq_build_changes_list(const struct event_changelist *changelist,$/;"	f	file:	signature:(const struct event_changelist *changelist, struct kqop *kqop)
kq_dealloc	kqueue.c	/^kq_dealloc(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
kq_dealloc	kqueue.c	/^static void kq_dealloc(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
kq_dispatch	kqueue.c	/^kq_dispatch(struct event_base *base, struct timeval *tv)$/;"	f	file:	signature:(struct event_base *base, struct timeval *tv)
kq_dispatch	kqueue.c	/^static int kq_dispatch(struct event_base *, struct timeval *);$/;"	p	file:	signature:(struct event_base *, struct timeval *)
kq_grow_events	kqueue.c	/^kq_grow_events(struct kqop *kqop, size_t new_size)$/;"	f	file:	signature:(struct kqop *kqop, size_t new_size)
kq_init	kqueue.c	/^kq_init(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
kq_init	kqueue.c	/^static void *kq_init(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
kq_setup_kevent	kqueue.c	/^kq_setup_kevent(struct kevent *out, evutil_socket_t fd, int filter, short change)$/;"	f	file:	signature:(struct kevent *out, evutil_socket_t fd, int filter, short change)
kq_sig_add	kqueue.c	/^kq_sig_add(struct event_base *base, int nsignal, short old, short events, void *p)$/;"	f	file:	signature:(struct event_base *base, int nsignal, short old, short events, void *p)
kq_sig_add	kqueue.c	/^static int kq_sig_add(struct event_base *, int, short, short, void *);$/;"	p	file:	signature:(struct event_base *, int, short, short, void *)
kq_sig_del	kqueue.c	/^kq_sig_del(struct event_base *base, int nsignal, short old, short events, void *p)$/;"	f	file:	signature:(struct event_base *base, int nsignal, short old, short events, void *p)
kq_sig_del	kqueue.c	/^static int kq_sig_del(struct event_base *, int, short, short, void *);$/;"	p	file:	signature:(struct event_base *, int, short, short, void *)
kq_sighandler	kqueue.c	/^kq_sighandler(int sig)$/;"	f	file:	signature:(int sig)
kqop	kqueue.c	/^struct kqop {$/;"	s	file:
kqop::changes	kqueue.c	/^	struct kevent *changes;$/;"	m	struct:kqop	typeref:struct:kqop::kevent	file:	access:public
kqop::changes_size	kqueue.c	/^	int changes_size;$/;"	m	struct:kqop	file:	access:public
kqop::events	kqueue.c	/^	struct kevent *events;$/;"	m	struct:kqop	typeref:struct:kqop::kevent	file:	access:public
kqop::events_size	kqueue.c	/^	int events_size;$/;"	m	struct:kqop	file:	access:public
kqop::kq	kqueue.c	/^	int kq;$/;"	m	struct:kqop	file:	access:public
kqop::pid	kqueue.c	/^	pid_t pid;$/;"	m	struct:kqop	file:	access:public
kqop_free	kqueue.c	/^kqop_free(struct kqop *kqop)$/;"	f	file:	signature:(struct kqop *kqop)
kqop_free	kqueue.c	/^static void kqop_free(struct kqop *kqop);$/;"	p	file:	signature:(struct kqop *kqop)
kqops	kqueue.c	/^const struct eventop kqops = {$/;"	v	typeref:struct:eventop
kqsigops	kqueue.c	/^static const struct eventop kqsigops = {$/;"	v	typeref:struct:eventop	file:
labels	evdns.c	/^	struct dnslabel_entry labels[MAX_LABELS];$/;"	m	struct:dnslabel_table	typeref:struct:dnslabel_table::dnslabel_entry	file:	access:public
last	evbuffer-internal.h	/^	struct evbuffer_chain *last;$/;"	m	struct:evbuffer	typeref:struct:evbuffer::evbuffer_chain	access:public
last_updated	ratelim-internal.h	/^	ev_uint32_t last_updated;$/;"	m	struct:ev_token_bucket	access:public
last_updated_clock_diff	event-internal.h	/^	time_t last_updated_clock_diff;$/;"	m	struct:event_base	access:public
last_with_datap	evbuffer-internal.h	/^	struct evbuffer_chain **last_with_datap;$/;"	m	struct:evbuffer	typeref:struct:evbuffer::evbuffer_chain	access:public
last_write	bufferevent_openssl.c	/^	ev_ssize_t last_write;$/;"	m	struct:bufferevent_openssl	file:	access:public
last_wrote_at	test/regress_bufferevent.c	/^	struct timeval last_wrote_at;$/;"	m	struct:timeout_cb_result	typeref:struct:timeout_cb_result::timeval	file:	access:public
lasttime	sample/time-test.c	/^struct timeval lasttime;$/;"	v	typeref:struct:timeval
launch_request	test/bench_httpclient.c	/^launch_request(void)$/;"	f	file:	signature:(void)
launch_request	test/bench_httpclient.c	/^static int launch_request(void);$/;"	p	file:	signature:(void)
le_proxy_OBJECTS	sample/Makefile	/^le_proxy_OBJECTS = $(am_le_proxy_OBJECTS)$/;"	m
legacy_setup	test/regress_main.c	/^const struct testcase_setup_t legacy_setup = {$/;"	v	typeref:struct:testcase_setup_t
legacy_test_cleanup	test/regress_main.c	/^legacy_test_cleanup(const struct testcase_t *testcase, void *ptr)$/;"	f	file:	signature:(const struct testcase_t *testcase, void *ptr)
legacy_test_fn	test/regress.h	/^	void (*legacy_test_fn)(void);$/;"	m	struct:basic_test_data	access:public
legacy_test_setup	test/regress_main.c	/^legacy_test_setup(const struct testcase_t *testcase)$/;"	f	file:	signature:(const struct testcase_t *testcase)
len	evdns.c	/^	int len;$/;"	m	struct:search_domain	file:	access:public
lev	listener.c	/^	struct evconnlistener_iocp *lev;$/;"	m	struct:accepting_socket	typeref:struct:accepting_socket::evconnlistener_iocp	file:	access:public
lib_LTLIBRARIES	Makefile	/^lib_LTLIBRARIES = $(LIBEVENT_LIBS_LA)$/;"	m
libdir	Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libdir	include/Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libdir	sample/Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libdir	test/Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libevent_core_la_DEPENDENCIES	Makefile	/^libevent_core_la_DEPENDENCIES =  $(am__DEPENDENCIES_1)$/;"	m
libevent_core_la_LDFLAGS	Makefile	/^libevent_core_la_LDFLAGS = $(GENERIC_LDFLAGS)$/;"	m
libevent_core_la_LIBADD	Makefile	/^libevent_core_la_LIBADD =  $(SYS_LIBS)$/;"	m
libevent_core_la_LINK	Makefile	/^libevent_core_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\$/;"	m
libevent_core_la_OBJECTS	Makefile	/^libevent_core_la_OBJECTS = $(am_libevent_core_la_OBJECTS)$/;"	m
libevent_core_la_SOURCES	Makefile	/^libevent_core_la_SOURCES = $(CORE_SRC)$/;"	m
libevent_extra_la_DEPENDENCIES	Makefile	/^libevent_extra_la_DEPENDENCIES = $(am__DEPENDENCIES_2) \\$/;"	m
libevent_extra_la_LDFLAGS	Makefile	/^libevent_extra_la_LDFLAGS = $(GENERIC_LDFLAGS)$/;"	m
libevent_extra_la_LIBADD	Makefile	/^libevent_extra_la_LIBADD = $(MAYBE_CORE) $(SYS_LIBS)$/;"	m
libevent_extra_la_LINK	Makefile	/^libevent_extra_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\$/;"	m
libevent_extra_la_OBJECTS	Makefile	/^libevent_extra_la_OBJECTS = $(am_libevent_extra_la_OBJECTS)$/;"	m
libevent_extra_la_SOURCES	Makefile	/^libevent_extra_la_SOURCES = $(EXTRA_SRC)$/;"	m
libevent_la_DEPENDENCIES	Makefile	/^libevent_la_DEPENDENCIES =  $(am__DEPENDENCIES_1)$/;"	m
libevent_la_LDFLAGS	Makefile	/^libevent_la_LDFLAGS = $(GENERIC_LDFLAGS)$/;"	m
libevent_la_LIBADD	Makefile	/^libevent_la_LIBADD =  $(SYS_LIBS)$/;"	m
libevent_la_LINK	Makefile	/^libevent_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\$/;"	m
libevent_la_OBJECTS	Makefile	/^libevent_la_OBJECTS = $(am_libevent_la_OBJECTS)$/;"	m
libevent_la_SOURCES	Makefile	/^libevent_la_SOURCES = $(CORE_SRC) $(EXTRA_SRC)$/;"	m
libevent_openssl_la_LINK	Makefile	/^libevent_openssl_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\$/;"	m
libevent_openssl_la_OBJECTS	Makefile	/^libevent_openssl_la_OBJECTS = $(am_libevent_openssl_la_OBJECTS)$/;"	m
libevent_pthreads_la_DEPENDENCIES	Makefile	/^libevent_pthreads_la_DEPENDENCIES =  \\$/;"	m
libevent_pthreads_la_LDFLAGS	Makefile	/^libevent_pthreads_la_LDFLAGS = $(GENERIC_LDFLAGS)$/;"	m
libevent_pthreads_la_LIBADD	Makefile	/^libevent_pthreads_la_LIBADD = $(MAYBE_CORE)$/;"	m
libevent_pthreads_la_LINK	Makefile	/^libevent_pthreads_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\$/;"	m
libevent_pthreads_la_OBJECTS	Makefile	/^libevent_pthreads_la_OBJECTS = $(am_libevent_pthreads_la_OBJECTS)$/;"	m
libevent_pthreads_la_SOURCES	Makefile	/^libevent_pthreads_la_SOURCES = evthread_pthread.c$/;"	m
libexecdir	Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
libexecdir	include/Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
libexecdir	sample/Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
libexecdir	test/Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
limit	bufferevent-internal.h	/^	struct ev_token_bucket limit;$/;"	m	struct:bufferevent_rate_limit	typeref:struct:bufferevent_rate_limit::ev_token_bucket	access:public
line_count	event_rpcgen.py	/^line_count = 0$/;"	v
listen_cb	test/regress_bufferevent.c	/^listen_cb(struct evconnlistener *listener, evutil_socket_t fd,$/;"	f	file:	signature:(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *sa, int socklen, void *arg)
listen_on_addr	sample/le-proxy.c	/^static struct sockaddr_storage listen_on_addr;$/;"	v	typeref:struct:sockaddr_storage	file:
listener	http-internal.h	/^	struct evconnlistener *listener;$/;"	m	struct:evhttp_bound_socket	typeref:struct:evhttp_bound_socket::evconnlistener	access:public
listener	listener.c	/^	struct event listener;$/;"	m	struct:evconnlistener_event	typeref:struct:evconnlistener_event::event	file:	access:public
listener_cb	sample/hello-world.c	/^listener_cb(struct evconnlistener *listener, evutil_socket_t fd,$/;"	f	file:	signature:(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *sa, int socklen, void *user_data)
listener_cb	sample/hello-world.c	/^static void listener_cb(struct evconnlistener *, evutil_socket_t,$/;"	p	file:	signature:(struct evconnlistener *, evutil_socket_t, struct sockaddr *, int socklen, void *)
listener_decref_and_unlock	listener.c	/^listener_decref_and_unlock(struct evconnlistener *listener)$/;"	f	file:	signature:(struct evconnlistener *listener)
listener_iocp_testcases	test/regress_listener.c	/^struct testcase_t listener_iocp_testcases[] = {$/;"	v	typeref:struct:testcase_t
listener_read_cb	listener.c	/^listener_read_cb(evutil_socket_t fd, short what, void *p)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *p)
listener_read_cb	listener.c	/^static void listener_read_cb(evutil_socket_t, short, void *);$/;"	p	file:	signature:(evutil_socket_t, short, void *)
listener_testcases	test/regress_listener.c	/^struct testcase_t listener_testcases[] = {$/;"	v	typeref:struct:testcase_t
load_deferred_queue	test/regress_thread.c	/^load_deferred_queue(void *arg)$/;"	f	file:	signature:(void *arg)
load_nameservers_from_registry	evdns.c	/^load_nameservers_from_registry(struct evdns_base *base)$/;"	f	file:	signature:(struct evdns_base *base)
load_nameservers_with_getnetworkparams	evdns.c	/^load_nameservers_with_getnetworkparams(struct evdns_base *base)$/;"	f	file:	signature:(struct evdns_base *base)
load_threads	test/regress_thread.c	/^static THREAD_T load_threads[QUEUE_THREAD_COUNT];$/;"	v	file:
localedir	Makefile	/^localedir = ${datarootdir}\/locale$/;"	m
localedir	include/Makefile	/^localedir = ${datarootdir}\/locale$/;"	m
localedir	sample/Makefile	/^localedir = ${datarootdir}\/locale$/;"	m
localedir	test/Makefile	/^localedir = ${datarootdir}\/locale$/;"	m
localstatedir	Makefile	/^localstatedir = ${prefix}\/var$/;"	m
localstatedir	include/Makefile	/^localstatedir = ${prefix}\/var$/;"	m
localstatedir	sample/Makefile	/^localstatedir = ${prefix}\/var$/;"	m
localstatedir	test/Makefile	/^localstatedir = ${prefix}\/var$/;"	m
lock	bufferevent-internal.h	/^	void *lock;$/;"	m	struct:bufferevent_private	access:public
lock	bufferevent-internal.h	/^	void *lock;$/;"	m	struct:bufferevent_rate_limit_group	access:public
lock	defer-internal.h	/^	void *lock;$/;"	m	struct:deferred_cb_queue	access:public
lock	evbuffer-internal.h	/^	void *lock;$/;"	m	struct:evbuffer	access:public
lock	evdns.c	/^	void *lock;$/;"	m	struct:evdns_base	file:	access:public
lock	evdns.c	/^	void *lock;$/;"	m	struct:evdns_server_port	file:	access:public
lock	evthread.c	/^	void *lock;$/;"	m	struct:debug_lock	file:	access:public
lock	evthread_win32.c	/^	CRITICAL_SECTION lock;$/;"	m	struct:evthread_win32_cond	file:	access:public
lock	include/event2/thread.h	/^	int (*lock)(unsigned mode, void *lock);$/;"	m	struct:evthread_lock_callbacks	access:public
lock	iocp-internal.h	/^	CRITICAL_SECTION lock;$/;"	m	struct:event_iocp_port	access:public
lock	listener.c	/^	CRITICAL_SECTION lock;$/;"	m	struct:accepting_socket	file:	access:public
lock	listener.c	/^	void *lock;$/;"	m	struct:evconnlistener	file:	access:public
lock	test/regress_iocp.c	/^	void *lock;$/;"	m	struct:dummy_overlapped	file:	access:public
lock	test/regress_thread.c	/^	void *lock;$/;"	m	struct:cond_wait	file:	access:public
lock_api_version	include/event2/thread.h	/^	int lock_api_version;$/;"	m	struct:evthread_lock_callbacks	access:public
locktype	evthread.c	/^	unsigned locktype;$/;"	m	struct:debug_lock	file:	access:public
log	evdns.c	473;"	d	file:
log_change_callback	test/regress_buffer.c	/^log_change_callback(struct evbuffer *buffer,$/;"	f	file:	signature:(struct evbuffer *buffer, const struct evbuffer_cb_info *cbinfo, void *arg)
log_fn	log.c	/^static event_log_cb log_fn = NULL;$/;"	v	file:
logfn	sample/dns-example.c	/^logfn(int is_warn, const char *msg) {$/;"	f	file:	signature:(int is_warn, const char *msg)
logfn	test/regress_util.c	/^logfn(int severity, const char *msg)$/;"	f	file:	signature:(int severity, const char *msg)
logmsg	test/regress_util.c	/^static char *logmsg = NULL;$/;"	v	file:
logsev	test/regress_util.c	/^static int logsev = 0;$/;"	v	file:
loop	event_iocp.c	/^loop(void *_port)$/;"	f	file:	signature:(void *_port)
loud_writecb	test/test-ratelim.c	/^loud_writecb(struct bufferevent *bev, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, void *ctx)
low	include/event2/bufferevent_struct.h	/^	size_t low;$/;"	m	struct:event_watermark	access:public
lseek	buffer.c	2898;"	d	file:
magic	test/regress_dns.c	/^	int magic;$/;"	m	struct:gaic_request_status	file:	access:public
main	sample/dns-example.c	/^main(int c, char **v) {$/;"	f	signature:(int c, char **v)
main	sample/event-test.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	sample/hello-world.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	sample/http-server.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	sample/le-proxy.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	sample/signal-test.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	sample/time-test.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/bench.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/bench_cascade.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/bench_http.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/bench_httpclient.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/regress_main.c	/^main(int argc, const char **argv)$/;"	f	signature:(int argc, const char **argv)
main	test/test-changelist.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/test-eof.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/test-init.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/test-ratelim.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/test-time.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/test-weof.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main_callback	sample/dns-example.c	/^main_callback(int result, char type, int count, int ttl,$/;"	f	file:	signature:(int result, char type, int count, int ttl, void *addrs, void *orig)
main_testcases	test/regress.c	/^struct testcase_t main_testcases[] = {$/;"	v	typeref:struct:testcase_t
major	include/event2/http_struct.h	/^	char major;			\/* HTTP Major number *\/$/;"	m	struct:evhttp_request	access:public
make_addrinfo	http.c	/^make_addrinfo(const char *address, ev_uint16_t port)$/;"	f	file:	signature:(const char *address, ev_uint16_t port)
mandir	Makefile	/^mandir = ${datarootdir}\/man$/;"	m
mandir	include/Makefile	/^mandir = ${datarootdir}\/man$/;"	m
mandir	sample/Makefile	/^mandir = ${datarootdir}\/man$/;"	m
mandir	test/Makefile	/^mandir = ${datarootdir}\/man$/;"	m
many_event_cb	test/regress.c	/^many_event_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
master_refill_event	bufferevent-internal.h	/^	struct event master_refill_event;$/;"	m	struct:bufferevent_rate_limit_group	typeref:struct:bufferevent_rate_limit_group::event	access:public
max_body_size	http-internal.h	/^	ev_uint64_t max_body_size;$/;"	m	struct:evhttp_connection	access:public
max_headers_size	http-internal.h	/^	size_t max_headers_size;$/;"	m	struct:evhttp_connection	access:public
mem_offset	bufferevent-internal.h	/^	off_t mem_offset;$/;"	m	struct:bufferevent_ops	access:public
members	bufferevent-internal.h	/^	TAILQ_HEAD(rlim_group_member_list, bufferevent_private) members;$/;"	m	struct:bufferevent_rate_limit_group	access:public
message_read_status	http-internal.h	/^enum message_read_status {$/;"	g
meta_data	evrpc-internal.h	/^	struct evrpc_meta_list meta_data;$/;"	m	struct:evrpc_hook_meta	typeref:struct:evrpc_hook_meta::evrpc_meta_list	access:public
methodname_to_envvar	test/regress.c	/^methodname_to_envvar(const char *mname, char *buf, size_t buflen)$/;"	f	file:	signature:(const char *mname, char *buf, size_t buflen)
methods_bufferevent	bufferevent_openssl.c	/^static BIO_METHOD methods_bufferevent = {$/;"	v	file:
min	test/test-ratelim.c	/^	const char *name; int *ptr; int min; int isbool;$/;"	m	struct:option	file:	access:public
min_heap	minheap-internal.h	/^typedef struct min_heap$/;"	s
min_heap::a	minheap-internal.h	/^	unsigned n, a;$/;"	m	struct:min_heap	access:public
min_heap::n	minheap-internal.h	/^	unsigned n, a;$/;"	m	struct:min_heap	access:public
min_heap::p	minheap-internal.h	/^	struct event** p;$/;"	m	struct:min_heap	typeref:struct:min_heap::event	access:public
min_heap_ctor	minheap-internal.h	/^static inline void	     min_heap_ctor(min_heap_t* s);$/;"	p	signature:(min_heap_t* s)
min_heap_ctor	minheap-internal.h	/^void min_heap_ctor(min_heap_t* s) { s->p = 0; s->n = 0; s->a = 0; }$/;"	f	signature:(min_heap_t* s)
min_heap_dtor	minheap-internal.h	/^static inline void	     min_heap_dtor(min_heap_t* s);$/;"	p	signature:(min_heap_t* s)
min_heap_dtor	minheap-internal.h	/^void min_heap_dtor(min_heap_t* s) { if (s->p) mm_free(s->p); }$/;"	f	signature:(min_heap_t* s)
min_heap_elem_greater	minheap-internal.h	/^int min_heap_elem_greater(struct event *a, struct event *b)$/;"	f	signature:(struct event *a, struct event *b)
min_heap_elem_greater	minheap-internal.h	/^static inline int	     min_heap_elem_greater(struct event *a, struct event *b);$/;"	p	signature:(struct event *a, struct event *b)
min_heap_elem_init	minheap-internal.h	/^static inline void	     min_heap_elem_init(struct event* e);$/;"	p	signature:(struct event* e)
min_heap_elem_init	minheap-internal.h	/^void min_heap_elem_init(struct event* e) { e->ev_timeout_pos.min_heap_idx = -1; }$/;"	f	signature:(struct event* e)
min_heap_elt_is_top	minheap-internal.h	/^int min_heap_elt_is_top(const struct event *e)$/;"	f	signature:(const struct event *e)
min_heap_elt_is_top	minheap-internal.h	/^static inline int	     min_heap_elt_is_top(const struct event *e);$/;"	p	signature:(const struct event *e)
min_heap_empty	minheap-internal.h	/^int min_heap_empty(min_heap_t* s) { return 0u == s->n; }$/;"	f	signature:(min_heap_t* s)
min_heap_empty	minheap-internal.h	/^static inline int	     min_heap_empty(min_heap_t* s);$/;"	p	signature:(min_heap_t* s)
min_heap_erase	minheap-internal.h	/^int min_heap_erase(min_heap_t* s, struct event* e)$/;"	f	signature:(min_heap_t* s, struct event* e)
min_heap_erase	minheap-internal.h	/^static inline int	     min_heap_erase(min_heap_t* s, struct event* e);$/;"	p	signature:(min_heap_t* s, struct event* e)
min_heap_idx	include/event2/event_struct.h	/^		int min_heap_idx;$/;"	m	union:event::__anon2	access:public
min_heap_pop	minheap-internal.h	/^static inline struct event*  min_heap_pop(min_heap_t* s);$/;"	p	signature:(min_heap_t* s)
min_heap_pop	minheap-internal.h	/^struct event* min_heap_pop(min_heap_t* s)$/;"	f	signature:(min_heap_t* s)
min_heap_push	minheap-internal.h	/^int min_heap_push(min_heap_t* s, struct event* e)$/;"	f	signature:(min_heap_t* s, struct event* e)
min_heap_push	minheap-internal.h	/^static inline int	     min_heap_push(min_heap_t* s, struct event* e);$/;"	p	signature:(min_heap_t* s, struct event* e)
min_heap_reserve	minheap-internal.h	/^int min_heap_reserve(min_heap_t* s, unsigned n)$/;"	f	signature:(min_heap_t* s, unsigned n)
min_heap_reserve	minheap-internal.h	/^static inline int	     min_heap_reserve(min_heap_t* s, unsigned n);$/;"	p	signature:(min_heap_t* s, unsigned n)
min_heap_shift_down_	minheap-internal.h	/^static inline void	     min_heap_shift_down_(min_heap_t* s, unsigned hole_index, struct event* e);$/;"	p	signature:(min_heap_t* s, unsigned hole_index, struct event* e)
min_heap_shift_down_	minheap-internal.h	/^void min_heap_shift_down_(min_heap_t* s, unsigned hole_index, struct event* e)$/;"	f	signature:(min_heap_t* s, unsigned hole_index, struct event* e)
min_heap_shift_up_	minheap-internal.h	/^static inline void	     min_heap_shift_up_(min_heap_t* s, unsigned hole_index, struct event* e);$/;"	p	signature:(min_heap_t* s, unsigned hole_index, struct event* e)
min_heap_shift_up_	minheap-internal.h	/^void min_heap_shift_up_(min_heap_t* s, unsigned hole_index, struct event* e)$/;"	f	signature:(min_heap_t* s, unsigned hole_index, struct event* e)
min_heap_size	minheap-internal.h	/^static inline unsigned	     min_heap_size(min_heap_t* s);$/;"	p	signature:(min_heap_t* s)
min_heap_size	minheap-internal.h	/^unsigned min_heap_size(min_heap_t* s) { return s->n; }$/;"	f	signature:(min_heap_t* s)
min_heap_t	minheap-internal.h	/^} min_heap_t;$/;"	t	typeref:struct:min_heap
min_heap_top	minheap-internal.h	/^static inline struct event*  min_heap_top(min_heap_t* s);$/;"	p	signature:(min_heap_t* s)
min_heap_top	minheap-internal.h	/^struct event* min_heap_top(min_heap_t* s) { return s->n ? *s->p : 0; }$/;"	f	signature:(min_heap_t* s)
min_share	bufferevent-internal.h	/^	ev_ssize_t min_share;$/;"	m	struct:bufferevent_rate_limit_group	access:public
minheap_testcases	test/regress_minheap.c	/^struct testcase_t minheap_testcases[] = {$/;"	v	typeref:struct:testcase_t
minor	include/event2/http_struct.h	/^	char minor;			\/* HTTP Minor number *\/$/;"	m	struct:evhttp_request	access:public
misalign	evbuffer-internal.h	/^	ev_misalign_t misalign;$/;"	m	struct:evbuffer_chain	access:public
mkdir_p	Makefile	/^mkdir_p = $(MKDIR_P)$/;"	m
mkdir_p	include/Makefile	/^mkdir_p = $(MKDIR_P)$/;"	m
mkdir_p	sample/Makefile	/^mkdir_p = $(MKDIR_P)$/;"	m
mkdir_p	test/Makefile	/^mkdir_p = $(MKDIR_P)$/;"	m
mkinstalldirs	Makefile	/^mkinstalldirs = $(install_sh) -d$/;"	m
mkinstalldirs	include/Makefile	/^mkinstalldirs = $(install_sh) -d$/;"	m
mkinstalldirs	sample/Makefile	/^mkinstalldirs = $(install_sh) -d$/;"	m
mkinstalldirs	test/Makefile	/^mkinstalldirs = $(install_sh) -d$/;"	m
mm_calloc	mm-internal.h	45;"	d
mm_calloc	mm-internal.h	51;"	d
mm_free	mm-internal.h	48;"	d
mm_free	mm-internal.h	54;"	d
mm_malloc	mm-internal.h	44;"	d
mm_malloc	mm-internal.h	50;"	d
mm_realloc	mm-internal.h	47;"	d
mm_realloc	mm-internal.h	53;"	d
mm_strdup	mm-internal.h	46;"	d
mm_strdup	mm-internal.h	52;"	d
mode_t	evutil.c	88;"	d	file:
ms	iocp-internal.h	/^	long ms;$/;"	m	struct:event_iocp_port	access:public
msec_per_tick	ratelim-internal.h	/^	unsigned msec_per_tick;$/;"	m	struct:ev_token_bucket_cfg	access:public
msg	evutil.c	/^static struct { int code; const char *msg; } windows_socket_errors[] = {$/;"	m	struct:__anon14	file:	access:public
multiple_read_cb	test/regress.c	/^multiple_read_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
multiple_write_cb	test/regress.c	/^multiple_write_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
n	minheap-internal.h	/^	unsigned n, a;$/;"	m	struct:min_heap	access:public
n	test/regress.c	/^	int n;$/;"	m	struct:persist_active_timeout_called	file:	access:public
n_accepting	listener.c	/^	short n_accepting;$/;"	m	struct:evconnlistener_iocp	file:	access:public
n_add_for_cb	evbuffer-internal.h	/^	size_t n_add_for_cb;$/;"	m	struct:evbuffer	access:public
n_added	include/event2/buffer.h	/^	size_t n_added;$/;"	m	struct:evbuffer_cb_info	access:public
n_additional	evdns.c	/^	int n_additional; \/* how many additional RRs have been set? *\/$/;"	m	struct:server_request	file:	access:public
n_answer	evdns.c	/^	int n_answer; \/* how many answer RRs have been set? *\/$/;"	m	struct:server_request	file:	access:public
n_authority	evdns.c	/^	int n_authority; \/* how many authority RRs have been set? *\/$/;"	m	struct:server_request	file:	access:public
n_bad	test/tinytest.c	/^static int n_bad = 0; \/**< Number of tests that have failed. *\/$/;"	v	file:
n_buffers	buffer_iocp.c	/^	int n_buffers;$/;"	m	struct:evbuffer_overlapped	file:	access:public
n_changes	event-internal.h	/^	int n_changes;$/;"	m	struct:event_changelist	access:public
n_common_timeouts	event-internal.h	/^	int n_common_timeouts;$/;"	m	struct:event_base	access:public
n_common_timeouts_allocated	event-internal.h	/^	int n_common_timeouts_allocated;$/;"	m	struct:event_base	access:public
n_connected	test/regress_ssl.c	/^static int n_connected = 0;$/;"	v	file:
n_cpus_hint	event-internal.h	/^	int n_cpus_hint;$/;"	m	struct:event_config	access:public
n_del_for_cb	evbuffer-internal.h	/^	size_t n_del_for_cb;$/;"	m	struct:evbuffer	access:public
n_deleted	include/event2/buffer.h	/^	size_t n_deleted;$/;"	m	struct:evbuffer_cb_info	access:public
n_echo_conns_open	test/test-ratelim.c	/^static int n_echo_conns_open = 0;$/;"	v	file:
n_errors	bufferevent_openssl.c	/^	unsigned n_errors : 2;$/;"	m	struct:bufferevent_openssl	file:	access:public
n_errors	test/bench_httpclient.c	/^int n_errors = 0;$/;"	v
n_gai_results_pending	test/regress_dns.c	/^static int n_gai_results_pending = 0;$/;"	v	file:
n_labels	evdns.c	/^	int n_labels; \/* number of current entries *\/$/;"	m	struct:dnslabel_table	file:	access:public
n_live_threads	iocp-internal.h	/^	short n_live_threads;$/;"	m	struct:event_iocp_port	access:public
n_members	bufferevent-internal.h	/^	int n_members;$/;"	m	struct:bufferevent_rate_limit_group	access:public
n_ok	test/tinytest.c	/^static int n_ok = 0; \/**< Number of tests that have passed *\/$/;"	v	file:
n_pai_calls	test/regress.c	/^static int n_pai_calls = 0;$/;"	v	file:
n_read	bufferevent_openssl.c	/^	unsigned long n_read;$/;"	m	struct:bio_data_counts	file:	access:public
n_read	test/bench_httpclient.c	/^	size_t n_read;$/;"	m	struct:request_info	file:	access:public
n_read_timeouts	test/regress_bufferevent.c	/^	int n_read_timeouts;$/;"	m	struct:timeout_cb_result	file:	access:public
n_reads_invoked	test/regress_bufferevent.c	/^static int n_reads_invoked = 0;$/;"	v	file:
n_replies_left	test/regress_dns.c	/^static int n_replies_left;$/;"	v	file:
n_req_heads	evdns.c	/^	int n_req_heads;$/;"	m	struct:evdns_base	file:	access:public
n_server_responses	test/regress_dns.c	/^static int n_server_responses = 0;$/;"	v	file:
n_skipped	test/tinytest.c	/^static int n_skipped = 0; \/**< Number of tests that have been skipped. *\/$/;"	v	file:
n_strings_read	test/regress_bufferevent.c	/^static int n_strings_read = 0;$/;"	v	file:
n_threads	iocp-internal.h	/^	short n_threads;$/;"	m	struct:event_iocp_port	access:public
n_to_wake	evthread_win32.c	/^	int n_to_wake;$/;"	m	struct:evthread_win32_cond	file:	access:public
n_waiting	evthread_win32.c	/^	int n_waiting;$/;"	m	struct:evthread_win32_cond	file:	access:public
n_write_timeouts	test/regress_bufferevent.c	/^	int n_write_timeouts;$/;"	m	struct:timeout_cb_result	file:	access:public
n_written	bufferevent_openssl.c	/^	unsigned long n_written;$/;"	m	struct:bio_data_counts	file:	access:public
nactivequeues	event-internal.h	/^	int nactivequeues;$/;"	m	struct:event_base	access:public
name	evdns.c	/^			char name[HOST_NAME_MAX];$/;"	m	struct:reply::__anon8::__anon11	file:	access:public
name	evdns.c	/^	char *name; \/* name part of the RR *\/$/;"	m	struct:server_reply_item	file:	access:public
name	event-internal.h	/^	const char *name;$/;"	m	struct:eventop	access:public
name	evrpc-internal.h	/^	char *name;$/;"	m	struct:evrpc_request_wrapper	access:public
name	http.c	/^	const char *name;$/;"	m	struct:response_class	file:	access:public
name	include/event2/dns_struct.h	/^	char name[1];$/;"	m	struct:evdns_server_question	access:public
name	test/test-ratelim.c	/^	const char *name; int *ptr; int min; int isbool;$/;"	m	struct:option	file:	access:public
name	test/tinytest.h	/^	const char *name; \/**< An identifier for this case. *\/$/;"	m	struct:testcase_t	access:public
name_from_addr	http.c	/^name_from_addr(struct sockaddr *sa, ev_socklen_t salen,$/;"	f	file:	signature:(struct sockaddr *sa, ev_socklen_t salen, char **phost, char **pport)
name_from_addr	http.c	/^static void name_from_addr(struct sockaddr *, ev_socklen_t, char **, char **);$/;"	p	file:	signature:(struct sockaddr *, ev_socklen_t, char **, char **)
name_parse	evdns.c	/^name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {$/;"	f	file:	signature:(u8 *packet, int length, int *idx, char *name_out, int name_out_len)
nameserver	evdns.c	/^struct nameserver {$/;"	s	file:
nameserver::address	evdns.c	/^	struct sockaddr_storage address;$/;"	m	struct:nameserver	typeref:struct:nameserver::sockaddr_storage	file:	access:public
nameserver::addrlen	evdns.c	/^	ev_socklen_t addrlen;$/;"	m	struct:nameserver	file:	access:public
nameserver::base	evdns.c	/^	struct evdns_base *base;$/;"	m	struct:nameserver	typeref:struct:nameserver::evdns_base	file:	access:public
nameserver::choked	evdns.c	/^	char choked;  \/* true if we have an EAGAIN from this server's socket *\/$/;"	m	struct:nameserver	file:	access:public
nameserver::event	evdns.c	/^	struct event event;$/;"	m	struct:nameserver	typeref:struct:nameserver::event	file:	access:public
nameserver::failed_times	evdns.c	/^	int failed_times;  \/* number of times which we have given this server a chance *\/$/;"	m	struct:nameserver	file:	access:public
nameserver::next	evdns.c	/^	struct nameserver *next, *prev;$/;"	m	struct:nameserver	typeref:struct:nameserver::nameserver	file:	access:public
nameserver::prev	evdns.c	/^	struct nameserver *next, *prev;$/;"	m	struct:nameserver	typeref:struct:nameserver::	file:	access:public
nameserver::probe_request	evdns.c	/^	struct evdns_request *probe_request;$/;"	m	struct:nameserver	typeref:struct:nameserver::evdns_request	file:	access:public
nameserver::socket	evdns.c	/^	evutil_socket_t socket;	 \/* a connected UDP socket *\/$/;"	m	struct:nameserver	file:	access:public
nameserver::state	evdns.c	/^	char state;  \/* zero if we think that this server is down *\/$/;"	m	struct:nameserver	file:	access:public
nameserver::timedout	evdns.c	/^	int timedout;  \/* number of times in a row a request has timed out *\/$/;"	m	struct:nameserver	file:	access:public
nameserver::timeout_event	evdns.c	/^	struct event timeout_event;  \/* used to keep the timeout for *\/$/;"	m	struct:nameserver	typeref:struct:nameserver::event	file:	access:public
nameserver::write_waiting	evdns.c	/^	char write_waiting;  \/* true if we are waiting for EV_WRITE events *\/$/;"	m	struct:nameserver	file:	access:public
nameserver_failed	evdns.c	/^nameserver_failed(struct nameserver *const ns, const char *msg) {$/;"	f	file:	signature:(struct nameserver *const ns, const char *msg)
nameserver_pick	evdns.c	/^nameserver_pick(struct evdns_base *base) {$/;"	f	file:	signature:(struct evdns_base *base)
nameserver_pick	evdns.c	/^static struct nameserver *nameserver_pick(struct evdns_base *base);$/;"	p	file:	signature:(struct evdns_base *base)
nameserver_probe_callback	evdns.c	/^nameserver_probe_callback(int result, char type, int count, int ttl, void *addresses, void *arg) {$/;"	f	file:	signature:(int result, char type, int count, int ttl, void *addresses, void *arg)
nameserver_probe_failed	evdns.c	/^nameserver_probe_failed(struct nameserver *const ns) {$/;"	f	file:	signature:(struct nameserver *const ns)
nameserver_prod_callback	evdns.c	/^nameserver_prod_callback(evutil_socket_t fd, short events, void *arg) {$/;"	f	file:	signature:(evutil_socket_t fd, short events, void *arg)
nameserver_read	evdns.c	/^nameserver_read(struct nameserver *ns) {$/;"	f	file:	signature:(struct nameserver *ns)
nameserver_ready_callback	evdns.c	/^nameserver_ready_callback(evutil_socket_t fd, short events, void *arg) {$/;"	f	file:	signature:(evutil_socket_t fd, short events, void *arg)
nameserver_ready_callback	evdns.c	/^static void nameserver_ready_callback(evutil_socket_t fd, short events, void *arg);$/;"	p	file:	signature:(evutil_socket_t fd, short events, void *arg)
nameserver_send_probe	evdns.c	/^nameserver_send_probe(struct nameserver *const ns) {$/;"	f	file:	signature:(struct nameserver *const ns)
nameserver_send_probe	evdns.c	/^static void nameserver_send_probe(struct nameserver *const ns);$/;"	p	file:	signature:(struct nameserver *const ns)
nameserver_up	evdns.c	/^nameserver_up(struct nameserver *const ns)$/;"	f	file:	signature:(struct nameserver *const ns)
nameserver_write_waiting	evdns.c	/^nameserver_write_waiting(struct nameserver *ns, char waiting) {$/;"	f	file:	signature:(struct nameserver *ns, char waiting)
nchanges	devpoll.c	/^	int nchanges;$/;"	m	struct:devpollop	file:	access:public
ndots	evdns.c	/^	int ndots;$/;"	m	struct:search_state	file:	access:public
need_input_hook	test/regress_rpc.c	/^static int need_input_hook = 0;$/;"	v	file:
need_numeric_port_hack	evutil.c	/^need_numeric_port_hack(void)$/;"	f	file:	signature:(void)
need_numeric_port_hack_	evutil.c	/^static int need_numeric_port_hack_=0;$/;"	v	file:
need_output_hook	test/regress_rpc.c	/^static int need_output_hook = 0;$/;"	v	file:
need_reinit	event-internal.h	/^	int need_reinit;$/;"	m	struct:eventop	access:public
need_socktype_protocol_hack	evutil.c	/^need_socktype_protocol_hack(void)$/;"	f	file:	signature:(void)
need_socktype_protocol_hack_	evutil.c	/^static int need_socktype_protocol_hack_=0;$/;"	v	file:
nentries	event-internal.h	/^	int nentries;$/;"	m	struct:event_signal_map	access:public
nevents	devpoll.c	/^	int nevents;$/;"	m	struct:devpollop	file:	access:public
nevents	epoll.c	/^	int nevents;$/;"	m	struct:epollop	file:	access:public
new_accepting_socket	listener.c	/^new_accepting_socket(struct evconnlistener_iocp *lev, int family)$/;"	f	file:	signature:(struct evconnlistener_iocp *lev, int family)
next	evbuffer-internal.h	/^	TAILQ_ENTRY(evbuffer_cb_entry) next;$/;"	m	struct:evbuffer_cb_entry	access:public
next	evbuffer-internal.h	/^	struct evbuffer_chain *next;$/;"	m	struct:evbuffer_chain	typeref:struct:evbuffer_chain::evbuffer_chain	access:public
next	evdns.c	/^	struct nameserver *next, *prev;$/;"	m	struct:nameserver	typeref:struct:nameserver::nameserver	file:	access:public
next	evdns.c	/^	struct request *next, *prev;$/;"	m	struct:request	typeref:struct:request::request	file:	access:public
next	evdns.c	/^	struct search_domain *next;$/;"	m	struct:search_domain	typeref:struct:search_domain::search_domain	file:	access:public
next	evdns.c	/^	struct server_reply_item *next; \/* next item in sequence. *\/$/;"	m	struct:server_reply_item	typeref:struct:server_reply_item::server_reply_item	file:	access:public
next	event-internal.h	/^	TAILQ_ENTRY(event_config_entry) next;$/;"	m	struct:event_config_entry	access:public
next	evrpc-internal.h	/^	TAILQ_ENTRY(evrpc_hook) next;$/;"	m	struct:evrpc_hook	access:public
next	evrpc-internal.h	/^	TAILQ_ENTRY(evrpc_hook_ctx) next;$/;"	m	struct:evrpc_hook_ctx	access:public
next	evrpc-internal.h	/^	TAILQ_ENTRY(evrpc_meta) next;$/;"	m	struct:evrpc_meta	access:public
next	evrpc-internal.h	/^	TAILQ_ENTRY(evrpc_request_wrapper) next;$/;"	m	struct:evrpc_request_wrapper	access:public
next	http-internal.h	/^	TAILQ_ENTRY(evhttp_bound_socket) next;$/;"	m	struct:evhttp_bound_socket	access:public
next	http-internal.h	/^	TAILQ_ENTRY(evhttp_cb) next;$/;"	m	struct:evhttp_cb	access:public
next	http-internal.h	/^	TAILQ_ENTRY(evhttp_connection) next;$/;"	m	struct:evhttp_connection	access:public
next	http-internal.h	/^	TAILQ_ENTRY(evhttp_server_alias) next;$/;"	m	struct:evhttp_server_alias	access:public
next	include/event2/http_struct.h	/^	TAILQ_ENTRY(evhttp_request) next;$/;"	m	struct:evhttp_request	access:public
next	include/event2/keyvalq_struct.h	/^	TAILQ_ENTRY(evkeyval) next;$/;"	m	struct:evkeyval	access:public
next	include/event2/rpc_struct.h	/^	TAILQ_ENTRY(evrpc) next;$/;"	m	struct:evrpc	access:public
next_in_group	bufferevent-internal.h	/^	TAILQ_ENTRY(bufferevent_private) next_in_group;$/;"	m	struct:bufferevent_rate_limit	access:public
next_pending	evdns.c	/^	struct server_request *next_pending;$/;"	m	struct:server_request	typeref:struct:server_request::server_request	file:	access:public
next_vhost	http-internal.h	/^	TAILQ_ENTRY(evhttp) next_vhost;$/;"	m	struct:evhttp	access:public
nfds	poll.c	/^	int nfds;			\/* Highest number used *\/$/;"	m	struct:pollop	file:	access:public
nil_accept_cb	test/regress_dns.c	/^nil_accept_cb(struct evconnlistener *l, evutil_socket_t fd, struct sockaddr *s,$/;"	f	file:	signature:(struct evconnlistener *l, evutil_socket_t fd, struct sockaddr *s, int socklen, void *arg)
nil_setup	test/regress_buffer.c	/^static const struct testcase_setup_t nil_setup = {$/;"	v	typeref:struct:testcase_setup_t	file:
no_cleanup	test/regress_buffer.c	/^no_cleanup(const void *data, size_t datalen, void *extra)$/;"	f	file:	signature:(const void *data, size_t datalen, void *extra)
nobase_include_HEADERS	include/Makefile	/^nobase_include_HEADERS = $(EVENT2_EXPORT)$/;"	m
nobase_nodist_include_HEADERS	include/Makefile	/^nobase_nodist_include_HEADERS = .\/event2\/event-config.h$/;"	m
noinst_HEADERS	Makefile	/^noinst_HEADERS = util-internal.h mm-internal.h ipv6-internal.h \\$/;"	m
noinst_HEADERS	test/Makefile	/^noinst_HEADERS = tinytest.h tinytest_macros.h regress.h tinytest_local.h$/;"	m
noinst_PROGRAMS	sample/Makefile	/^noinst_PROGRAMS = event-test$(EXEEXT) time-test$(EXEEXT) \\$/;"	m
noinst_PROGRAMS	test/Makefile	/^noinst_PROGRAMS = test-init$(EXEEXT) test-eof$(EXEEXT) \\$/;"	m
nonident	event_rpcgen.py	/^nonident = re.compile(r'[^a-zA-Z0-9_]')$/;"	v
notification_fd_used	test/regress_thread.c	/^static int notification_fd_used = 0;$/;"	v	file:
notify_arg	defer-internal.h	/^	void *notify_arg;$/;"	m	struct:deferred_cb_queue	access:public
notify_base_cbq_callback	event.c	/^notify_base_cbq_callback(struct deferred_cb_queue *cb, void *baseptr)$/;"	f	file:	signature:(struct deferred_cb_queue *cb, void *baseptr)
notify_fd_cb	test/regress_thread.c	/^notify_fd_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
notify_fn	defer-internal.h	/^	void (*notify_fn)(struct deferred_cb_queue *, void *);$/;"	m	struct:deferred_cb_queue	access:public
nquestions	include/event2/dns_struct.h	/^	int nquestions;$/;"	m	struct:evdns_server_request	access:public
nread	evmap.c	/^	ev_uint16_t nread;$/;"	m	struct:evmap_io	file:	access:public
nread	test/regress.c	/^	int nread;$/;"	m	struct:both	file:	access:public
ns	evdns.c	/^	struct nameserver *ns;	\/* the server which we last sent it *\/$/;"	m	struct:request	typeref:struct:request::nameserver	file:	access:public
ntoread	include/event2/http_struct.h	/^	ev_int64_t ntoread;$/;"	m	struct:evhttp_request	access:public
num_active	test/bench.c	/^static int num_pipes, num_active, num_writes;$/;"	v	file:
num_domains	evdns.c	/^	int num_domains;$/;"	m	struct:search_state	file:	access:public
num_fds_in_fd_sets	win32select.c	/^	unsigned num_fds_in_fd_sets;$/;"	m	struct:win32op	file:	access:public
num_pipes	test/bench.c	/^static int num_pipes, num_active, num_writes;$/;"	v	file:
num_responses	http.c	/^	size_t num_responses;$/;"	m	struct:response_class	file:	access:public
num_writes	test/bench.c	/^static int num_pipes, num_active, num_writes;$/;"	v	file:
nwrite	evmap.c	/^	ev_uint16_t nwrite;$/;"	m	struct:evmap_io	file:	access:public
off	evbuffer-internal.h	/^	size_t off;$/;"	m	struct:evbuffer_chain	access:public
off64_t	test/regress_zlib.c	77;"	d	file:
ok	bufferevent_async.c	/^	unsigned ok : 1;$/;"	m	struct:bufferevent_async	file:	access:public
old_events	changelist-internal.h	/^	short old_events;$/;"	m	struct:event_change	access:public
oldincludedir	Makefile	/^oldincludedir = \/usr\/include$/;"	m
oldincludedir	include/Makefile	/^oldincludedir = \/usr\/include$/;"	m
oldincludedir	sample/Makefile	/^oldincludedir = \/usr\/include$/;"	m
oldincludedir	test/Makefile	/^oldincludedir = \/usr\/include$/;"	m
open	evutil.c	83;"	d	file:
open	sample/http-server.c	53;"	d	file:
open_ssl_bufevs	test/regress_ssl.c	/^open_ssl_bufevs(struct bufferevent **bev1_out, struct bufferevent **bev2_out,$/;"	f	file:	signature:(struct bufferevent **bev1_out, struct bufferevent **bev2_out, struct event_base *base, int is_open, int flags, SSL *ssl1, SSL *ssl2, evutil_socket_t *fd_pair, struct bufferevent **underlying_pair)
ops	listener.c	/^	const struct evconnlistener_ops *ops;$/;"	m	struct:evconnlistener	typeref:struct:evconnlistener::evconnlistener_ops	file:	access:public
opt_forked	test/tinytest.c	/^static int opt_forked = 0; \/**< True iff we're called from inside a win32 fork*\/$/;"	v	file:
opt_nofork	test/tinytest.c	/^static int opt_nofork = 0; \/**< Suppress calls to fork() for debugging. *\/$/;"	v	file:
opt_verbosity	test/tinytest.c	/^static int opt_verbosity = 1; \/**< -==quiet,0==terse,1==normal,2==verbose *\/$/;"	v	file:
option	test/test-ratelim.c	/^static struct option {$/;"	s	file:
option::isbool	test/test-ratelim.c	/^	const char *name; int *ptr; int min; int isbool;$/;"	m	struct:option	file:	access:public
option::min	test/test-ratelim.c	/^	const char *name; int *ptr; int min; int isbool;$/;"	m	struct:option	file:	access:public
option::name	test/test-ratelim.c	/^	const char *name; int *ptr; int min; int isbool;$/;"	m	struct:option	file:	access:public
option::ptr	test/test-ratelim.c	/^	const char *name; int *ptr; int min; int isbool;$/;"	m	struct:option	file:	access:public
options	bufferevent-internal.h	/^	enum bufferevent_options options;$/;"	m	struct:bufferevent_private	typeref:enum:bufferevent_private::bufferevent_options	access:public
options	test/test-ratelim.c	/^} options[] = {$/;"	v	typeref:struct:option	file:
orig_size	include/event2/buffer.h	/^	size_t orig_size;$/;"	m	struct:evbuffer_cb_info	access:public
out_hooks	evrpc-internal.h	/^	struct evrpc_hook_list out_hooks;$/;"	m	struct:_evrpc_hooks	typeref:struct:_evrpc_hooks::evrpc_hook_list	access:public
outbuf_cb	bufferevent_filter.c	/^	struct evbuffer_cb_entry *outbuf_cb;$/;"	m	struct:bufferevent_filtered	typeref:struct:bufferevent_filtered::evbuffer_cb_entry	file:	access:public
outbuf_cb	bufferevent_openssl.c	/^	struct evbuffer_cb_entry *outbuf_cb;$/;"	m	struct:bufferevent_openssl	typeref:struct:bufferevent_openssl::evbuffer_cb_entry	file:	access:public
outcome	test/tinytest.c	/^enum outcome { SKIP=2, OK=1, FAIL=0 };$/;"	g	file:
outfilter_calls	test/regress_zlib.c	/^static int outfilter_calls;$/;"	v	file:
output	include/event2/bufferevent_struct.h	/^	struct evbuffer *output;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::evbuffer	access:public
output_buffer	include/event2/http_struct.h	/^	struct evbuffer *output_buffer;	\/* outgoing post or data *\/$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evbuffer	access:public
output_headers	include/event2/http_struct.h	/^	struct evkeyvalq *output_headers;$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evkeyvalq	access:public
output_hooks	evrpc-internal.h	68;"	d
overlapped	iocp-internal.h	/^	OVERLAPPED overlapped;$/;"	m	struct:event_overlapped	access:public
overlapped	listener.c	/^	struct event_overlapped overlapped;$/;"	m	struct:accepting_socket	typeref:struct:accepting_socket::event_overlapped	file:	access:public
own_lock	bufferevent-internal.h	/^	unsigned own_lock : 1;$/;"	m	struct:bufferevent_private	access:public
own_lock	evbuffer-internal.h	/^	unsigned own_lock : 1;$/;"	m	struct:evbuffer	access:public
p	minheap-internal.h	/^	struct event** p;$/;"	m	struct:min_heap	typeref:struct:min_heap::event	access:public
pai_events	test/regress.c	/^static struct event pai_events[3];$/;"	v	typeref:struct:event	file:
pair	test/regress.c	/^evutil_socket_t pair[2];$/;"	v
pair	test/regress.h	/^	evutil_socket_t pair[2];$/;"	m	struct:basic_test_data	access:public
pair	test/test-weof.c	/^evutil_socket_t pair[2];$/;"	v
pair_is_in	test/regress_iocp.c	/^pair_is_in(struct dummy_overlapped *o, uintptr_t key, ev_ssize_t n)$/;"	f	file:	signature:(struct dummy_overlapped *o, uintptr_t key, ev_ssize_t n)
parent	evbuffer-internal.h	/^	struct bufferevent *parent;$/;"	m	struct:evbuffer	typeref:struct:evbuffer::bufferevent	access:public
parse	test/regress_util.c	/^	const char *parse;$/;"	m	struct:sa_port_ent	file:	access:public
parse	test/regress_util.c	/^	const char *parse;$/;"	m	struct:sa_pred_ent	file:	access:public
parse_authority	http.c	/^parse_authority(struct evhttp_uri *uri, char *s, char *eos)$/;"	f	file:	signature:(struct evhttp_uri *uri, char *s, char *eos)
parse_numeric_servname	evutil.c	/^parse_numeric_servname(const char *servname)$/;"	f	file:	signature:(const char *servname)
parse_port	http.c	/^parse_port(const char *s, const char *eos)$/;"	f	file:	signature:(const char *s, const char *eos)
partner	bufferevent_pair.c	/^	struct bufferevent_pair *partner;$/;"	m	struct:bufferevent_pair	typeref:struct:bufferevent_pair::bufferevent_pair	file:	access:public
path	http.c	/^	char *path; \/* path, or "". *\/$/;"	m	struct:evhttp_uri	file:	access:public
path_matches_noscheme	http.c	/^path_matches_noscheme(const char *cp)$/;"	f	file:	signature:(const char *cp)
pause_requests	evrpc-internal.h	/^	struct evrpc_pause_list pause_requests;$/;"	m	struct:_evrpc_hooks	typeref:struct:_evrpc_hooks::evrpc_pause_list	access:public
paused_requests	evrpc-internal.h	69;"	d
pdfdir	Makefile	/^pdfdir = ${docdir}$/;"	m
pdfdir	include/Makefile	/^pdfdir = ${docdir}$/;"	m
pdfdir	sample/Makefile	/^pdfdir = ${docdir}$/;"	m
pdfdir	test/Makefile	/^pdfdir = ${docdir}$/;"	m
pending	test/regress_dns.c	/^static int pending = 0;$/;"	v	file:
pending_cb	evdns.c	/^	int pending_cb; \/* Waiting for its callback to be invoked; not$/;"	m	struct:evdns_request	file:	access:public
pending_connect_events	test/regress_ssl.c	/^static int pending_connect_events = 0;$/;"	v	file:
pending_error	evdns.c	/^	int pending_error;$/;"	m	struct:evdns_getaddrinfo_request	file:	access:public
pending_replies	evdns.c	/^	struct server_request *pending_replies;$/;"	m	struct:evdns_server_port	typeref:struct:evdns_server_port::server_request	file:	access:public
pending_result	evdns.c	/^	struct evutil_addrinfo *pending_result;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::evutil_addrinfo	file:	access:public
pending_unsuspend_read	bufferevent-internal.h	/^	unsigned pending_unsuspend_read : 1;$/;"	m	struct:bufferevent_rate_limit_group	access:public
pending_unsuspend_write	bufferevent-internal.h	/^	unsigned pending_unsuspend_write : 1;$/;"	m	struct:bufferevent_rate_limit_group	access:public
periodic_timeout_cb	test/regress.c	/^periodic_timeout_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
persist_active_timeout_called	test/regress.c	/^struct persist_active_timeout_called {$/;"	s	file:
persist_active_timeout_called::events	test/regress.c	/^	short events[16];$/;"	m	struct:persist_active_timeout_called	file:	access:public
persist_active_timeout_called::n	test/regress.c	/^	int n;$/;"	m	struct:persist_active_timeout_called	file:	access:public
persist_active_timeout_called::tvs	test/regress.c	/^	struct timeval tvs[16];$/;"	m	struct:persist_active_timeout_called	typeref:struct:persist_active_timeout_called::timeval	file:	access:public
persist_active_timeout_cb	test/regress.c	/^persist_active_timeout_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
pid	kqueue.c	/^	pid_t pid;$/;"	m	struct:kqop	file:	access:public
pid_t	arc4random.c	84;"	d	file:
pin_release	buffer_iocp.c	/^pin_release(struct evbuffer_overlapped *eo, unsigned flag)$/;"	f	file:	signature:(struct evbuffer_overlapped *eo, unsigned flag)
pipes	test/bench.c	/^static evutil_socket_t *pipes;$/;"	v	file:
pipes	test/bench_cascade.c	/^static evutil_socket_t *pipes;$/;"	v	file:
pkgconfig_DATA	Makefile	/^pkgconfig_DATA = $(LIBEVENT_PKGCONFIG)$/;"	m
pkgconfigdir	Makefile	/^pkgconfigdir = $(libdir)\/pkgconfig$/;"	m
pkgdatadir	Makefile	/^pkgdatadir = $(datadir)\/libevent$/;"	m
pkgdatadir	include/Makefile	/^pkgdatadir = $(datadir)\/libevent$/;"	m
pkgdatadir	sample/Makefile	/^pkgdatadir = $(datadir)\/libevent$/;"	m
pkgdatadir	test/Makefile	/^pkgdatadir = $(datadir)\/libevent$/;"	m
pkgincludedir	Makefile	/^pkgincludedir = $(includedir)\/libevent$/;"	m
pkgincludedir	include/Makefile	/^pkgincludedir = $(includedir)\/libevent$/;"	m
pkgincludedir	sample/Makefile	/^pkgincludedir = $(includedir)\/libevent$/;"	m
pkgincludedir	test/Makefile	/^pkgincludedir = $(includedir)\/libevent$/;"	m
pkglibdir	Makefile	/^pkglibdir = $(libdir)\/libevent$/;"	m
pkglibdir	include/Makefile	/^pkglibdir = $(libdir)\/libevent$/;"	m
pkglibdir	sample/Makefile	/^pkglibdir = $(libdir)\/libevent$/;"	m
pkglibdir	test/Makefile	/^pkglibdir = $(libdir)\/libevent$/;"	m
pkglibexecdir	Makefile	/^pkglibexecdir = $(libexecdir)\/libevent$/;"	m
pkglibexecdir	include/Makefile	/^pkglibexecdir = $(libexecdir)\/libevent$/;"	m
pkglibexecdir	sample/Makefile	/^pkglibexecdir = $(libexecdir)\/libevent$/;"	m
pkglibexecdir	test/Makefile	/^pkglibexecdir = $(libexecdir)\/libevent$/;"	m
poll_add	poll.c	/^poll_add(struct event_base *base, int fd, short old, short events, void *_idx)$/;"	f	file:	signature:(struct event_base *base, int fd, short old, short events, void *_idx)
poll_add	poll.c	/^static int poll_add(struct event_base *, int, short old, short events, void *_idx);$/;"	p	file:	signature:(struct event_base *, int, short old, short events, void *_idx)
poll_check_ok	poll.c	/^poll_check_ok(struct pollop *pop)$/;"	f	file:	signature:(struct pollop *pop)
poll_check_ok	poll.c	115;"	d	file:
poll_dealloc	poll.c	/^poll_dealloc(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
poll_dealloc	poll.c	/^static void poll_dealloc(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
poll_del	poll.c	/^poll_del(struct event_base *base, int fd, short old, short events, void *_idx)$/;"	f	file:	signature:(struct event_base *base, int fd, short old, short events, void *_idx)
poll_del	poll.c	/^static int poll_del(struct event_base *, int, short old, short events, void *_idx);$/;"	p	file:	signature:(struct event_base *, int, short old, short events, void *_idx)
poll_dispatch	poll.c	/^poll_dispatch(struct event_base *base, struct timeval *tv)$/;"	f	file:	signature:(struct event_base *base, struct timeval *tv)
poll_dispatch	poll.c	/^static int poll_dispatch(struct event_base *, struct timeval *);$/;"	p	file:	signature:(struct event_base *, struct timeval *)
poll_init	poll.c	/^poll_init(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
poll_init	poll.c	/^static void *poll_init(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
pollidx	poll.c	/^struct pollidx {$/;"	s	file:
pollidx::idxplus1	poll.c	/^	int idxplus1;$/;"	m	struct:pollidx	file:	access:public
pollop	poll.c	/^struct pollop {$/;"	s	file:
pollop::event_count	poll.c	/^	int event_count;		\/* Highest number alloc *\/$/;"	m	struct:pollop	file:	access:public
pollop::event_set	poll.c	/^	struct pollfd *event_set;$/;"	m	struct:pollop	typeref:struct:pollop::pollfd	file:	access:public
pollop::event_set_copy	poll.c	/^	struct pollfd *event_set_copy;$/;"	m	struct:pollop	typeref:struct:pollop::pollfd	file:	access:public
pollop::nfds	poll.c	/^	int nfds;			\/* Highest number used *\/$/;"	m	struct:pollop	file:	access:public
pollop::realloc_copy	poll.c	/^	int realloc_copy;		\/* True iff we must realloc$/;"	m	struct:pollop	file:	access:public
pollops	poll.c	/^const struct eventop pollops = {$/;"	v	typeref:struct:eventop
pool	evrpc-internal.h	/^	struct evrpc_pool *pool;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::evrpc_pool	access:public
port	evdns.c	/^	ev_uint16_t port;$/;"	m	struct:evdns_getaddrinfo_request	file:	access:public
port	evdns.c	/^	struct evdns_server_port *port; \/* Which port received this request on? *\/$/;"	m	struct:server_request	typeref:struct:server_request::evdns_server_port	file:	access:public
port	http-internal.h	/^	u_short port;$/;"	m	struct:evhttp_connection	access:public
port	http.c	/^	int port; \/* port, or zero *\/$/;"	m	struct:evhttp_uri	file:	access:public
port	iocp-internal.h	/^	HANDLE port;$/;"	m	struct:event_iocp_port	access:public
port	listener.c	/^	struct event_iocp_port *port;$/;"	m	struct:evconnlistener_iocp	typeref:struct:evconnlistener_iocp::event_iocp_port	file:	access:public
port	test/regress_util.c	/^	int port;$/;"	m	struct:sa_port_ent	file:	access:public
pos	evdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	m	struct:dnslabel_entry	file:	access:public
pos	include/event2/buffer.h	/^	ev_ssize_t pos;$/;"	m	struct:evbuffer_ptr	access:public
pos_in_chain	include/event2/buffer.h	/^		size_t pos_in_chain;$/;"	m	struct:evbuffer_ptr::__anon1	access:public
prefix	Makefile	/^prefix = \/usr$/;"	m
prefix	include/Makefile	/^prefix = \/usr$/;"	m
prefix	sample/Makefile	/^prefix = \/usr$/;"	m
prefix	test/Makefile	/^prefix = \/usr$/;"	m
prefix	test/tinytest.h	/^	const char *prefix; \/**< Prefix to prepend to testnames. *\/$/;"	m	struct:testgroup_t	access:public
prefix_suffix_match	http.c	/^prefix_suffix_match(const char *pattern, const char *name, int ignorecase)$/;"	f	file:	signature:(const char *pattern, const char *name, int ignorecase)
premature_event	test/regress.c	/^static int premature_event = 0;$/;"	v	file:
prev	evdns.c	/^	struct nameserver *next, *prev;$/;"	m	struct:nameserver	typeref:struct:nameserver::	file:	access:public
prev	evdns.c	/^	struct request *next, *prev;$/;"	m	struct:request	typeref:struct:request::	file:	access:public
prev_pending	evdns.c	/^	struct server_request *prev_pending;$/;"	m	struct:server_request	typeref:struct:server_request::server_request	file:	access:public
print_err	bufferevent_openssl.c	99;"	d	file:
prio_active_inversion_cb	test/regress.c	/^prio_active_inversion_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
probe_request	evdns.c	/^	struct evdns_request *probe_request;$/;"	m	struct:nameserver	typeref:struct:nameserver::evdns_request	file:	access:public
process	evrpc-internal.h	/^	int (*process)(void *, struct evhttp_request *,$/;"	m	struct:evrpc_hook	access:public
process_arg	evrpc-internal.h	/^	void *process_arg;$/;"	m	struct:evrpc_hook	access:public
process_in	bufferevent_filter.c	/^	bufferevent_filter_cb process_in;$/;"	m	struct:bufferevent_filtered	file:	access:public
process_out	bufferevent_filter.c	/^	bufferevent_filter_cb process_out;$/;"	m	struct:bufferevent_filtered	file:	access:public
program_transform_name	Makefile	/^program_transform_name = s,x,x,$/;"	m
program_transform_name	include/Makefile	/^program_transform_name = s,x,x,$/;"	m
program_transform_name	sample/Makefile	/^program_transform_name = s,x,x,$/;"	m
program_transform_name	test/Makefile	/^program_transform_name = s,x,x,$/;"	m
prototypes	configure	/^   function prototypes and stuff, but not '\\xHH' hex character constants.$/;"	f
psdir	Makefile	/^psdir = ${docdir}$/;"	m
psdir	include/Makefile	/^psdir = ${docdir}$/;"	m
psdir	sample/Makefile	/^psdir = ${docdir}$/;"	m
psdir	test/Makefile	/^psdir = ${docdir}$/;"	m
ptr	bufferevent-internal.h	/^	void *ptr;$/;"	m	union:bufferevent_ctrl_data	access:public
ptr	evdns.c	/^		} ptr;$/;"	m	union:reply::__anon8	typeref:struct:reply::__anon8::__anon11	file:	access:public
ptr	event.c	/^	const struct event *ptr;$/;"	m	struct:event_debug_entry	typeref:struct:event_debug_entry::event	file:	access:public
ptr	test/test-ratelim.c	/^	const char *name; int *ptr; int min; int isbool;$/;"	m	struct:option	file:	access:public
put_cname_in_ptr	evdns.c	/^	char **put_cname_in_ptr; \/* store the cname here if we get one. *\/$/;"	m	struct:request	file:	access:public
put_error	bufferevent_openssl.c	/^put_error(struct bufferevent_openssl *bev_ssl, unsigned long err)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl, unsigned long err)
q	test/regress_testutils.h	/^	const char *q;$/;"	m	struct:regress_dns_server_table	access:public
query	http.c	/^	char *query; \/* query, or NULL *\/$/;"	m	struct:evhttp_uri	file:	access:public
questions	include/event2/dns_struct.h	/^	struct evdns_server_question **questions;$/;"	m	struct:evdns_server_request	typeref:struct:evdns_server_request::evdns_server_question	access:public
queue	test/regress_thread.c	/^	struct deferred_cb_queue *queue;$/;"	m	struct:deferred_test_data	typeref:struct:deferred_test_data::deferred_cb_queue	file:	access:public
queued	defer-internal.h	/^	unsigned queued : 1;$/;"	m	struct:deferred_cb	access:public
queued	test/test-ratelim.c	/^	size_t queued;$/;"	m	struct:client_state	file:	access:public
r	evdns.c	/^	struct evdns_request *r;$/;"	m	struct:getaddrinfo_subrequest	typeref:struct:getaddrinfo_subrequest::evdns_request	file:	access:public
r	test/regress_dns.c	/^	struct generic_dns_callback_result r;$/;"	m	struct:testleak_env_t	typeref:struct:testleak_env_t::generic_dns_callback_result	file:	access:public
rand_int	test/test-time.c	/^rand_int(int n)$/;"	f	file:	signature:(int n)
rate_limit	bufferevent-internal.h	/^	struct ev_token_bucket rate_limit;$/;"	m	struct:bufferevent_rate_limit_group	typeref:struct:bufferevent_rate_limit_group::ev_token_bucket	access:public
rate_limit_cfg	bufferevent-internal.h	/^	struct ev_token_bucket_cfg rate_limit_cfg;$/;"	m	struct:bufferevent_rate_limit_group	typeref:struct:bufferevent_rate_limit_group::ev_token_bucket_cfg	access:public
rate_limiting	bufferevent-internal.h	/^	struct bufferevent_rate_limit *rate_limiting;$/;"	m	struct:bufferevent_private	typeref:struct:bufferevent_private::bufferevent_rate_limit	access:public
ratelim_group	test/test-ratelim.c	/^struct bufferevent_rate_limit_group *ratelim_group = NULL;$/;"	v	typeref:struct:bufferevent_rate_limit_group
rbuf	test/regress.c	/^static char rbuf[4096];$/;"	v	file:
rbuf	test/regress_iocp.c	/^static struct evbuffer *rbuf = NULL, *wbuf = NULL;$/;"	v	typeref:struct:evbuffer	file:
rcsid	strlcpy.c	/^static char *rcsid = "$OpenBSD: strlcpy.c,v 1.5 2001\/05\/13 15:40:16 deraadt Exp $";$/;"	v	file:
re	event_rpcgen.py	/^import re$/;"	i
re_add_read_cb	test/regress.c	/^re_add_read_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
read	evutil.c	84;"	d	file:
read	test/regress.c	98;"	d	file:
read_added	bufferevent_async.c	/^	unsigned read_added : 1;$/;"	m	struct:bufferevent_async	file:	access:public
read_all	arc4random.c	/^read_all(int fd, unsigned char *buf, size_t count)$/;"	f	file:	signature:(int fd, unsigned char *buf, size_t count)
read_blocked_on_write	bufferevent_openssl.c	/^	unsigned read_blocked_on_write : 1;$/;"	m	struct:bufferevent_openssl	file:	access:public
read_called_once_cb	test/regress.c	/^read_called_once_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
read_cb	test/bench.c	/^read_cb(evutil_socket_t fd, short which, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short which, void *arg)
read_cb	test/bench_cascade.c	/^read_cb(evutil_socket_t fd, short which, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short which, void *arg)
read_cb	test/regress_et.c	/^read_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
read_cb	test/test-eof.c	/^read_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
read_change	changelist-internal.h	/^	ev_uint8_t read_change;$/;"	m	struct:event_change	access:public
read_complete	bufferevent_async.c	/^read_complete(struct event_overlapped *eo, ev_uintptr_t key,$/;"	f	file:	signature:(struct event_overlapped *eo, ev_uintptr_t key, ev_ssize_t nbytes, int ok)
read_complete	test/regress_iocp.c	/^read_complete(struct event_overlapped *eo, uintptr_t key,$/;"	f	file:	signature:(struct event_overlapped *eo, uintptr_t key, ev_ssize_t nbytes, int ok)
read_in_progress	buffer_iocp.c	/^	unsigned read_in_progress : 1;$/;"	m	struct:evbuffer_overlapped	file:	access:public
read_in_progress	bufferevent_async.c	/^	size_t read_in_progress;$/;"	m	struct:bufferevent_async	file:	access:public
read_limit	ratelim-internal.h	/^	ev_ssize_t read_limit, write_limit;$/;"	m	struct:ev_token_bucket	access:public
read_maximum	ratelim-internal.h	/^	size_t read_maximum;$/;"	m	struct:ev_token_bucket_cfg	access:public
read_more_deferred_cb	http-internal.h	/^	struct deferred_cb read_more_deferred_cb;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::deferred_cb	access:public
read_once_cb	test/regress.c	/^read_once_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
read_overlapped	bufferevent_async.c	/^	struct event_overlapped read_overlapped;$/;"	m	struct:bufferevent_async	typeref:struct:bufferevent_async::event_overlapped	file:	access:public
read_pos_plus1	win32select.c	/^	int read_pos_plus1;$/;"	m	struct:idx_info	file:	access:public
read_rate	ratelim-internal.h	/^	size_t read_rate;$/;"	m	struct:ev_token_bucket_cfg	access:public
read_suspended	bufferevent-internal.h	/^	bufferevent_suspend_flags read_suspended;$/;"	m	struct:bufferevent_private	access:public
read_suspended	bufferevent-internal.h	/^	unsigned read_suspended : 1;$/;"	m	struct:bufferevent_rate_limit_group	access:public
read_timeout_at	test/regress_bufferevent.c	/^	struct timeval read_timeout_at;$/;"	m	struct:timeout_cb_result	typeref:struct:timeout_cb_result::timeval	file:	access:public
read_watermarks_cb	bufferevent-internal.h	/^	struct evbuffer_cb_entry *read_watermarks_cb;$/;"	m	struct:bufferevent_private	typeref:struct:bufferevent_private::evbuffer_cb_entry	access:public
readcb	include/event2/bufferevent_struct.h	/^	bufferevent_data_cb readcb;$/;"	m	struct:bufferevent	access:public
readcb	sample/le-proxy.c	/^readcb(struct bufferevent *bev, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, void *ctx)
readcb	test/bench_httpclient.c	/^readcb(struct bufferevent *b, void *arg)$/;"	f	file:	signature:(struct bufferevent *b, void *arg)
readcb	test/bench_httpclient.c	/^static void readcb(struct bufferevent *b, void *arg);$/;"	p	file:	signature:(struct bufferevent *b, void *arg)
readcb	test/regress_bufferevent.c	/^readcb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
readcb	test/regress_zlib.c	/^readcb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
readcb_finished	test/regress_zlib.c	/^static int readcb_finished;$/;"	v	file:
readcb_pending	bufferevent-internal.h	/^	unsigned readcb_pending : 1;$/;"	m	struct:bufferevent_private	access:public
readd_test_event_last_added	test/regress.c	/^static struct event *readd_test_event_last_added = NULL;$/;"	v	typeref:struct:event	file:
reader_eventcb	test/regress_bufferevent.c	/^reader_eventcb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *ctx)
reader_readcb	test/regress_bufferevent.c	/^reader_readcb(struct bufferevent *bev, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, void *ctx)
readset_in	win32select.c	/^	struct win_fd_set *readset_in;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
readset_out	win32select.c	/^	struct win_fd_set *readset_out;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
realloc_copy	poll.c	/^	int realloc_copy;		\/* True iff we must realloc$/;"	m	struct:pollop	file:	access:public
reassociate	evport.c	/^reassociate(struct evport_data *epdp, struct fd_info *fdip, int fd)$/;"	f	file:	signature:(struct evport_data *epdp, struct fd_info *fdip, int fd)
received	test/test-ratelim.c	/^	ev_uint64_t received;$/;"	m	struct:client_state	file:	access:public
record_event_cb	test/regress.c	/^record_event_cb(evutil_socket_t s, short what, void *ptr)$/;"	f	file:	signature:(evutil_socket_t s, short what, void *ptr)
redirection_phrases	http.c	/^static const char *redirection_phrases[] = {$/;"	v	file:
reentrant_cb_run	test/regress.c	/^static int reentrant_cb_run = 0;$/;"	v	file:
ref_done_cb	test/regress_buffer.c	/^static void ref_done_cb(const void *data, size_t len, void *info)$/;"	f	file:	signature:(const void *data, size_t len, void *info)
ref_done_cb_called_count	test/regress_buffer.c	/^static int ref_done_cb_called_count = 0;$/;"	v	file:
ref_done_cb_called_with	test/regress_buffer.c	/^static void *ref_done_cb_called_with = NULL;$/;"	v	file:
ref_done_cb_called_with_data	test/regress_buffer.c	/^static const void *ref_done_cb_called_with_data = NULL;$/;"	v	file:
ref_done_cb_called_with_len	test/regress_buffer.c	/^static size_t ref_done_cb_called_with_len = 0;$/;"	v	file:
refcnt	bufferevent-internal.h	/^	int refcnt;$/;"	m	struct:bufferevent_private	access:public
refcnt	evbuffer-internal.h	/^	int refcnt;$/;"	m	struct:evbuffer	access:public
refcnt	evdns.c	/^	int refcnt; \/* reference count. *\/$/;"	m	struct:evdns_server_port	file:	access:public
refcnt	listener.c	/^	short refcnt;$/;"	m	struct:evconnlistener	file:	access:public
refcount	evdns.c	/^	int refcount;$/;"	m	struct:search_state	file:	access:public
reference_cb	test/regress_buffer.c	/^reference_cb(const void *data, size_t len, void *extra)$/;"	f	file:	signature:(const void *data, size_t len, void *extra)
reference_cb_called	test/regress_buffer.c	/^static int reference_cb_called;$/;"	v	file:
refill_bucket_event	bufferevent-internal.h	/^	struct event refill_bucket_event;$/;"	m	struct:bufferevent_rate_limit	typeref:struct:bufferevent_rate_limit::event	access:public
registered_rpcs	evrpc-internal.h	/^	TAILQ_HEAD(evrpc_list, evrpc) registered_rpcs;$/;"	m	struct:evrpc_base	access:public
regname_ok	http.c	/^regname_ok(const char *s, const char *eos)$/;"	f	file:	signature:(const char *s, const char *eos)
regress_CPPFLAGS	test/Makefile	/^regress_CPPFLAGS = $(AM_CPPFLAGS) $(PTHREAD_CFLAGS) $(ZLIB_CFLAGS)$/;"	m
regress_DEPENDENCIES	test/Makefile	/^regress_DEPENDENCIES = $(am__DEPENDENCIES_1) ..\/libevent.la \\$/;"	m
regress_LDADD	test/Makefile	/^regress_LDADD = $(LIBEVENT_GC_SECTIONS) ..\/libevent.la $(PTHREAD_LIBS) \\$/;"	m
regress_LDFLAGS	test/Makefile	/^regress_LDFLAGS = $(PTHREAD_CFLAGS)$/;"	m
regress_LINK	test/Makefile	/^regress_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
regress_OBJECTS	test/Makefile	/^regress_OBJECTS = $(am_regress_OBJECTS)$/;"	m
regress_SOURCES	test/Makefile	/^regress_SOURCES = regress.c regress_buffer.c regress_http.c \\$/;"	m
regress_bufferevent_openssl	test/regress_ssl.c	/^regress_bufferevent_openssl(void *arg)$/;"	f	file:	signature:(void *arg)
regress_bufferevent_openssl_connect	test/regress_ssl.c	/^regress_bufferevent_openssl_connect(void *arg)$/;"	f	file:	signature:(void *arg)
regress_clean_dnsserver	test/regress_testutils.c	/^regress_clean_dnsserver(void)$/;"	f	signature:(void)
regress_clean_dnsserver	test/regress_testutils.h	/^void regress_clean_dnsserver(void);$/;"	p	signature:(void)
regress_dns_server_cb	test/regress_testutils.c	/^regress_dns_server_cb(struct evdns_server_request *req, void *data)$/;"	f	signature:(struct evdns_server_request *req, void *data)
regress_dns_server_cb	test/regress_testutils.h	/^void regress_dns_server_cb($/;"	p	signature:( struct evdns_server_request *req, void *data)
regress_dns_server_table	test/regress_testutils.h	/^struct regress_dns_server_table {$/;"	s
regress_dns_server_table::ans	test/regress_testutils.h	/^	const char *ans;$/;"	m	struct:regress_dns_server_table	access:public
regress_dns_server_table::anstype	test/regress_testutils.h	/^	const char *anstype;$/;"	m	struct:regress_dns_server_table	access:public
regress_dns_server_table::q	test/regress_testutils.h	/^	const char *q;$/;"	m	struct:regress_dns_server_table	access:public
regress_dns_server_table::seen	test/regress_testutils.h	/^	int seen;$/;"	m	struct:regress_dns_server_table	access:public
regress_dnsserver	test/regress_testutils.c	/^regress_dnsserver(struct event_base *base, ev_uint16_t *port,$/;"	f	signature:(struct event_base *base, ev_uint16_t *port, struct regress_dns_server_table *search_table)
regress_dnsserver	test/regress_testutils.h	/^int regress_dnsserver(struct event_base *base, ev_uint16_t *port,$/;"	p	signature:(struct event_base *base, ev_uint16_t *port, struct regress_dns_server_table *seach_table)
regress_fork	test/regress.h	/^pid_t regress_fork(void);$/;"	p	signature:(void)
regress_fork	test/regress_main.c	/^regress_fork(void)$/;"	f	signature:(void)
regress_get_dnsserver	test/regress_testutils.c	/^regress_get_dnsserver(struct event_base *base,$/;"	f	signature:(struct event_base *base, ev_uint16_t *portnum, evutil_socket_t *psock, evdns_request_callback_fn_type cb, void *arg)
regress_get_dnsserver	test/regress_testutils.h	/^regress_get_dnsserver(struct event_base *base,$/;"	p	signature:(struct event_base *base, ev_uint16_t *portnum, evutil_socket_t *psock, evdns_request_callback_fn_type cb, void *arg)
regress_get_listener_addr	test/regress_testutils.c	/^regress_get_listener_addr(struct evconnlistener *lev,$/;"	f	signature:(struct evconnlistener *lev, struct sockaddr *sa, ev_socklen_t *socklen)
regress_get_listener_addr	test/regress_testutils.h	/^int regress_get_listener_addr(struct evconnlistener *lev,$/;"	p	signature:(struct evconnlistener *lev, struct sockaddr *sa, ev_socklen_t *socklen)
regress_get_socket_port	test/regress_testutils.c	/^regress_get_socket_port(evutil_socket_t fd)$/;"	f	signature:(evutil_socket_t fd)
regress_get_socket_port	test/regress_testutils.h	/^int regress_get_socket_port(evutil_socket_t fd);$/;"	p	signature:(evutil_socket_t fd)
regress_ipv4_parse	test/regress_util.c	/^regress_ipv4_parse(void *ptr)$/;"	f	file:	signature:(void *ptr)
regress_ipv6_parse	test/regress_util.c	/^regress_ipv6_parse(void *ptr)$/;"	f	file:	signature:(void *ptr)
regress_listener_error	test/regress_listener.c	/^regress_listener_error(void *arg)$/;"	f	file:	signature:(void *arg)
regress_make_tmpfile	test/regress.h	/^int regress_make_tmpfile(const void *data, size_t datalen);$/;"	p	signature:(const void *data, size_t datalen)
regress_make_tmpfile	test/regress_main.c	/^regress_make_tmpfile(const void *data, size_t datalen)$/;"	f	signature:(const void *data, size_t datalen)
regress_pick_a_port	test/regress_listener.c	/^regress_pick_a_port(void *arg)$/;"	f	file:	signature:(void *arg)
regress_sockaddr_port_format	test/regress_util.c	/^regress_sockaddr_port_format(void *ptr)$/;"	f	file:	signature:(void *ptr)
regress_sockaddr_port_parse	test/regress_util.c	/^regress_sockaddr_port_parse(void *ptr)$/;"	f	file:	signature:(void *ptr)
regress_thread_SOURCES	test/Makefile	/^regress_thread_SOURCES = regress_thread.c$/;"	m
regress_threads	test/regress.h	/^void regress_threads(void *);$/;"	p	signature:(void *)
reissue_count	evdns.c	/^	int reissue_count;$/;"	m	struct:request	file:	access:public
reissue_table	test/regress_dns.c	/^static struct regress_dns_server_table reissue_table[] = {$/;"	v	typeref:struct:regress_dns_server_table	file:
remote_host	include/event2/http_struct.h	/^	char *remote_host;$/;"	m	struct:evhttp_request	access:public
remote_port	include/event2/http_struct.h	/^	ev_uint16_t remote_port;$/;"	m	struct:evhttp_request	access:public
renegotiate_at	test/regress_ssl.c	/^static int renegotiate_at = -1;$/;"	v	file:
reply	evdns.c	/^	struct reply reply;$/;"	m	struct:deferred_reply_callback	typeref:struct:deferred_reply_callback::reply	file:	access:public
reply	evdns.c	/^struct reply {$/;"	s	file:
reply	evrpc-internal.h	/^	void *reply;$/;"	m	struct:evrpc_req_generic	access:public
reply	evrpc-internal.h	/^	void *reply;$/;"	m	struct:evrpc_request_wrapper	access:public
reply::__anon8::__anon10::addrcount	evdns.c	/^			u32 addrcount;$/;"	m	struct:reply::__anon8::__anon10	file:	access:public
reply::__anon8::__anon10::addresses	evdns.c	/^			struct in6_addr addresses[MAX_V6_ADDRS];$/;"	m	struct:reply::__anon8::__anon10	typeref:struct:reply::__anon8::__anon10::in6_addr	file:	access:public
reply::__anon8::__anon11::name	evdns.c	/^			char name[HOST_NAME_MAX];$/;"	m	struct:reply::__anon8::__anon11	file:	access:public
reply::__anon8::__anon9::addrcount	evdns.c	/^			u32 addrcount;$/;"	m	struct:reply::__anon8::__anon9	file:	access:public
reply::__anon8::__anon9::addresses	evdns.c	/^			u32 addresses[MAX_V4_ADDRS];$/;"	m	struct:reply::__anon8::__anon9	file:	access:public
reply::__anon8::a	evdns.c	/^		} a;$/;"	m	union:reply::__anon8	typeref:struct:reply::__anon8::__anon9	file:	access:public
reply::__anon8::aaaa	evdns.c	/^		} aaaa;$/;"	m	union:reply::__anon8	typeref:struct:reply::__anon8::__anon10	file:	access:public
reply::__anon8::ptr	evdns.c	/^		} ptr;$/;"	m	union:reply::__anon8	typeref:struct:reply::__anon8::__anon11	file:	access:public
reply::data	evdns.c	/^	} data;$/;"	m	struct:reply	typeref:union:reply::__anon8	file:	access:public
reply::have_answer	evdns.c	/^	unsigned int have_answer : 1;$/;"	m	struct:reply	file:	access:public
reply::type	evdns.c	/^	unsigned int type;$/;"	m	struct:reply	file:	access:public
reply_clear	evrpc-internal.h	/^	void (*reply_clear)(void *);$/;"	m	struct:evrpc_request_wrapper	access:public
reply_complete	include/event2/rpc_struct.h	/^	int (*reply_complete)(void *);$/;"	m	struct:evrpc	access:public
reply_free	include/event2/rpc_struct.h	/^	void (*reply_free)(void *);$/;"	m	struct:evrpc	access:public
reply_handle	evdns.c	/^reply_handle(struct request *const req, u16 flags, u32 ttl, struct reply *reply) {$/;"	f	file:	signature:(struct request *const req, u16 flags, u32 ttl, struct reply *reply)
reply_marshal	include/event2/rpc_struct.h	/^	void (*reply_marshal)(struct evbuffer*, void *);$/;"	m	struct:evrpc	access:public
reply_new	include/event2/rpc_struct.h	/^	void *(*reply_new)(void *);$/;"	m	struct:evrpc	access:public
reply_new_arg	include/event2/rpc_struct.h	/^	void *reply_new_arg;$/;"	m	struct:evrpc	access:public
reply_parse	evdns.c	/^reply_parse(struct evdns_base *base, u8 *packet, int length) {$/;"	f	file:	signature:(struct evdns_base *base, u8 *packet, int length)
reply_run_callback	evdns.c	/^reply_run_callback(struct deferred_cb *d, void *user_pointer)$/;"	f	file:	signature:(struct deferred_cb *d, void *user_pointer)
reply_schedule_callback	evdns.c	/^reply_schedule_callback(struct request *const req, u32 ttl, u32 err, struct reply *reply)$/;"	f	file:	signature:(struct request *const req, u32 ttl, u32 err, struct reply *reply)
reply_unmarshal	evrpc-internal.h	/^	int (*reply_unmarshal)(void *, struct evbuffer*);$/;"	m	struct:evrpc_request_wrapper	access:public
req	evrpc-internal.h	/^	struct evhttp_request *req;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::evhttp_request	access:public
req	test/regress_dns.c	/^	struct evdns_request *req;$/;"	m	struct:testleak_env_t	typeref:struct:testleak_env_t::evdns_request	file:	access:public
req	test/regress_http.c	/^	struct evhttp_request *req;$/;"	m	struct:chunk_req_state	typeref:struct:chunk_req_state::evhttp_request	file:	access:public
req	test/regress_http.c	/^	struct evhttp_request *req;$/;"	m	struct:terminate_state	typeref:struct:terminate_state::evhttp_request	file:	access:public
req_heads	evdns.c	/^	struct request **req_heads;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::request	file:	access:public
req_waiting_head	evdns.c	/^	struct request *req_waiting_head;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::request	file:	access:public
request	evdns.c	/^	u8 *request;  \/* the dns packet data *\/$/;"	m	struct:request	file:	access:public
request	evdns.c	/^struct request {$/;"	s	file:
request	evrpc-internal.h	/^	void *request;$/;"	m	struct:evrpc_req_generic	access:public
request	evrpc-internal.h	/^	void *request;$/;"	m	struct:evrpc_request_wrapper	access:public
request	test/regress_dns.c	/^	struct evdns_getaddrinfo_request *request;$/;"	m	struct:gaic_request_status	typeref:struct:gaic_request_status::evdns_getaddrinfo_request	file:	access:public
request::base	evdns.c	/^	struct evdns_base *base;$/;"	m	struct:request	typeref:struct:request::evdns_base	file:	access:public
request::handle	evdns.c	/^	struct evdns_request *handle;$/;"	m	struct:request	typeref:struct:request::evdns_request	file:	access:public
request::next	evdns.c	/^	struct request *next, *prev;$/;"	m	struct:request	typeref:struct:request::request	file:	access:public
request::ns	evdns.c	/^	struct nameserver *ns;	\/* the server which we last sent it *\/$/;"	m	struct:request	typeref:struct:request::nameserver	file:	access:public
request::prev	evdns.c	/^	struct request *next, *prev;$/;"	m	struct:request	typeref:struct:request::	file:	access:public
request::put_cname_in_ptr	evdns.c	/^	char **put_cname_in_ptr; \/* store the cname here if we get one. *\/$/;"	m	struct:request	file:	access:public
request::reissue_count	evdns.c	/^	int reissue_count;$/;"	m	struct:request	file:	access:public
request::request	evdns.c	/^	u8 *request;  \/* the dns packet data *\/$/;"	m	struct:request	file:	access:public
request::request_appended	evdns.c	/^	unsigned request_appended :1;	\/* true if the request pointer is data which follows this struct *\/$/;"	m	struct:request	file:	access:public
request::request_len	evdns.c	/^	unsigned int request_len;$/;"	m	struct:request	file:	access:public
request::request_type	evdns.c	/^	u8 request_type; \/* TYPE_PTR or TYPE_A or TYPE_AAAA *\/$/;"	m	struct:request	file:	access:public
request::timeout_event	evdns.c	/^	struct event timeout_event;$/;"	m	struct:request	typeref:struct:request::event	file:	access:public
request::trans_id	evdns.c	/^	u16 trans_id;  \/* the transaction id *\/$/;"	m	struct:request	file:	access:public
request::transmit_me	evdns.c	/^	unsigned transmit_me :1;  \/* needs to be transmitted *\/$/;"	m	struct:request	file:	access:public
request::tx_count	evdns.c	/^	int tx_count;  \/* the number of times that this packet has been sent *\/$/;"	m	struct:request	file:	access:public
request::user_callback	evdns.c	/^	evdns_callback_type user_callback;$/;"	m	struct:request	file:	access:public
request::user_pointer	evdns.c	/^	void *user_pointer;  \/* the pointer given to us for this request *\/$/;"	m	struct:request	file:	access:public
request_appended	evdns.c	/^	unsigned request_appended :1;	\/* true if the request pointer is data which follows this struct *\/$/;"	m	struct:request	file:	access:public
request_count	test/regress_dns.c	/^static int request_count = 0;$/;"	v	file:
request_done	evdns.c	/^	unsigned request_done : 1;$/;"	m	struct:evdns_getaddrinfo_request	file:	access:public
request_find_from_trans_id	evdns.c	/^request_find_from_trans_id(struct evdns_base *base, u16 trans_id) {$/;"	f	file:	signature:(struct evdns_base *base, u16 trans_id)
request_finished	evdns.c	/^request_finished(struct request *const req, struct request **head, int free_handle) {$/;"	f	file:	signature:(struct request *const req, struct request **head, int free_handle)
request_free	include/event2/rpc_struct.h	/^	void (*request_free)(void *);$/;"	m	struct:evrpc	access:public
request_info	test/bench_httpclient.c	/^struct request_info {$/;"	s	file:
request_info::n_read	test/bench_httpclient.c	/^	size_t n_read;$/;"	m	struct:request_info	file:	access:public
request_info::started	test/bench_httpclient.c	/^	struct timeval started;$/;"	m	struct:request_info	typeref:struct:request_info::timeval	file:	access:public
request_len	evdns.c	/^	unsigned int request_len;$/;"	m	struct:request	file:	access:public
request_marshal	evrpc-internal.h	/^	void (*request_marshal)(struct evbuffer *, void *);$/;"	m	struct:evrpc_request_wrapper	access:public
request_new	evdns.c	/^request_new(struct evdns_base *base, struct evdns_request *handle, int type,$/;"	f	file:	signature:(struct evdns_base *base, struct evdns_request *handle, int type, const char *name, int flags, evdns_callback_type callback, void *user_ptr)
request_new	evdns.c	/^static struct request *request_new(struct evdns_base *base, struct evdns_request *handle, int type, const char *name, int flags, evdns_callback_type callback, void *ptr);$/;"	p	file:	signature:(struct evdns_base *base, struct evdns_request *handle, int type, const char *name, int flags, evdns_callback_type callback, void *ptr)
request_new	include/event2/rpc_struct.h	/^	void *(*request_new)(void *);$/;"	m	struct:evrpc	access:public
request_new_arg	include/event2/rpc_struct.h	/^	void *request_new_arg;$/;"	m	struct:evrpc	access:public
request_parse	evdns.c	/^request_parse(u8 *packet, int length, struct evdns_server_port *port, struct sockaddr *addr, ev_socklen_t addrlen)$/;"	f	file:	signature:(u8 *packet, int length, struct evdns_server_port *port, struct sockaddr *addr, ev_socklen_t addrlen)
request_reissue	evdns.c	/^request_reissue(struct request *req) {$/;"	f	file:	signature:(struct request *req)
request_submit	evdns.c	/^request_submit(struct request *const req) {$/;"	f	file:	signature:(struct request *const req)
request_submit	evdns.c	/^static void request_submit(struct request *const req);$/;"	p	file:	signature:(struct request *const req)
request_trans_id_set	evdns.c	/^request_trans_id_set(struct request *const req, const u16 trans_id) {$/;"	f	file:	signature:(struct request *const req, const u16 trans_id)
request_type	evdns.c	/^	u8 request_type; \/* TYPE_PTR or TYPE_A or TYPE_AAAA *\/$/;"	m	struct:request	file:	access:public
request_type	evdns.c	/^	u8 request_type;$/;"	m	struct:deferred_reply_callback	file:	access:public
request_unmarshal	include/event2/rpc_struct.h	/^	int (*request_unmarshal)(void *, struct evbuffer *);$/;"	m	struct:evrpc	access:public
requests	http-internal.h	/^	TAILQ_HEAD(evcon_requestq, evhttp_request) requests;$/;"	m	struct:evhttp_connection	access:public
require_features	event-internal.h	/^	enum event_method_feature require_features;$/;"	m	struct:event_config	typeref:enum:event_config::event_method_feature	access:public
res	test/regress_util.c	/^	ev_uint32_t res;$/;"	m	struct:ipv4_entry	file:	access:public
res	test/regress_util.c	/^	ev_uint32_t res[4];$/;"	m	struct:ipv6_entry	file:	access:public
resize_out_sets	select.c	/^	int resize_out_sets;$/;"	m	struct:selectop	file:	access:public
resize_out_sets	win32select.c	/^	int resize_out_sets;$/;"	m	struct:win32op	file:	access:public
resolv_conf_parse_line	evdns.c	/^resolv_conf_parse_line(struct evdns_base *base, char *const start, int flags) {$/;"	f	file:	signature:(struct evdns_base *base, char *const start, int flags)
resource	test/bench_httpclient.c	/^const char *resource = NULL;$/;"	v
respond_to_number	test/regress_ssl.c	/^respond_to_number(struct bufferevent *bev, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, void *ctx)
response	evdns.c	/^	char *response;$/;"	m	struct:server_request	file:	access:public
response_class	http.c	/^struct response_class {$/;"	s	file:
response_class::name	http.c	/^	const char *name;$/;"	m	struct:response_class	file:	access:public
response_class::num_responses	http.c	/^	size_t num_responses;$/;"	m	struct:response_class	file:	access:public
response_class::responses	http.c	/^	const char **responses;$/;"	m	struct:response_class	file:	access:public
response_classes	http.c	/^static const struct response_class response_classes[] = {$/;"	v	typeref:struct:response_class	file:
response_code	include/event2/http_struct.h	/^	int response_code;		\/* HTTP Response code *\/$/;"	m	struct:evhttp_request	access:public
response_code_line	include/event2/http_struct.h	/^	char *response_code_line;	\/* Readable response *\/$/;"	m	struct:evhttp_request	access:public
response_len	evdns.c	/^	size_t response_len;$/;"	m	struct:server_request	file:	access:public
responses	http.c	/^	const char **responses;$/;"	m	struct:response_class	file:	access:public
result	test/regress_dns.c	/^	int result;$/;"	m	struct:generic_dns_callback_result	file:	access:public
retry_cnt	http-internal.h	/^	int retry_cnt;			\/* retry count *\/$/;"	m	struct:evhttp_connection	access:public
retry_ev	http-internal.h	/^	struct event retry_ev;		\/* for retrying connects *\/$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::event	access:public
retry_max	http-internal.h	/^	int retry_max;			\/* maximum number of retries *\/$/;"	m	struct:evhttp_connection	access:public
roff	test/regress.c	/^static int roff;$/;"	v	file:
rpc	evrpc-internal.h	/^	struct evrpc *rpc;$/;"	m	struct:evrpc_req_generic	typeref:struct:evrpc_req_generic::evrpc	access:public
rpc_basic_client	test/regress_rpc.c	/^rpc_basic_client(void)$/;"	f	file:	signature:(void)
rpc_basic_client_with_pause	test/regress_rpc.c	/^rpc_basic_client_with_pause(void)$/;"	f	file:	signature:(void)
rpc_basic_message	test/regress_rpc.c	/^rpc_basic_message(void)$/;"	f	file:	signature:(void)
rpc_basic_queued_client	test/regress_rpc.c	/^rpc_basic_queued_client(void)$/;"	f	file:	signature:(void)
rpc_basic_test	test/regress_rpc.c	/^rpc_basic_test(void)$/;"	f	file:	signature:(void)
rpc_client_timeout	test/regress_rpc.c	/^rpc_client_timeout(void)$/;"	f	file:	signature:(void)
rpc_data	evrpc-internal.h	/^	struct evbuffer* rpc_data;$/;"	m	struct:evrpc_req_generic	typeref:struct:evrpc_req_generic::evbuffer	access:public
rpc_hook_add_header	test/regress_rpc.c	/^rpc_hook_add_header(void *ctx, struct evhttp_request *req,$/;"	f	file:	signature:(void *ctx, struct evhttp_request *req, struct evbuffer *evbuf, void *arg)
rpc_hook_add_meta	test/regress_rpc.c	/^rpc_hook_add_meta(void *ctx, struct evhttp_request *req,$/;"	f	file:	signature:(void *ctx, struct evhttp_request *req, struct evbuffer *evbuf, void *arg)
rpc_hook_pause	test/regress_rpc.c	/^rpc_hook_pause(void *ctx, struct evhttp_request *req, struct evbuffer *evbuf,$/;"	f	file:	signature:(void *ctx, struct evhttp_request *req, struct evbuffer *evbuf, void *arg)
rpc_hook_pause_cb	test/regress_rpc.c	/^rpc_hook_pause_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
rpc_hook_remove_header	test/regress_rpc.c	/^rpc_hook_remove_header(void *ctx, struct evhttp_request *req,$/;"	f	file:	signature:(void *ctx, struct evhttp_request *req, struct evbuffer *evbuf, void *arg)
rpc_pool_with_connection	test/regress_rpc.c	/^rpc_pool_with_connection(ev_uint16_t port)$/;"	f	file:	signature:(ev_uint16_t port)
rpc_postrequest_done	test/regress_rpc.c	/^rpc_postrequest_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
rpc_postrequest_failure	test/regress_rpc.c	/^rpc_postrequest_failure(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
rpc_setup	test/regress_rpc.c	/^rpc_setup(struct evhttp **phttp, ev_uint16_t *pport, struct evrpc_base **pbase)$/;"	f	file:	signature:(struct evhttp **phttp, ev_uint16_t *pport, struct evrpc_base **pbase)
rpc_teardown	test/regress_rpc.c	/^rpc_teardown(struct evrpc_base *base)$/;"	f	file:	signature:(struct evrpc_base *base)
rpc_test	test/regress_rpc.c	/^rpc_test(void)$/;"	f	file:	signature:(void)
rpc_testcases	test/regress_rpc.c	/^struct testcase_t rpc_testcases[] = {$/;"	v	typeref:struct:testcase_t
rs	arc4random.c	/^static struct arc4_stream rs;$/;"	v	typeref:struct:arc4_stream	file:
rs_initialized	arc4random.c	/^static int rs_initialized;$/;"	v	file:
run	event_rpcgen.py	/^    def run(self):$/;"	m	class:CommandLine	access:public
run_legacy_test_fn	test/regress.h	/^void run_legacy_test_fn(void *ptr);$/;"	p	signature:(void *ptr)
run_legacy_test_fn	test/regress_main.c	/^run_legacy_test_fn(void *ptr)$/;"	f	signature:(void *ptr)
run_once	test/bench.c	/^run_once(void)$/;"	f	file:	signature:(void)
run_once	test/bench_cascade.c	/^run_once(int num_pipes)$/;"	f	file:	signature:(int num_pipes)
run_tests	test/test.sh	/^run_tests () {$/;"	f
running_loop	event-internal.h	/^	int running_loop;$/;"	m	struct:event_base	access:public
s	arc4random.c	/^	unsigned char s[256];$/;"	m	struct:arc4_stream	file:	access:public
s	listener.c	/^	SOCKET s;$/;"	m	struct:accepting_socket	file:	access:public
s6_addr	ipv6-internal.h	/^	ev_uint8_t s6_addr[16];$/;"	m	struct:in6_addr	access:public
sa	evdns.c	/^		struct sockaddr sa;$/;"	m	union:hosts_entry::__anon12	typeref:struct:hosts_entry::__anon12::sockaddr	file:	access:public
sa_family_t	ipv6-internal.h	/^typedef int sa_family_t;$/;"	t
sa_port_ent	test/regress_util.c	/^static struct sa_port_ent {$/;"	s	file:
sa_port_ent::addr	test/regress_util.c	/^	const char *addr;$/;"	m	struct:sa_port_ent	file:	access:public
sa_port_ent::parse	test/regress_util.c	/^	const char *parse;$/;"	m	struct:sa_port_ent	file:	access:public
sa_port_ent::port	test/regress_util.c	/^	int port;$/;"	m	struct:sa_port_ent	file:	access:public
sa_port_ent::safamily	test/regress_util.c	/^	int safamily;$/;"	m	struct:sa_port_ent	file:	access:public
sa_port_ents	test/regress_util.c	/^} sa_port_ents[] = {$/;"	v	typeref:struct:sa_port_ent	file:
sa_pred_ent	test/regress_util.c	/^static struct sa_pred_ent {$/;"	s	file:
sa_pred_ent::is_loopback	test/regress_util.c	/^	int is_loopback;$/;"	m	struct:sa_pred_ent	file:	access:public
sa_pred_ent::parse	test/regress_util.c	/^	const char *parse;$/;"	m	struct:sa_pred_ent	file:	access:public
sa_pred_entries	test/regress_util.c	/^} sa_pred_entries[] = {$/;"	v	typeref:struct:sa_pred_ent	file:
safamily	test/regress_util.c	/^	int safamily;$/;"	m	struct:sa_port_ent	file:	access:public
sbindir	Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
sbindir	include/Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
sbindir	sample/Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
sbindir	test/Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
scheme	http.c	/^	char *scheme; \/* scheme; e.g http, ftp etc *\/$/;"	m	struct:evhttp_uri	file:	access:public
scheme_ok	http.c	/^scheme_ok(const char *s, const char *eos)$/;"	f	file:	signature:(const char *s, const char *eos)
search_cancel_server_cb	test/regress_dns.c	/^search_cancel_server_cb(struct evdns_server_request *req, void *data)$/;"	f	file:	signature:(struct evdns_server_request *req, void *data)
search_domain	evdns.c	/^struct search_domain {$/;"	s	file:
search_domain::len	evdns.c	/^	int len;$/;"	m	struct:search_domain	file:	access:public
search_domain::next	evdns.c	/^	struct search_domain *next;$/;"	m	struct:search_domain	typeref:struct:search_domain::search_domain	file:	access:public
search_flags	evdns.c	/^	int search_flags;$/;"	m	struct:evdns_request	file:	access:public
search_index	evdns.c	/^	int search_index;$/;"	m	struct:evdns_request	file:	access:public
search_make_new	evdns.c	/^search_make_new(const struct search_state *const state, int n, const char *const base_name) {$/;"	f	file:	signature:(const struct search_state *const state, int n, const char *const base_name)
search_origname	evdns.c	/^	char *search_origname;	\/* needs to be free()ed *\/$/;"	m	struct:evdns_request	file:	access:public
search_postfix_add	evdns.c	/^search_postfix_add(struct evdns_base *base, const char *domain) {$/;"	f	file:	signature:(struct evdns_base *base, const char *domain)
search_postfix_clear	evdns.c	/^search_postfix_clear(struct evdns_base *base) {$/;"	f	file:	signature:(struct evdns_base *base)
search_request_finished	evdns.c	/^search_request_finished(struct evdns_request *const handle) {$/;"	f	file:	signature:(struct evdns_request *const handle)
search_request_finished	evdns.c	/^static void search_request_finished(struct evdns_request *const);$/;"	p	file:	signature:(struct evdns_request *const)
search_request_new	evdns.c	/^search_request_new(struct evdns_base *base, struct evdns_request *handle,$/;"	f	file:	signature:(struct evdns_base *base, struct evdns_request *handle, int type, const char *const name, int flags, evdns_callback_type user_callback, void *user_arg)
search_request_new	evdns.c	/^static struct request *search_request_new(struct evdns_base *base, struct evdns_request *handle, int type, const char *const name, int flags, evdns_callback_type user_callback, void *user_arg);$/;"	p	file:	signature:(struct evdns_base *base, struct evdns_request *handle, int type, const char *const name, int flags, evdns_callback_type user_callback, void *user_arg)
search_reverse	evdns.c	/^search_reverse(struct evdns_base *base) {$/;"	f	file:	signature:(struct evdns_base *base)
search_set_from_hostname	evdns.c	/^search_set_from_hostname(struct evdns_base *base) {$/;"	f	file:	signature:(struct evdns_base *base)
search_state	evdns.c	/^	struct search_state *search_state;$/;"	m	struct:evdns_request	typeref:struct:evdns_request::search_state	file:	access:public
search_state	evdns.c	/^struct search_state {$/;"	s	file:
search_state::head	evdns.c	/^	struct search_domain *head;$/;"	m	struct:search_state	typeref:struct:search_state::search_domain	file:	access:public
search_state::ndots	evdns.c	/^	int ndots;$/;"	m	struct:search_state	file:	access:public
search_state::num_domains	evdns.c	/^	int num_domains;$/;"	m	struct:search_state	file:	access:public
search_state::refcount	evdns.c	/^	int refcount;$/;"	m	struct:search_state	file:	access:public
search_state_decref	evdns.c	/^search_state_decref(struct search_state *const state) {$/;"	f	file:	signature:(struct search_state *const state)
search_state_new	evdns.c	/^search_state_new(void) {$/;"	f	file:	signature:(void)
search_table	test/regress_dns.c	/^static struct regress_dns_server_table search_table[] = {$/;"	v	typeref:struct:regress_dns_server_table	file:
search_table	test/regress_http.c	/^static struct regress_dns_server_table search_table[] = {$/;"	v	typeref:struct:regress_dns_server_table	file:
search_try_next	evdns.c	/^search_try_next(struct evdns_request *const handle) {$/;"	f	file:	signature:(struct evdns_request *const handle)
search_try_next	evdns.c	/^static int search_try_next(struct evdns_request *const req);$/;"	p	file:	signature:(struct evdns_request *const req)
seconds_per_tick	test/test-ratelim.c	/^static double seconds_per_tick = 0.0;$/;"	v	file:
seen	test/regress_testutils.h	/^	int seen;$/;"	m	struct:regress_dns_server_table	access:public
select_add	select.c	/^select_add(struct event_base *base, int fd, short old, short events, void *p)$/;"	f	file:	signature:(struct event_base *base, int fd, short old, short events, void *p)
select_add	select.c	/^static int select_add(struct event_base *, int, short old, short events, void*);$/;"	p	file:	signature:(struct event_base *, int, short old, short events, void*)
select_dealloc	select.c	/^select_dealloc(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
select_dealloc	select.c	/^static void select_dealloc(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
select_del	select.c	/^select_del(struct event_base *base, int fd, short old, short events, void *p)$/;"	f	file:	signature:(struct event_base *base, int fd, short old, short events, void *p)
select_del	select.c	/^static int select_del(struct event_base *, int, short old, short events, void*);$/;"	p	file:	signature:(struct event_base *, int, short old, short events, void*)
select_dispatch	select.c	/^select_dispatch(struct event_base *base, struct timeval *tv)$/;"	f	file:	signature:(struct event_base *base, struct timeval *tv)
select_dispatch	select.c	/^static int select_dispatch(struct event_base *, struct timeval *);$/;"	p	file:	signature:(struct event_base *, struct timeval *)
select_free_selectop	select.c	/^select_free_selectop(struct selectop *sop)$/;"	f	file:	signature:(struct selectop *sop)
select_free_selectop	select.c	/^static void select_free_selectop(struct selectop *sop);$/;"	p	file:	signature:(struct selectop *sop)
select_init	select.c	/^select_init(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
select_init	select.c	/^static void *select_init(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
select_resize	select.c	/^select_resize(struct selectop *sop, int fdsz)$/;"	f	file:	signature:(struct selectop *sop, int fdsz)
select_resize	select.c	/^static int select_resize(struct selectop *sop, int fdsz);$/;"	p	file:	signature:(struct selectop *sop, int fdsz)
selectop	select.c	/^struct selectop {$/;"	s	file:
selectop::event_fds	select.c	/^	int event_fds;		\/* Highest fd in fd set *\/$/;"	m	struct:selectop	file:	access:public
selectop::event_fdsz	select.c	/^	int event_fdsz;$/;"	m	struct:selectop	file:	access:public
selectop::event_readset_in	select.c	/^	fd_set *event_readset_in;$/;"	m	struct:selectop	file:	access:public
selectop::event_readset_out	select.c	/^	fd_set *event_readset_out;$/;"	m	struct:selectop	file:	access:public
selectop::event_writeset_in	select.c	/^	fd_set *event_writeset_in;$/;"	m	struct:selectop	file:	access:public
selectop::event_writeset_out	select.c	/^	fd_set *event_writeset_out;$/;"	m	struct:selectop	file:	access:public
selectop::resize_out_sets	select.c	/^	int resize_out_sets;$/;"	m	struct:selectop	file:	access:public
selectops	select.c	/^const struct eventop selectops = {$/;"	v	typeref:struct:eventop
self_draining_callback	test/regress_buffer.c	/^self_draining_callback(struct evbuffer *evbuffer, size_t old_len,$/;"	f	file:	signature:(struct evbuffer *evbuffer, size_t old_len, size_t new_len, void *arg)
send_document_cb	sample/http-server.c	/^send_document_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
sender_errorcb	test/regress_bufferevent.c	/^sender_errorcb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *ctx)
sender_writecb	test/regress_bufferevent.c	/^sender_writecb(struct bufferevent *bev, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, void *ctx)
server_error_phrases	http.c	/^static const char *server_error_phrases[] = {$/;"	v	file:
server_head	evdns.c	/^	struct nameserver *server_head;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::nameserver	file:	access:public
server_port_flush	evdns.c	/^server_port_flush(struct evdns_server_port *port)$/;"	f	file:	signature:(struct evdns_server_port *port)
server_port_free	evdns.c	/^server_port_free(struct evdns_server_port *port)$/;"	f	file:	signature:(struct evdns_server_port *port)
server_port_free	evdns.c	/^static void server_port_free(struct evdns_server_port *port);$/;"	p	file:	signature:(struct evdns_server_port *port)
server_port_read	evdns.c	/^server_port_read(struct evdns_server_port *s) {$/;"	f	file:	signature:(struct evdns_server_port *s)
server_port_ready_callback	evdns.c	/^server_port_ready_callback(evutil_socket_t fd, short events, void *arg) {$/;"	f	file:	signature:(evutil_socket_t fd, short events, void *arg)
server_port_ready_callback	evdns.c	/^static void server_port_ready_callback(evutil_socket_t fd, short events, void *arg);$/;"	p	file:	signature:(evutil_socket_t fd, short events, void *arg)
server_reply_item	evdns.c	/^struct server_reply_item {$/;"	s	file:
server_reply_item::class	evdns.c	/^	u16 class; \/* The RR class (usually CLASS_INET) *\/$/;"	m	struct:server_reply_item	file:	access:public
server_reply_item::data	evdns.c	/^	void *data; \/* The contents of the RR *\/$/;"	m	struct:server_reply_item	file:	access:public
server_reply_item::datalen	evdns.c	/^	u16 datalen; \/* Length of data; -1 if data is a label *\/$/;"	m	struct:server_reply_item	file:	access:public
server_reply_item::is_name	evdns.c	/^	char is_name; \/* True iff data is a label *\/$/;"	m	struct:server_reply_item	file:	access:public
server_reply_item::name	evdns.c	/^	char *name; \/* name part of the RR *\/$/;"	m	struct:server_reply_item	file:	access:public
server_reply_item::next	evdns.c	/^	struct server_reply_item *next; \/* next item in sequence. *\/$/;"	m	struct:server_reply_item	typeref:struct:server_reply_item::server_reply_item	file:	access:public
server_reply_item::ttl	evdns.c	/^	u32 ttl; \/* The RR TTL *\/$/;"	m	struct:server_reply_item	file:	access:public
server_reply_item::type	evdns.c	/^	u16 type; \/* The RR type *\/$/;"	m	struct:server_reply_item	file:	access:public
server_request	evdns.c	/^struct server_request {$/;"	s	file:
server_request::additional	evdns.c	/^	struct server_reply_item *additional; \/* linked list of additional RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:	access:public
server_request::addr	evdns.c	/^	struct sockaddr_storage addr; \/* Where to send the response *\/$/;"	m	struct:server_request	typeref:struct:server_request::sockaddr_storage	file:	access:public
server_request::addrlen	evdns.c	/^	ev_socklen_t addrlen; \/* length of addr *\/$/;"	m	struct:server_request	file:	access:public
server_request::answer	evdns.c	/^	struct server_reply_item *answer; \/* linked list of answer RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:	access:public
server_request::authority	evdns.c	/^	struct server_reply_item *authority; \/* linked list of authority RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:	access:public
server_request::base	evdns.c	/^	struct evdns_server_request base;$/;"	m	struct:server_request	typeref:struct:server_request::evdns_server_request	file:	access:public
server_request::n_additional	evdns.c	/^	int n_additional; \/* how many additional RRs have been set? *\/$/;"	m	struct:server_request	file:	access:public
server_request::n_answer	evdns.c	/^	int n_answer; \/* how many answer RRs have been set? *\/$/;"	m	struct:server_request	file:	access:public
server_request::n_authority	evdns.c	/^	int n_authority; \/* how many authority RRs have been set? *\/$/;"	m	struct:server_request	file:	access:public
server_request::next_pending	evdns.c	/^	struct server_request *next_pending;$/;"	m	struct:server_request	typeref:struct:server_request::server_request	file:	access:public
server_request::port	evdns.c	/^	struct evdns_server_port *port; \/* Which port received this request on? *\/$/;"	m	struct:server_request	typeref:struct:server_request::evdns_server_port	file:	access:public
server_request::prev_pending	evdns.c	/^	struct server_request *prev_pending;$/;"	m	struct:server_request	typeref:struct:server_request::server_request	file:	access:public
server_request::response	evdns.c	/^	char *response;$/;"	m	struct:server_request	file:	access:public
server_request::response_len	evdns.c	/^	size_t response_len;$/;"	m	struct:server_request	file:	access:public
server_request::trans_id	evdns.c	/^	u16 trans_id; \/* Transaction id. *\/$/;"	m	struct:server_request	file:	access:public
server_request_free	evdns.c	/^server_request_free(struct server_request *req)$/;"	f	file:	signature:(struct server_request *req)
server_request_free	evdns.c	/^static int server_request_free(struct server_request *req);$/;"	p	file:	signature:(struct server_request *req)
server_request_free_answers	evdns.c	/^server_request_free_answers(struct server_request *req)$/;"	f	file:	signature:(struct server_request *req)
server_request_free_answers	evdns.c	/^static void server_request_free_answers(struct server_request *req);$/;"	p	file:	signature:(struct server_request *req)
set_handshake_callbacks	bufferevent_openssl.c	/^set_handshake_callbacks(struct bufferevent_openssl *bev_ssl, evutil_socket_t fd)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl, evutil_socket_t fd)
set_open_callbacks	bufferevent_openssl.c	/^set_open_callbacks(struct bufferevent_openssl *bev_ssl, evutil_socket_t fd)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl, evutil_socket_t fd)
set_random_timeout	test/regress_minheap.c	/^set_random_timeout(struct event *ev)$/;"	f	file:	signature:(struct event *ev)
set_rbow	bufferevent_openssl.c	/^set_rbow(struct bufferevent_openssl *bev_ssl)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl)
set_wbor	bufferevent_openssl.c	/^set_wbor(struct bufferevent_openssl *bev_ssl)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl)
setenv	test/regress.c	/^static void setenv(const char *k, const char *v, int _o)$/;"	f	file:	signature:(const char *k, const char *v, int _o)
setup	test/test.sh	/^setup () {$/;"	f
setup	test/tinytest.h	/^	const struct testcase_setup_t *setup; \/**< Optional setup\/cleanup fns*\/$/;"	m	struct:testcase_t	typeref:struct:testcase_t::testcase_setup_t	access:public
setup_data	test/regress.h	/^	void *setup_data;$/;"	m	struct:basic_test_data	access:public
setup_data	test/tinytest.h	/^	void *setup_data; \/**< Extra data usable by setup function *\/$/;"	m	struct:testcase_t	access:public
setup_fn	test/tinytest.h	/^	void *(*setup_fn)(const struct testcase_t *);$/;"	m	struct:testcase_setup_t	access:public
setup_passthrough	test/regress_buffer.c	/^setup_passthrough(const struct testcase_t *testcase)$/;"	f	file:	signature:(const struct testcase_t *testcase)
setup_test	test/regress.c	303;"	d	file:
sh_old	evsignal-internal.h	/^	ev_sighandler_t **sh_old;$/;"	m	struct:evsig_info	access:public
sh_old	evsignal-internal.h	/^	struct sigaction **sh_old;$/;"	m	struct:evsig_info	typeref:struct:evsig_info::sigaction	access:public
sh_old_max	evsignal-internal.h	/^	int sh_old_max;$/;"	m	struct:evsig_info	access:public
sharedstatedir	Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
sharedstatedir	include/Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
sharedstatedir	sample/Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
sharedstatedir	test/Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
shutdown	iocp-internal.h	/^	short shutdown;$/;"	m	struct:event_iocp_port	access:public
shutdown	listener.c	/^	void (*shutdown)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	file:	access:public
shutdownSemaphore	iocp-internal.h	/^	HANDLE *shutdownSemaphore;$/;"	m	struct:event_iocp_port	access:public
shutting_down	listener.c	/^	unsigned shutting_down : 1;$/;"	m	struct:evconnlistener_iocp	file:	access:public
sig	event-internal.h	/^	struct evsig_info sig;$/;"	m	struct:event_base	typeref:struct:event_base::evsig_info	access:public
sigchld_cb	test/regress_thread.c	/^sigchld_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
sigmap	event-internal.h	/^	struct event_signal_map sigmap;$/;"	m	struct:event_base	typeref:struct:event_base::event_signal_map	access:public
signal_add	include/event2/event_compat.h	202;"	d
signal_cb	sample/hello-world.c	/^signal_cb(evutil_socket_t sig, short events, void *user_data)$/;"	f	file:	signature:(evutil_socket_t sig, short events, void *user_data)
signal_cb	sample/hello-world.c	/^static void signal_cb(evutil_socket_t, short, void *);$/;"	p	file:	signature:(evutil_socket_t, short, void *)
signal_cb	sample/signal-test.c	/^signal_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
signal_cb	test/regress.c	/^signal_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
signal_cb	test/regress.c	/^static void signal_cb(evutil_socket_t fd, short event, void *arg);$/;"	p	file:	signature:(evutil_socket_t fd, short event, void *arg)
signal_cb_sa	test/regress.c	/^signal_cb_sa(int sig)$/;"	f	file:	signature:(int sig)
signal_cb_swp	test/regress.c	/^signal_cb_swp(int sig, short event, void *arg)$/;"	f	file:	signature:(int sig, short event, void *arg)
signal_condition	include/event2/thread.h	/^	int (*signal_condition)(void *cond, int broadcast);$/;"	m	struct:evthread_condition_callbacks	access:public
signal_del	include/event2/event_compat.h	205;"	d
signal_initialized	include/event2/event_compat.h	207;"	d
signal_pending	include/event2/event_compat.h	206;"	d
signal_set	include/event2/event_compat.h	203;"	d
signal_test_DEPENDENCIES	sample/Makefile	/^signal_test_DEPENDENCIES = $(am__DEPENDENCIES_1) ..\/libevent.la$/;"	m
signal_test_LDADD	sample/Makefile	/^signal_test_LDADD = $(LDADD)$/;"	m
signal_test_OBJECTS	sample/Makefile	/^signal_test_OBJECTS = $(am_signal_test_OBJECTS)$/;"	m
signal_test_SOURCES	sample/Makefile	/^signal_test_SOURCES = signal-test.c$/;"	m
signal_testcases	test/regress.c	/^struct testcase_t signal_testcases[] = {$/;"	v	typeref:struct:testcase_t
signals_are_broken	win32select.c	/^	unsigned signals_are_broken : 1;$/;"	m	struct:win32op	file:	access:public
simple_read_cb	test/regress.c	/^simple_read_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
simple_write_cb	test/regress.c	/^simple_write_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
simpleclose_close_fd_cb	test/regress.c	/^simpleclose_close_fd_cb(evutil_socket_t s, short what, void *ptr)$/;"	f	file:	signature:(evutil_socket_t s, short what, void *ptr)
simpleread_multiple_cb	test/regress.c	/^simpleread_multiple_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
sin	evdns.c	/^		struct sockaddr_in sin;$/;"	m	union:hosts_entry::__anon12	typeref:struct:hosts_entry::__anon12::sockaddr_in	file:	access:public
sin6	evdns.c	/^		struct sockaddr_in6 sin6;$/;"	m	union:hosts_entry::__anon12	typeref:struct:hosts_entry::__anon12::sockaddr_in6	file:	access:public
sin6_addr	ipv6-internal.h	/^	struct in6_addr sin6_addr;$/;"	m	struct:sockaddr_in6	typeref:struct:sockaddr_in6::in6_addr	access:public
sin6_family	ipv6-internal.h	/^	sa_family_t sin6_family;$/;"	m	struct:sockaddr_in6	access:public
sin6_port	ipv6-internal.h	/^	ev_uint16_t sin6_port;$/;"	m	struct:sockaddr_in6	access:public
sizes	test/regress_iocp.c	/^	ev_ssize_t sizes[MAX_CALLS];$/;"	m	struct:dummy_overlapped	file:	access:public
snprintf	test/tinytest_local.h	10;"	d
snprintf	test/tinytest_local.h	12;"	d
sock_err_fn	test/regress_util.c	/^sock_err_fn(void)$/;"	f	file:	signature:(void)
sockaddr_getport	evdns.c	/^sockaddr_getport(struct sockaddr *sa)$/;"	f	file:	signature:(struct sockaddr *sa)
sockaddr_in6	ipv6-internal.h	/^struct sockaddr_in6 {$/;"	s
sockaddr_in6::sin6_addr	ipv6-internal.h	/^	struct in6_addr sin6_addr;$/;"	m	struct:sockaddr_in6	typeref:struct:sockaddr_in6::in6_addr	access:public
sockaddr_in6::sin6_family	ipv6-internal.h	/^	sa_family_t sin6_family;$/;"	m	struct:sockaddr_in6	access:public
sockaddr_in6::sin6_port	ipv6-internal.h	/^	ev_uint16_t sin6_port;$/;"	m	struct:sockaddr_in6	access:public
sockaddr_setport	evdns.c	/^sockaddr_setport(struct sockaddr *sa, ev_uint16_t port)$/;"	f	file:	signature:(struct sockaddr *sa, ev_uint16_t port)
sockaddr_storage	util-internal.h	/^struct sockaddr_storage {$/;"	s
sockaddr_storage::__anon7::ss_padding	util-internal.h	/^		char ss_padding[128];$/;"	m	union:sockaddr_storage::__anon7	access:public
sockaddr_storage::__anon7::ss_sa	util-internal.h	/^		struct sockaddr ss_sa;$/;"	m	union:sockaddr_storage::__anon7	typeref:struct:sockaddr_storage::__anon7::sockaddr	access:public
sockaddr_storage::__anon7::ss_sin	util-internal.h	/^		struct sockaddr_in ss_sin;$/;"	m	union:sockaddr_storage::__anon7	typeref:struct:sockaddr_storage::__anon7::sockaddr_in	access:public
sockaddr_storage::__anon7::ss_sin6	util-internal.h	/^		struct sockaddr_in6 ss_sin6;$/;"	m	union:sockaddr_storage::__anon7	typeref:struct:sockaddr_storage::__anon7::sockaddr_in6	access:public
sockaddr_storage::ss_union	util-internal.h	/^	} ss_union;$/;"	m	struct:sockaddr_storage	typeref:union:sockaddr_storage::__anon7	access:public
socket	evdns.c	/^	evutil_socket_t socket;	 \/* a connected UDP socket *\/$/;"	m	struct:nameserver	file:	access:public
socket	evdns.c	/^	evutil_socket_t socket; \/* socket we use to read queries and write replies. *\/$/;"	m	struct:evdns_server_port	file:	access:public
sockets	http-internal.h	/^	TAILQ_HEAD(boundq, evhttp_bound_socket) sockets;$/;"	m	struct:evhttp	access:public
socklen_t	util-internal.h	111;"	d
srcdir	Makefile	/^srcdir = .$/;"	m
srcdir	include/Makefile	/^srcdir = .$/;"	m
srcdir	sample/Makefile	/^srcdir = .$/;"	m
srcdir	test/Makefile	/^srcdir = .$/;"	m
ss_family	include/event2/util.h	264;"	d
ss_family	util-internal.h	227;"	d
ss_padding	util-internal.h	/^		char ss_padding[128];$/;"	m	union:sockaddr_storage::__anon7	access:public
ss_sa	util-internal.h	/^		struct sockaddr ss_sa;$/;"	m	union:sockaddr_storage::__anon7	typeref:struct:sockaddr_storage::__anon7::sockaddr	access:public
ss_sin	util-internal.h	/^		struct sockaddr_in ss_sin;$/;"	m	union:sockaddr_storage::__anon7	typeref:struct:sockaddr_storage::__anon7::sockaddr_in	access:public
ss_sin6	util-internal.h	/^		struct sockaddr_in6 ss_sin6;$/;"	m	union:sockaddr_storage::__anon7	typeref:struct:sockaddr_storage::__anon7::sockaddr_in6	access:public
ss_union	util-internal.h	/^	} ss_union;$/;"	m	struct:sockaddr_storage	typeref:union:sockaddr_storage::__anon7	access:public
ssize_t	evutil_rand.c	111;"	d	file:
ssl	bufferevent_openssl.c	/^	SSL *ssl;$/;"	m	struct:bufferevent_openssl	file:	access:public
ssl_ctx	sample/le-proxy.c	/^static SSL_CTX *ssl_ctx = NULL;$/;"	v	file:
ssl_testcases	test/regress_ssl.c	/^struct testcase_t ssl_testcases[] = {$/;"	v	typeref:struct:testcase_t
start_accepting	listener.c	/^start_accepting(struct accepting_socket *as)$/;"	f	file:	signature:(struct accepting_socket *as)
start_cpu_usage_timer	test/test-changelist.c	/^start_cpu_usage_timer(struct cpu_usage_timer *timer)$/;"	f	file:	signature:(struct cpu_usage_timer *timer)
start_reading	bufferevent_openssl.c	/^start_reading(struct bufferevent_openssl *bev_ssl)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl)
start_threads_callback	test/regress_thread.c	/^start_threads_callback(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
start_writing	bufferevent_openssl.c	/^start_writing(struct bufferevent_openssl *bev_ssl)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl)
started	test/bench_httpclient.c	/^	struct timeval started;$/;"	m	struct:request_info	typeref:struct:request_info::timeval	file:	access:public
stat	evutil.c	87;"	d	file:
stat	sample/http-server.c	51;"	d	file:
state	bufferevent_openssl.c	/^	unsigned state : 2;$/;"	m	struct:bufferevent_openssl	file:	access:public
state	evdns.c	/^	char state;  \/* zero if we think that this server is down *\/$/;"	m	struct:nameserver	file:	access:public
state	http-internal.h	/^	enum evhttp_connection_state state;$/;"	m	struct:evhttp_connection	typeref:enum:evhttp_connection::evhttp_connection_state	access:public
status	test/regress_util.c	/^	enum entry_status status;$/;"	m	struct:ipv4_entry	typeref:enum:ipv4_entry::entry_status	file:	access:public
status	test/regress_util.c	/^	enum entry_status status;$/;"	m	struct:ipv6_entry	typeref:enum:ipv6_entry::entry_status	file:	access:public
stop_accepting	listener.c	/^stop_accepting(struct accepting_socket *as)$/;"	f	file:	signature:(struct accepting_socket *as)
stop_reading	bufferevent_openssl.c	/^stop_reading(struct bufferevent_openssl *bev_ssl)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl)
stop_when_connected	test/regress_ssl.c	/^static int stop_when_connected = 0;$/;"	v	file:
stop_writing	bufferevent_openssl.c	/^stop_writing(struct bufferevent_openssl *bev_ssl)$/;"	f	file:	signature:(struct bufferevent_openssl *bev_ssl)
str_matches_option	evdns.c	/^str_matches_option(const char *s1, const char *optionname)$/;"	f	file:	signature:(const char *s1, const char *optionname)
string_num_dots	evdns.c	/^string_num_dots(const char *s) {$/;"	f	file:	signature:(const char *s)
strlcpy	strlcpy-internal.h	13;"	d
strsep	http.c	/^strsep(char **s, const char *del)$/;"	f	file:	signature:(char **s, const char *del)
strtoint	evdns.c	/^static int strtoint(const char *const str);$/;"	p	file:	signature:(const char *const str)
strtoint	evdns.c	/^strtoint(const char *const str)$/;"	f	file:	signature:(const char *const str)
strtoint_clipped	evdns.c	/^strtoint_clipped(const char *const str, int min, int max)$/;"	f	file:	signature:(const char *const str, int min, int max)
strtok_r	evdns.c	/^strtok_r(char *s, const char *delim, char **state) {$/;"	f	file:	signature:(char *s, const char *delim, char **state)
strtotimeval	evdns.c	/^strtotimeval(const char *const str, struct timeval *out)$/;"	f	file:	signature:(const char *const str, struct timeval *out)
structdef	event_rpcgen.py	/^structdef = re.compile(r'^struct +[a-zA-Z_][a-zA-Z0-9_]* *{$')$/;"	v
structref	event_rpcgen.py	/^structref = re.compile(r'^struct\\[([a-zA-Z_][a-zA-Z0-9_]*)\\]$')$/;"	v
subdir	Makefile	/^subdir = .$/;"	m
subdir	include/Makefile	/^subdir = include$/;"	m
subdir	sample/Makefile	/^subdir = sample$/;"	m
subdir	test/Makefile	/^subdir = test$/;"	m
success_phrases	http.c	/^static const char *success_phrases[] = {$/;"	v	file:
supported_locktypes	include/event2/thread.h	/^	unsigned supported_locktypes;$/;"	m	struct:evthread_lock_callbacks	access:public
syntax	sample/http-server.c	/^syntax(void)$/;"	f	file:	signature:(void)
syntax	sample/le-proxy.c	/^syntax(void)$/;"	f	file:	signature:(void)
sys	event_rpcgen.py	/^import sys$/;"	i
sysconfdir	Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
sysconfdir	include/Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
sysconfdir	sample/Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
sysconfdir	test/Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
table_entry	sample/http-server.c	/^static const struct table_entry {$/;"	s	file:
table_entry::content_type	sample/http-server.c	/^	const char *content_type;$/;"	m	struct:table_entry	file:	access:public
table_entry::extension	sample/http-server.c	/^	const char *extension;$/;"	m	struct:table_entry	file:	access:public
tardir	Makefile	/^	tardir=$(distdir) && $(am__tar) | BZIP2=$${BZIP2--9} bzip2 -c >$(distdir).tar.bz2$/;"	m
tardir	Makefile	/^	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz$/;"	m
tardir	Makefile	/^	tardir=$(distdir) && $(am__tar) | XZ_OPT=$${XZ_OPT--e} xz -c >$(distdir).tar.xz$/;"	m
tardir	Makefile	/^	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z$/;"	m
tardir	Makefile	/^	tardir=$(distdir) && $(am__tar) | lzip -c $${LZIP_OPT--9} >$(distdir).tar.lz$/;"	m
target_alias	Makefile	/^target_alias = $/;"	m
target_alias	include/Makefile	/^target_alias = $/;"	m
target_alias	sample/Makefile	/^target_alias = $/;"	m
target_alias	test/Makefile	/^target_alias = $/;"	m
tcalled	test/regress.c	/^static struct timeval tcalled;$/;"	v	typeref:struct:timeval	file:
terminate_chunked_cb	test/regress_http.c	/^terminate_chunked_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
terminate_chunked_client	test/regress_http.c	/^terminate_chunked_client(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
terminate_chunked_close_cb	test/regress_http.c	/^terminate_chunked_close_cb(struct evhttp_connection *evcon, void *arg)$/;"	f	file:	signature:(struct evhttp_connection *evcon, void *arg)
terminate_chunked_trickle_cb	test/regress_http.c	/^terminate_chunked_trickle_cb(evutil_socket_t fd, short events, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short events, void *arg)
terminate_readcb	test/regress_http.c	/^terminate_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
terminate_state	test/regress_http.c	/^struct terminate_state {$/;"	s	file:
terminate_state::base	test/regress_http.c	/^	struct event_base *base;$/;"	m	struct:terminate_state	typeref:struct:terminate_state::event_base	file:	access:public
terminate_state::bev	test/regress_http.c	/^	struct bufferevent *bev;$/;"	m	struct:terminate_state	typeref:struct:terminate_state::bufferevent	file:	access:public
terminate_state::fd	test/regress_http.c	/^	evutil_socket_t fd;$/;"	m	struct:terminate_state	file:	access:public
terminate_state::gotclosecb	test/regress_http.c	/^	int gotclosecb: 1;$/;"	m	struct:terminate_state	file:	access:public
terminate_state::req	test/regress_http.c	/^	struct evhttp_request *req;$/;"	m	struct:terminate_state	typeref:struct:terminate_state::evhttp_request	file:	access:public
test_ai_eq	test/regress.h	108;"	d
test_bad_assign	test/regress.c	/^test_bad_assign(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_bad_reentrant	test/regress.c	/^test_bad_reentrant(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_base_environ	test/regress.c	/^test_base_environ(void *arg)$/;"	f	file:	signature:(void *arg)
test_base_features	test/regress.c	/^test_base_features(void *arg)$/;"	f	file:	signature:(void *arg)
test_bufferevent	test/regress_bufferevent.c	/^test_bufferevent(void)$/;"	f	file:	signature:(void)
test_bufferevent_connect	test/regress_bufferevent.c	/^test_bufferevent_connect(void *arg)$/;"	f	file:	signature:(void *arg)
test_bufferevent_connect_fail	test/regress_bufferevent.c	/^test_bufferevent_connect_fail(void *arg)$/;"	f	file:	signature:(void *arg)
test_bufferevent_connect_hostname	test/regress_dns.c	/^test_bufferevent_connect_hostname(void *arg)$/;"	f	file:	signature:(void *arg)
test_bufferevent_filters	test/regress_bufferevent.c	/^test_bufferevent_filters(void)$/;"	f	file:	signature:(void)
test_bufferevent_filters_impl	test/regress_bufferevent.c	/^test_bufferevent_filters_impl(int use_pair)$/;"	f	file:	signature:(int use_pair)
test_bufferevent_impl	test/regress_bufferevent.c	/^test_bufferevent_impl(int use_pair)$/;"	f	file:	signature:(int use_pair)
test_bufferevent_pair	test/regress_bufferevent.c	/^test_bufferevent_pair(void)$/;"	f	file:	signature:(void)
test_bufferevent_pair_filters	test/regress_bufferevent.c	/^test_bufferevent_pair_filters(void)$/;"	f	file:	signature:(void)
test_bufferevent_pair_watermarks	test/regress_bufferevent.c	/^test_bufferevent_pair_watermarks(void)$/;"	f	file:	signature:(void)
test_bufferevent_timeouts	test/regress_bufferevent.c	/^test_bufferevent_timeouts(void *arg)$/;"	f	file:	signature:(void *arg)
test_bufferevent_watermarks	test/regress_bufferevent.c	/^test_bufferevent_watermarks(void)$/;"	f	file:	signature:(void)
test_bufferevent_watermarks_impl	test/regress_bufferevent.c	/^test_bufferevent_watermarks_impl(int use_pair)$/;"	f	file:	signature:(int use_pair)
test_bufferevent_zlib	test/regress.h	/^void test_bufferevent_zlib(void *);$/;"	p	signature:(void *)
test_bufferevent_zlib	test/regress_zlib.c	/^test_bufferevent_zlib(void *arg)$/;"	f	signature:(void *arg)
test_changelist_DEPENDENCIES	test/Makefile	/^test_changelist_DEPENDENCIES = ..\/libevent_core.la$/;"	m
test_changelist_LDADD	test/Makefile	/^test_changelist_LDADD = ..\/libevent_core.la$/;"	m
test_changelist_OBJECTS	test/Makefile	/^test_changelist_OBJECTS = $(am_test_changelist_OBJECTS)$/;"	m
test_changelist_SOURCES	test/Makefile	/^test_changelist_SOURCES = test-changelist.c$/;"	m
test_combined	test/regress.c	/^test_combined(void)$/;"	f	file:	signature:(void)
test_common_timeout	test/regress.c	/^test_common_timeout(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_dbg_leak_cancel	test/regress_dns.c	/^test_dbg_leak_cancel(void *env_)$/;"	f	file:	signature:(void *env_)
test_dbg_leak_shutdown	test/regress_dns.c	/^test_dbg_leak_shutdown(void *env_)$/;"	f	file:	signature:(void *env_)
test_dup_fd	test/regress.c	/^test_dup_fd(void *arg)$/;"	f	file:	signature:(void *arg)
test_edgetriggered	test/regress_et.c	/^test_edgetriggered(void *et)$/;"	f	file:	signature:(void *et)
test_edgetriggered_mix_error	test/regress_et.c	/^test_edgetriggered_mix_error(void *data_)$/;"	f	file:	signature:(void *data_)
test_eof_DEPENDENCIES	test/Makefile	/^test_eof_DEPENDENCIES = ..\/libevent_core.la$/;"	m
test_eof_LDADD	test/Makefile	/^test_eof_LDADD = ..\/libevent_core.la$/;"	m
test_eof_OBJECTS	test/Makefile	/^test_eof_OBJECTS = $(am_test_eof_OBJECTS)$/;"	m
test_eof_SOURCES	test/Makefile	/^test_eof_SOURCES = test-eof.c$/;"	m
test_evbuffer	test/regress_buffer.c	/^test_evbuffer(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_add_file	test/regress_buffer.c	/^test_evbuffer_add_file(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_add_reference	test/regress_buffer.c	/^test_evbuffer_add_reference(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_callbacks	test/regress_buffer.c	/^test_evbuffer_callbacks(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_expand	test/regress_buffer.c	/^test_evbuffer_expand(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_find	test/regress_buffer.c	/^test_evbuffer_find(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_freeze	test/regress_buffer.c	/^test_evbuffer_freeze(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_iterative	test/regress_buffer.c	/^test_evbuffer_iterative(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_peek	test/regress_buffer.c	/^test_evbuffer_peek(void *info)$/;"	f	file:	signature:(void *info)
test_evbuffer_prepend	test/regress_buffer.c	/^test_evbuffer_prepend(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_ptr_set	test/regress_buffer.c	/^test_evbuffer_ptr_set(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_readln	test/regress_buffer.c	/^test_evbuffer_readln(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_reference	test/regress_buffer.c	/^test_evbuffer_reference(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_remove_buffer_with_empty	test/regress_buffer.c	/^test_evbuffer_remove_buffer_with_empty(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_reserve2	test/regress_buffer.c	/^test_evbuffer_reserve2(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_reserve_many	test/regress_buffer.c	/^test_evbuffer_reserve_many(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_search	test/regress_buffer.c	/^test_evbuffer_search(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evbuffer_search_eol	test/regress_buffer.c	/^test_evbuffer_search_eol(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_event_base_new	test/regress.c	/^test_event_base_new(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_event_once	test/regress.c	/^test_event_once(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_event_pending	test/regress.c	/^test_event_pending(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evutil_casecmp	test/regress_util.c	/^test_evutil_casecmp(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evutil_getaddrinfo	test/regress_util.c	/^test_evutil_getaddrinfo(void *arg)$/;"	f	file:	signature:(void *arg)
test_evutil_integers	test/regress_util.c	/^test_evutil_integers(void *arg)$/;"	f	file:	signature:(void *arg)
test_evutil_loadsyslib	test/regress_util.c	/^test_evutil_loadsyslib(void *arg)$/;"	f	file:	signature:(void *arg)
test_evutil_log	test/regress_util.c	/^test_evutil_log(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evutil_rand	test/regress_util.c	/^test_evutil_rand(void *arg)$/;"	f	file:	signature:(void *arg)
test_evutil_snprintf	test/regress_util.c	/^test_evutil_snprintf(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evutil_sockaddr_predicates	test/regress_util.c	/^test_evutil_sockaddr_predicates(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evutil_strlcpy	test/regress_util.c	/^test_evutil_strlcpy(void *arg)$/;"	f	file:	signature:(void *arg)
test_evutil_strtoll	test/regress_util.c	/^test_evutil_strtoll(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_evutil_upcast	test/regress_util.c	/^test_evutil_upcast(void *arg)$/;"	f	file:	signature:(void *arg)
test_for_getaddrinfo_hacks	evutil.c	/^test_for_getaddrinfo_hacks(void)$/;"	f	file:	signature:(void)
test_fork	test/regress.c	/^test_fork(void)$/;"	f	file:	signature:(void)
test_free_active_base	test/regress.c	/^test_free_active_base(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_getaddrinfo_async	test/regress_dns.c	/^test_getaddrinfo_async(void *arg)$/;"	f	file:	signature:(void *arg)
test_getaddrinfo_async_cancel_stress	test/regress_dns.c	/^test_getaddrinfo_async_cancel_stress(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_heap_randomized	test/regress_minheap.c	/^test_heap_randomized(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_immediatesignal	test/regress.c	/^test_immediatesignal(void)$/;"	f	file:	signature:(void)
test_init_DEPENDENCIES	test/Makefile	/^test_init_DEPENDENCIES = ..\/libevent_core.la$/;"	m
test_init_LDADD	test/Makefile	/^test_init_LDADD = ..\/libevent_core.la$/;"	m
test_init_OBJECTS	test/Makefile	/^test_init_OBJECTS = $(am_test_init_OBJECTS)$/;"	m
test_init_SOURCES	test/Makefile	/^test_init_SOURCES = test-init.c$/;"	m
test_iocp_bufferevent_async	test/regress_iocp.c	/^test_iocp_bufferevent_async(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_iocp_evbuffer	test/regress_iocp.c	/^test_iocp_evbuffer(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_iocp_port	test/regress_iocp.c	/^test_iocp_port(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_is_done	test/regress_ssl.c	/^static int test_is_done = 0;$/;"	v	file:
test_loopbreak	test/regress.c	/^test_loopbreak(void)$/;"	f	file:	signature:(void)
test_loopexit	test/regress.c	/^test_loopexit(void)$/;"	f	file:	signature:(void)
test_loopexit_multiple	test/regress.c	/^test_loopexit_multiple(void)$/;"	f	file:	signature:(void)
test_manipulate_active_events	test/regress.c	/^test_manipulate_active_events(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_many_events	test/regress.c	/^test_many_events(void *arg)$/;"	f	file:	signature:(void *arg)
test_methods	test/regress.c	/^test_methods(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_mm_functions	test/regress.c	/^test_mm_functions(void *arg)$/;"	f	file:	signature:(void *arg)
test_multiple	test/regress.c	/^test_multiple(void)$/;"	f	file:	signature:(void)
test_multiple_cb	test/regress.c	/^test_multiple_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
test_multiple_events_for_same_fd	test/regress.c	/^test_multiple_events_for_same_fd(void)$/;"	f	file:	signature:(void)
test_multiplesignal	test/regress.c	/^test_multiplesignal(void)$/;"	f	file:	signature:(void)
test_nonpersist_readd	test/regress.c	/^test_nonpersist_readd(void)$/;"	f	file:	signature:(void)
test_ok	test/regress.c	/^int test_ok;$/;"	v
test_okay	test/test-eof.c	/^int test_okay = 1;$/;"	v
test_okay	test/test-weof.c	/^int test_okay = 1;$/;"	v
test_persistent	test/regress.c	/^test_persistent(void)$/;"	f	file:	signature:(void)
test_persistent_active_timeout	test/regress.c	/^test_persistent_active_timeout(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_persistent_timeout	test/regress.c	/^test_persistent_timeout(void)$/;"	f	file:	signature:(void)
test_persistent_timeout_jump	test/regress.c	/^test_persistent_timeout_jump(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_pri_event	test/regress.c	/^struct test_pri_event {$/;"	s	file:
test_pri_event::count	test/regress.c	/^	int count;$/;"	m	struct:test_pri_event	file:	access:public
test_pri_event::ev	test/regress.c	/^	struct event ev;$/;"	m	struct:test_pri_event	typeref:struct:test_pri_event::event	file:	access:public
test_priorities	test/regress.c	/^test_priorities(void)$/;"	f	file:	signature:(void)
test_priorities_cb	test/regress.c	/^test_priorities_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
test_priorities_impl	test/regress.c	/^test_priorities_impl(int npriorities)$/;"	f	file:	signature:(int npriorities)
test_priority_active_inversion	test/regress.c	/^test_priority_active_inversion(void *data_)$/;"	f	file:	signature:(void *data_)
test_ratelim_DEPENDENCIES	test/Makefile	/^test_ratelim_DEPENDENCIES = ..\/libevent_core.la$/;"	m
test_ratelim_LDADD	test/Makefile	/^test_ratelim_LDADD = ..\/libevent_core.la -lm$/;"	m
test_ratelim_OBJECTS	test/Makefile	/^test_ratelim_OBJECTS = $(am_test_ratelim_OBJECTS)$/;"	m
test_ratelim_SOURCES	test/Makefile	/^test_ratelim_SOURCES = test-ratelim.c$/;"	m
test_ratelimiting	test/test-ratelim.c	/^test_ratelimiting(void)$/;"	f	file:	signature:(void)
test_signal_assert	test/regress.c	/^test_signal_assert(void)$/;"	f	file:	signature:(void)
test_signal_dealloc	test/regress.c	/^test_signal_dealloc(void)$/;"	f	file:	signature:(void)
test_signal_pipeloss	test/regress.c	/^test_signal_pipeloss(void)$/;"	f	file:	signature:(void)
test_signal_restore	test/regress.c	/^test_signal_restore(void)$/;"	f	file:	signature:(void)
test_signal_switchbase	test/regress.c	/^test_signal_switchbase(void)$/;"	f	file:	signature:(void)
test_signal_while_processing	test/regress.c	/^test_signal_while_processing(void)$/;"	f	file:	signature:(void)
test_simpleclose	test/regress.c	/^test_simpleclose(void *ptr)$/;"	f	file:	signature:(void *ptr)
test_simpleread	test/regress.c	/^test_simpleread(void)$/;"	f	file:	signature:(void)
test_simpleread_multiple	test/regress.c	/^test_simpleread_multiple(void)$/;"	f	file:	signature:(void)
test_simplesignal	test/regress.c	/^test_simplesignal(void)$/;"	f	file:	signature:(void)
test_simpletimeout	test/regress.c	/^test_simpletimeout(void)$/;"	f	file:	signature:(void)
test_simplewrite	test/regress.c	/^test_simplewrite(void)$/;"	f	file:	signature:(void)
test_struct_event_size	test/regress.c	/^test_struct_event_size(void *arg)$/;"	f	file:	signature:(void *arg)
test_time_DEPENDENCIES	test/Makefile	/^test_time_DEPENDENCIES = ..\/libevent_core.la$/;"	m
test_time_LDADD	test/Makefile	/^test_time_LDADD = ..\/libevent_core.la$/;"	m
test_time_OBJECTS	test/Makefile	/^test_time_OBJECTS = $(am_test_time_OBJECTS)$/;"	m
test_time_SOURCES	test/Makefile	/^test_time_SOURCES = test-time.c$/;"	m
test_timeval_diff_eq	test/regress.h	116;"	d
test_timeval_diff_leq	test/regress.h	113;"	d
test_version	test/regress.c	/^test_version(void *arg)$/;"	f	file:	signature:(void *arg)
test_want_only_once	test/regress.c	/^test_want_only_once(void)$/;"	f	file:	signature:(void)
test_weof_DEPENDENCIES	test/Makefile	/^test_weof_DEPENDENCIES = ..\/libevent_core.la$/;"	m
test_weof_LDADD	test/Makefile	/^test_weof_LDADD = ..\/libevent_core.la$/;"	m
test_weof_OBJECTS	test/Makefile	/^test_weof_OBJECTS = $(am_test_weof_OBJECTS)$/;"	m
test_weof_SOURCES	test/Makefile	/^test_weof_SOURCES = test-weof.c$/;"	m
testcase_fn	test/tinytest.h	/^typedef void (*testcase_fn)(void *);$/;"	t
testcase_run_one	test/tinytest.c	/^testcase_run_one(const struct testgroup_t *group,$/;"	f	signature:(const struct testgroup_t *group, const struct testcase_t *testcase)
testcase_run_one	test/tinytest.h	/^int testcase_run_one(const struct testgroup_t *,const struct testcase_t *);$/;"	p	signature:(const struct testgroup_t *,const struct testcase_t *)
testcase_setup_t	test/tinytest.h	/^struct testcase_setup_t {$/;"	s
testcase_setup_t::cleanup_fn	test/tinytest.h	/^	int (*cleanup_fn)(const struct testcase_t *, void *);$/;"	m	struct:testcase_setup_t	access:public
testcase_setup_t::setup_fn	test/tinytest.h	/^	void *(*setup_fn)(const struct testcase_t *);$/;"	m	struct:testcase_setup_t	access:public
testcase_t	test/tinytest.h	/^struct testcase_t {$/;"	s
testcase_t::flags	test/tinytest.h	/^	unsigned long flags; \/**< Bitfield of TT_* flags. *\/$/;"	m	struct:testcase_t	access:public
testcase_t::fn	test/tinytest.h	/^	testcase_fn fn; \/**< The function to run to implement this case. *\/$/;"	m	struct:testcase_t	access:public
testcase_t::name	test/tinytest.h	/^	const char *name; \/**< An identifier for this case. *\/$/;"	m	struct:testcase_t	access:public
testcase_t::setup	test/tinytest.h	/^	const struct testcase_setup_t *setup; \/**< Optional setup\/cleanup fns*\/$/;"	m	struct:testcase_t	typeref:struct:testcase_t::testcase_setup_t	access:public
testcase_t::setup_data	test/tinytest.h	/^	void *setup_data; \/**< Extra data usable by setup function *\/$/;"	m	struct:testcase_t	access:public
tested_for_getaddrinfo_hacks	evutil.c	/^static int tested_for_getaddrinfo_hacks=0;$/;"	v	file:
testgroup_t	test/tinytest.h	/^struct testgroup_t {$/;"	s
testgroup_t::cases	test/tinytest.h	/^	struct testcase_t *cases; \/** Array, ending with END_OF_TESTCASES *\/$/;"	m	struct:testgroup_t	typeref:struct:testgroup_t::testcase_t	access:public
testgroup_t::prefix	test/tinytest.h	/^	const char *prefix; \/**< Prefix to prepend to testnames. *\/$/;"	m	struct:testgroup_t	access:public
testgroups	test/regress_main.c	/^struct testgroup_t testgroups[] = {$/;"	v	typeref:struct:testgroup_t
testleak_cleanup	test/regress_dns.c	/^testleak_cleanup(const struct testcase_t *testcase, void *env_)$/;"	f	file:	signature:(const struct testcase_t *testcase, void *env_)
testleak_env_t	test/regress_dns.c	/^struct testleak_env_t {$/;"	s	file:
testleak_env_t::base	test/regress_dns.c	/^	struct event_base *base;$/;"	m	struct:testleak_env_t	typeref:struct:testleak_env_t::event_base	file:	access:public
testleak_env_t::dns_base	test/regress_dns.c	/^	struct evdns_base *dns_base;$/;"	m	struct:testleak_env_t	typeref:struct:testleak_env_t::evdns_base	file:	access:public
testleak_env_t::r	test/regress_dns.c	/^	struct generic_dns_callback_result r;$/;"	m	struct:testleak_env_t	typeref:struct:testleak_env_t::generic_dns_callback_result	file:	access:public
testleak_env_t::req	test/regress_dns.c	/^	struct evdns_request *req;$/;"	m	struct:testleak_env_t	typeref:struct:testleak_env_t::evdns_request	file:	access:public
testleak_funcs	test/regress_dns.c	/^static struct testcase_setup_t testleak_funcs = {$/;"	v	typeref:struct:testcase_setup_t	file:
testleak_setup	test/regress_dns.c	/^testleak_setup(const struct testcase_t *testcase)$/;"	f	file:	signature:(const struct testcase_t *testcase)
th_base_lock	event-internal.h	/^	void *th_base_lock;$/;"	m	struct:event_base	access:public
th_notify	event-internal.h	/^	struct event th_notify;$/;"	m	struct:event_base	typeref:struct:event_base::event	access:public
th_notify_fd	event-internal.h	/^	evutil_socket_t th_notify_fd[2];$/;"	m	struct:event_base	access:public
th_notify_fn	event-internal.h	/^	int (*th_notify_fn)(struct event_base *base);$/;"	m	struct:event_base	access:public
th_owner_id	event-internal.h	/^	unsigned long th_owner_id;$/;"	m	struct:event_base	access:public
the_extension_fns	event_iocp.c	/^static struct win32_extension_fns the_extension_fns;$/;"	v	typeref:struct:win32_extension_fns	file:
the_ssl_ctx	test/regress_ssl.c	/^static SSL_CTX *the_ssl_ctx = NULL;$/;"	v	file:
thread	test/test-changelist.c	/^	HANDLE thread;$/;"	m	struct:cpu_usage_timer	file:	access:public
thread_basic	test/regress_thread.c	/^thread_basic(void *arg)$/;"	f	file:	signature:(void *arg)
thread_conditions_simple	test/regress_thread.c	/^thread_conditions_simple(void *arg)$/;"	f	file:	signature:(void *arg)
thread_deferred_cb_skew	test/regress_thread.c	/^thread_deferred_cb_skew(void *arg)$/;"	f	file:	signature:(void *arg)
thread_testcases	test/regress_main.c	/^struct testcase_t thread_testcases[] = {$/;"	v	typeref:struct:testcase_t
thread_testcases	test/regress_thread.c	/^struct testcase_t thread_testcases[] = {$/;"	v	typeref:struct:testcase_t
threads	iocp-internal.h	/^	HANDLE *threads;$/;"	m	struct:event_iocp_port	access:public
tick_timeout	ratelim-internal.h	/^	struct timeval tick_timeout;$/;"	m	struct:ev_token_bucket_cfg	typeref:struct:ev_token_bucket_cfg::timeval	access:public
timeBegin	test/test-changelist.c	/^	struct timeval timeBegin;$/;"	m	struct:cpu_usage_timer	typeref:struct:cpu_usage_timer::timeval	file:	access:public
time_cb	test/test-time.c	/^time_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
time_test_DEPENDENCIES	sample/Makefile	/^time_test_DEPENDENCIES = $(am__DEPENDENCIES_1) ..\/libevent.la$/;"	m
time_test_LDADD	sample/Makefile	/^time_test_LDADD = $(LDADD)$/;"	m
time_test_OBJECTS	sample/Makefile	/^time_test_OBJECTS = $(am_time_test_OBJECTS)$/;"	m
time_test_SOURCES	sample/Makefile	/^time_test_SOURCES = time-test.c$/;"	m
timed_out	test/regress_thread.c	/^	int timed_out;$/;"	m	struct:alerted_record	file:	access:public
timedout	evdns.c	/^	int timedout;  \/* number of times in a row a request has timed out *\/$/;"	m	struct:nameserver	file:	access:public
timeheap	event-internal.h	/^	struct min_heap timeheap;$/;"	m	struct:event_base	typeref:struct:event_base::min_heap	access:public
timeout	evdns.c	/^	struct event timeout;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::event	file:	access:public
timeout	evrpc-internal.h	/^	int timeout;$/;"	m	struct:evrpc_pool	access:public
timeout	http-internal.h	/^	int timeout;			\/* timeout in seconds for events *\/$/;"	m	struct:evhttp_connection	access:public
timeout	http-internal.h	/^	int timeout;$/;"	m	struct:evhttp	access:public
timeout	test/test-eof.c	/^struct timeval timeout = {60, 0};$/;"	v	typeref:struct:timeval
timeout_add	include/event2/event_compat.h	188;"	d
timeout_called_once_cb	test/regress.c	/^timeout_called_once_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
timeout_cb	sample/time-test.c	/^timeout_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
timeout_cb	test/regress.c	/^timeout_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
timeout_cb	test/test-changelist.c	/^timeout_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
timeout_cb_result	test/regress_bufferevent.c	/^struct timeout_cb_result {$/;"	s	file:
timeout_cb_result::last_wrote_at	test/regress_bufferevent.c	/^	struct timeval last_wrote_at;$/;"	m	struct:timeout_cb_result	typeref:struct:timeout_cb_result::timeval	file:	access:public
timeout_cb_result::n_read_timeouts	test/regress_bufferevent.c	/^	int n_read_timeouts;$/;"	m	struct:timeout_cb_result	file:	access:public
timeout_cb_result::n_write_timeouts	test/regress_bufferevent.c	/^	int n_write_timeouts;$/;"	m	struct:timeout_cb_result	file:	access:public
timeout_cb_result::read_timeout_at	test/regress_bufferevent.c	/^	struct timeval read_timeout_at;$/;"	m	struct:timeout_cb_result	typeref:struct:timeout_cb_result::timeval	file:	access:public
timeout_cb_result::total_calls	test/regress_bufferevent.c	/^	int total_calls;$/;"	m	struct:timeout_cb_result	file:	access:public
timeout_cb_result::write_timeout_at	test/regress_bufferevent.c	/^	struct timeval write_timeout_at;$/;"	m	struct:timeout_cb_result	typeref:struct:timeout_cb_result::timeval	file:	access:public
timeout_cb_swp	test/regress.c	/^timeout_cb_swp(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
timeout_correct	event.c	/^static void	timeout_correct(struct event_base *, struct timeval *);$/;"	p	file:	signature:(struct event_base *, struct timeval *)
timeout_correct	event.c	/^timeout_correct(struct event_base *base, struct timeval *tv)$/;"	f	file:	signature:(struct event_base *base, struct timeval *tv)
timeout_del	include/event2/event_compat.h	190;"	d
timeout_event	evdns.c	/^	struct event timeout_event;  \/* used to keep the timeout for *\/$/;"	m	struct:nameserver	typeref:struct:nameserver::event	file:	access:public
timeout_event	evdns.c	/^	struct event timeout_event;$/;"	m	struct:request	typeref:struct:request::event	file:	access:public
timeout_event	event-internal.h	/^	struct event timeout_event;$/;"	m	struct:common_timeout_list	typeref:struct:common_timeout_list::event	access:public
timeout_initialized	http.c	87;"	d	file:
timeout_initialized	include/event2/event_compat.h	192;"	d
timeout_next	event.c	/^static int	timeout_next(struct event_base *, struct timeval **);$/;"	p	file:	signature:(struct event_base *, struct timeval **)
timeout_next	event.c	/^timeout_next(struct event_base *base, struct timeval **tv_p)$/;"	f	file:	signature:(struct event_base *base, struct timeval **tv_p)
timeout_pending	http.c	86;"	d	file:
timeout_pending	include/event2/event_compat.h	191;"	d
timeout_process	event.c	/^static void	timeout_process(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
timeout_process	event.c	/^timeout_process(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
timeout_read	include/event2/bufferevent_struct.h	/^	struct timeval timeout_read;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::timeval	access:public
timeout_set	include/event2/event_compat.h	189;"	d
timeout_write	include/event2/bufferevent_struct.h	/^	struct timeval timeout_write;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::timeval	access:public
timer_callback	test/regress_thread.c	/^timer_callback(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
timer_end	test/regress_thread.c	/^static time_t timer_end = 0;$/;"	v	file:
timer_start	test/regress_thread.c	/^static time_t timer_start = 0;$/;"	v	file:
timeval_msec_diff	test/regress.h	/^long timeval_msec_diff(const struct timeval *start, const struct timeval *end);$/;"	p	signature:(const struct timeval *start, const struct timeval *end)
timeval_msec_diff	test/regress_main.c	/^timeval_msec_diff(const struct timeval *start, const struct timeval *end)$/;"	f	signature:(const struct timeval *start, const struct timeval *end)
tinytest_main	test/tinytest.c	/^tinytest_main(int c, const char **v, struct testgroup_t *groups)$/;"	f	signature:(int c, const char **v, struct testgroup_t *groups)
tinytest_main	test/tinytest.h	/^int tinytest_main(int argc, const char **argv, struct testgroup_t *groups);$/;"	p	signature:(int argc, const char **argv, struct testgroup_t *groups)
tinytest_skip	test/tinytest.h	78;"	d
top_build_prefix	Makefile	/^top_build_prefix = $/;"	m
top_build_prefix	include/Makefile	/^top_build_prefix = ..\/$/;"	m
top_build_prefix	sample/Makefile	/^top_build_prefix = ..\/$/;"	m
top_build_prefix	test/Makefile	/^top_build_prefix = ..\/$/;"	m
top_builddir	Makefile	/^top_builddir = .$/;"	m
top_builddir	include/Makefile	/^top_builddir = ..$/;"	m
top_builddir	sample/Makefile	/^top_builddir = ..$/;"	m
top_builddir	test/Makefile	/^top_builddir = ..$/;"	m
top_distdir	Makefile	/^top_distdir = $(distdir)$/;"	m
top_srcdir	Makefile	/^top_srcdir = .$/;"	m
top_srcdir	include/Makefile	/^top_srcdir = ..$/;"	m
top_srcdir	sample/Makefile	/^top_srcdir = ..$/;"	m
top_srcdir	test/Makefile	/^top_srcdir = ..$/;"	m
total_calls	test/regress_bufferevent.c	/^	int total_calls;$/;"	m	struct:timeout_cb_result	file:	access:public
total_connected_or_failed	test/regress_dns.c	/^static int total_connected_or_failed = 0;$/;"	v	file:
total_len	evbuffer-internal.h	/^	size_t total_len;$/;"	m	struct:evbuffer	access:public
total_n_accepted	test/regress_dns.c	/^static int total_n_accepted = 0;$/;"	v	file:
total_n_bytes	test/bench_httpclient.c	/^size_t total_n_bytes = 0;$/;"	v
total_n_errors	test/bench_httpclient.c	/^int total_n_errors = 0;$/;"	v
total_n_handled	test/bench_httpclient.c	/^int total_n_handled = 0;$/;"	v
total_n_launched	test/bench_httpclient.c	/^int total_n_launched = 0;$/;"	v
total_read	bufferevent-internal.h	/^	ev_uint64_t total_read;$/;"	m	struct:bufferevent_rate_limit_group	access:public
total_time	test/bench_httpclient.c	/^struct timeval total_time = {0,0};$/;"	v	typeref:struct:timeval
total_written	bufferevent-internal.h	/^	ev_uint64_t total_written;$/;"	m	struct:bufferevent_rate_limit_group	access:public
trans_id	evdns.c	/^	u16 trans_id;  \/* the transaction id *\/$/;"	m	struct:request	file:	access:public
trans_id	evdns.c	/^	u16 trans_id; \/* Transaction id. *\/$/;"	m	struct:server_request	file:	access:public
transaction_id_pick	evdns.c	/^static u16 transaction_id_pick(struct evdns_base *base);$/;"	p	file:	signature:(struct evdns_base *base)
transaction_id_pick	evdns.c	/^transaction_id_pick(struct evdns_base *base) {$/;"	f	file:	signature:(struct evdns_base *base)
transform	Makefile	/^transform = $(program_transform_name)$/;"	m
transform	include/Makefile	/^transform = $(program_transform_name)$/;"	m
transform	sample/Makefile	/^transform = $(program_transform_name)$/;"	m
transform	test/Makefile	/^transform = $(program_transform_name)$/;"	m
transmit_me	evdns.c	/^	unsigned transmit_me :1;  \/* needs to be transmitted *\/$/;"	m	struct:request	file:	access:public
tset	test/regress.c	/^static struct timeval tset;$/;"	v	typeref:struct:timeval	file:
tt_abort	test/tinytest_macros.h	74;"	d
tt_abort_msg	test/tinytest_macros.h	73;"	d
tt_abort_perror	test/tinytest_macros.h	72;"	d
tt_abort_printf	test/tinytest_macros.h	71;"	d
tt_assert	test/tinytest_macros.h	111;"	d
tt_assert_msg	test/tinytest_macros.h	105;"	d
tt_assert_op_type	test/tinytest_macros.h	149;"	d
tt_assert_test_fmt_type	test/tinytest_macros.h	113;"	d
tt_assert_test_type	test/tinytest_macros.h	143;"	d
tt_fail	test/tinytest_macros.h	80;"	d
tt_fail_msg	test/tinytest_macros.h	79;"	d
tt_fail_perror	test/tinytest_macros.h	78;"	d
tt_fail_printf	test/tinytest_macros.h	77;"	d
tt_int_op	test/tinytest_macros.h	153;"	d
tt_iov_eq	test/regress_buffer.c	1443;"	d	file:
tt_line_eq	test/regress_buffer.c	723;"	d	file:
tt_ptr_op	test/tinytest_macros.h	161;"	d
tt_skip	test/tinytest_macros.h	83;"	d
tt_str_op	test/tinytest_macros.h	165;"	d
tt_uint_op	test/tinytest_macros.h	157;"	d
tt_want	test/tinytest_macros.h	109;"	d
tt_want_int_op	test/tinytest_macros.h	169;"	d
tt_want_msg	test/tinytest_macros.h	101;"	d
tt_want_ptr_op	test/tinytest_macros.h	176;"	d
tt_want_str_op	test/tinytest_macros.h	180;"	d
tt_want_uint_op	test/tinytest_macros.h	172;"	d
ttl	evdns.c	/^	u32 ttl; \/* The RR TTL *\/$/;"	m	struct:server_reply_item	file:	access:public
ttl	evdns.c	/^	u32 ttl;$/;"	m	struct:deferred_reply_callback	file:	access:public
ttl	test/regress_dns.c	/^	int ttl;$/;"	m	struct:generic_dns_callback_result	file:	access:public
tv_cache	event-internal.h	/^	struct timeval tv_cache;$/;"	m	struct:event_base	typeref:struct:event_base::timeval	access:public
tv_clock_diff	event-internal.h	/^	struct timeval tv_clock_diff;$/;"	m	struct:event_base	typeref:struct:event_base::timeval	access:public
tvs	test/regress.c	/^	struct timeval tvs[16];$/;"	m	struct:persist_active_timeout_called	typeref:struct:persist_active_timeout_called::timeval	file:	access:public
tx_count	evdns.c	/^	int tx_count;  \/* the number of times that this packet has been sent *\/$/;"	m	struct:request	file:	access:public
type	bufferevent-internal.h	/^	const char *type;$/;"	m	struct:bufferevent_ops	access:public
type	evdns.c	/^	ev_uint32_t type;$/;"	m	struct:getaddrinfo_subrequest	file:	access:public
type	evdns.c	/^	u16 type; \/* The RR type *\/$/;"	m	struct:server_reply_item	file:	access:public
type	evdns.c	/^	unsigned int type;$/;"	m	struct:reply	file:	access:public
type	include/event2/dns_struct.h	/^	int type;$/;"	m	struct:evdns_server_question	access:public
type	include/event2/http_struct.h	/^	enum evhttp_cmd_type type;$/;"	m	struct:evhttp_request	typeref:enum:evhttp_request::evhttp_cmd_type	access:public
type	test/regress_dns.c	/^	char type;$/;"	m	struct:generic_dns_callback_result	file:	access:public
u16	evdns.c	138;"	d	file:
u32	evdns.c	137;"	d	file:
u32	sample/dns-example.c	37;"	d	file:
u64	evdns.c	136;"	d	file:
u8	evdns.c	139;"	d	file:
u8	sample/dns-example.c	38;"	d	file:
u_char	event.h	/^typedef unsigned char u_char;$/;"	t
u_short	event.h	/^typedef unsigned short u_short;$/;"	t
underlying	bufferevent_filter.c	/^	struct bufferevent *underlying;$/;"	m	struct:bufferevent_filtered	typeref:struct:bufferevent_filtered::bufferevent	file:	access:public
underlying	bufferevent_openssl.c	/^	struct bufferevent *underlying;$/;"	m	struct:bufferevent_openssl	typeref:struct:bufferevent_openssl::bufferevent	file:	access:public
unlock	include/event2/thread.h	/^	int (*unlock)(unsigned mode, void *lock);$/;"	m	struct:evthread_lock_callbacks	access:public
unsetenv	test/regress.c	/^static void unsetenv(const char *k)$/;"	f	file:	signature:(const char *k)
upcast	bufferevent_async.c	/^upcast(struct bufferevent *bev)$/;"	f	file:	signature:(struct bufferevent *bev)
upcast	bufferevent_filter.c	/^upcast(struct bufferevent *bev)$/;"	f	file:	signature:(struct bufferevent *bev)
upcast	bufferevent_openssl.c	/^upcast(struct bufferevent *bev)$/;"	f	file:	signature:(struct bufferevent *bev)
upcast	bufferevent_pair.c	/^upcast(struct bufferevent *bev)$/;"	f	file:	signature:(struct bufferevent *bev)
upcast_connect	bufferevent_async.c	/^upcast_connect(struct event_overlapped *eo)$/;"	f	file:	signature:(struct event_overlapped *eo)
upcast_evbuffer	buffer_iocp.c	/^upcast_evbuffer(struct evbuffer *buf)$/;"	f	file:	signature:(struct evbuffer *buf)
upcast_read	bufferevent_async.c	/^upcast_read(struct event_overlapped *eo)$/;"	f	file:	signature:(struct event_overlapped *eo)
upcast_write	bufferevent_async.c	/^upcast_write(struct event_overlapped *eo)$/;"	f	file:	signature:(struct event_overlapped *eo)
update_time_cache	event.c	/^update_time_cache(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
uri	include/event2/http_struct.h	/^	char *uri;			\/* uri after HTTP request was parsed *\/$/;"	m	struct:evhttp_request	access:public
uri	include/event2/rpc_struct.h	/^	const char* uri;$/;"	m	struct:evrpc	access:public
uri_chars	http.c	/^static const char uri_chars[256] = {$/;"	v	file:
uri_elems	include/event2/http_struct.h	/^	struct evhttp_uri *uri_elems;	\/* uri elements *\/$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evhttp_uri	access:public
uri_part	http.c	/^enum uri_part {$/;"	g	file:
uri_root	sample/http-server.c	/^char uri_root[512];$/;"	v
usage	test/test-ratelim.c	/^usage(void)$/;"	f	file:	signature:(void)
usage	test/tinytest.c	/^static void usage(struct testgroup_t *groups, int list_groups)$/;"	p	file:	signature:(struct testgroup_t *groups, int list_groups)
usage	test/tinytest.c	/^usage(struct testgroup_t *groups, int list_groups)$/;"	f	file:	signature:(struct testgroup_t *groups, int list_groups)
use_mmap	buffer.c	/^static int use_mmap = 1;$/;"	v	file:
use_monotonic	event.c	/^static int use_monotonic;$/;"	v	file:
use_sendfile	buffer.c	/^static int use_sendfile = 1;$/;"	v	file:
use_wrapper	sample/le-proxy.c	/^static int use_wrapper = 1;$/;"	v	file:
usepersist	test/regress.c	/^static int usepersist;$/;"	v	file:
user_callback	evdns.c	/^	evdns_callback_type user_callback;$/;"	m	struct:deferred_reply_callback	file:	access:public
user_callback	evdns.c	/^	evdns_callback_type user_callback;$/;"	m	struct:request	file:	access:public
user_callback	evdns.c	/^	evdns_request_callback_fn_type user_callback; \/* Fn to handle requests *\/$/;"	m	struct:evdns_server_port	file:	access:public
user_canceled	evdns.c	/^	unsigned user_canceled : 1;$/;"	m	struct:evdns_getaddrinfo_request	file:	access:public
user_cb	evdns.c	/^	evdns_getaddrinfo_cb user_cb;$/;"	m	struct:evdns_getaddrinfo_request	file:	access:public
user_data	evdns.c	/^	void *user_data; \/* Opaque pointer passed to user_callback *\/$/;"	m	struct:evdns_server_port	file:	access:public
user_data	evdns.c	/^	void *user_data;$/;"	m	struct:evdns_getaddrinfo_request	file:	access:public
user_data	listener.c	/^	void *user_data;$/;"	m	struct:evconnlistener	file:	access:public
user_pointer	evdns.c	/^	void *user_pointer;  \/* the pointer given to us for this request *\/$/;"	m	struct:request	file:	access:public
userdone	include/event2/http_struct.h	/^	    userdone:1;			\/* the user has sent all data *\/$/;"	m	struct:evhttp_request	access:public
userinfo	http.c	/^	char *userinfo; \/* userinfo (typically username:pass), or NULL *\/$/;"	m	struct:evhttp_uri	file:	access:public
userinfo_ok	http.c	/^userinfo_ok(const char *s, const char *eos)$/;"	f	file:	signature:(const char *s, const char *eos)
usertimeBegin	test/test-changelist.c	/^	FILETIME usertimeBegin;$/;"	m	struct:cpu_usage_timer	file:	access:public
util_testcases	test/regress_util.c	/^struct testcase_t util_testcases[] = {$/;"	v	typeref:struct:testcase_t
v	evdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	m	struct:dnslabel_entry	file:	access:public
va_copy	buffer.c	2693;"	d	file:
validate_header	test/regress_http.c	/^static int validate_header($/;"	f	file:	signature:( const struct evkeyvalq* headers, const char *key, const char *value)
value	include/event2/keyvalq_struct.h	/^	char *value;$/;"	m	struct:evkeyval	access:public
vbase	test/regress_rpc.c	/^	void *vbase;$/;"	m	struct:_rpc_hook_ctx	file:	access:public
verbose	sample/dns-example.c	/^static int verbose = 0;$/;"	v	file:
verbosity_flag	test/tinytest.c	/^const char *verbosity_flag = "";$/;"	v
vhost_pattern	http-internal.h	/^	char *vhost_pattern;$/;"	m	struct:evhttp	access:public
virtual_event_count	event-internal.h	/^	int virtual_event_count;$/;"	m	struct:event_base	access:public
virtualhosts	http-internal.h	/^	TAILQ_HEAD(vhostsq, evhttp) virtualhosts;$/;"	m	struct:evhttp	access:public
wait_condition	include/event2/thread.h	/^	int (*wait_condition)(void *cond, void *lock,$/;"	m	struct:evthread_condition_callbacks	access:public
wait_for_condition	test/regress_thread.c	/^wait_for_condition(void *arg)$/;"	f	file:	signature:(void *arg)
wake_all_timeout	test/regress_thread.c	/^wake_all_timeout(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
wake_one_timeout	test/regress_thread.c	/^wake_one_timeout(evutil_socket_t fd, short what, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short what, void *arg)
want_fail_eventcb	test/regress_bufferevent.c	/^want_fail_eventcb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *ctx)
was_et	test/regress_et.c	/^static int was_et = 0;$/;"	v	file:
wbuf	test/regress.c	/^static char wbuf[4096];$/;"	v	file:
wbuf	test/regress_iocp.c	/^static struct evbuffer *rbuf = NULL, *wbuf = NULL;$/;"	v	typeref:struct:	file:
what	http-internal.h	/^	char *what;$/;"	m	struct:evhttp_cb	access:public
what	test/regress_dns.c	/^	int what;$/;"	m	struct:be_conn_hostname_result	file:	access:public
which	test/regress.c	/^	int which;$/;"	m	struct:common_timeout_info	file:	access:public
white	event_rpcgen.py	/^white = re.compile(r'\\s+')$/;"	v
win32_add	win32select.c	/^static int win32_add(struct event_base *, evutil_socket_t, short old, short events, void *_idx);$/;"	p	file:	signature:(struct event_base *, evutil_socket_t, short old, short events, void *_idx)
win32_add	win32select.c	/^win32_add(struct event_base *base, evutil_socket_t fd,$/;"	f	signature:(struct event_base *base, evutil_socket_t fd, short old, short events, void *_idx)
win32_dealloc	win32select.c	/^static void win32_dealloc(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
win32_dealloc	win32select.c	/^win32_dealloc(struct event_base *_base)$/;"	f	signature:(struct event_base *_base)
win32_del	win32select.c	/^static int win32_del(struct event_base *, evutil_socket_t, short old, short events, void *_idx);$/;"	p	file:	signature:(struct event_base *, evutil_socket_t, short old, short events, void *_idx)
win32_del	win32select.c	/^win32_del(struct event_base *base, evutil_socket_t fd, short old, short events,$/;"	f	signature:(struct event_base *base, evutil_socket_t fd, short old, short events, void *_idx)
win32_dispatch	win32select.c	/^static int win32_dispatch(struct event_base *base, struct timeval *);$/;"	p	file:	signature:(struct event_base *base, struct timeval *)
win32_dispatch	win32select.c	/^win32_dispatch(struct event_base *base, struct timeval *tv)$/;"	f	signature:(struct event_base *base, struct timeval *tv)
win32_extension_fns	iocp-internal.h	/^struct win32_extension_fns {$/;"	s
win32_extension_fns::AcceptEx	iocp-internal.h	/^	AcceptExPtr AcceptEx;$/;"	m	struct:win32_extension_fns	access:public
win32_extension_fns::ConnectEx	iocp-internal.h	/^	ConnectExPtr ConnectEx;$/;"	m	struct:win32_extension_fns	access:public
win32_extension_fns::GetAcceptExSockaddrs	iocp-internal.h	/^	GetAcceptExSockaddrsPtr GetAcceptExSockaddrs;$/;"	m	struct:win32_extension_fns	access:public
win32_init	win32select.c	/^static void *win32_init(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
win32_init	win32select.c	/^win32_init(struct event_base *_base)$/;"	f	signature:(struct event_base *_base)
win32op	win32select.c	/^struct win32op {$/;"	s	file:
win32op::exset_out	win32select.c	/^	struct win_fd_set *exset_out;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
win32op::num_fds_in_fd_sets	win32select.c	/^	unsigned num_fds_in_fd_sets;$/;"	m	struct:win32op	file:	access:public
win32op::readset_in	win32select.c	/^	struct win_fd_set *readset_in;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
win32op::readset_out	win32select.c	/^	struct win_fd_set *readset_out;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
win32op::resize_out_sets	win32select.c	/^	int resize_out_sets;$/;"	m	struct:win32op	file:	access:public
win32op::signals_are_broken	win32select.c	/^	unsigned signals_are_broken : 1;$/;"	m	struct:win32op	file:	access:public
win32op::writeset_in	win32select.c	/^	struct win_fd_set *writeset_in;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
win32op::writeset_out	win32select.c	/^	struct win_fd_set *writeset_out;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
win32ops	win32select.c	/^struct eventop win32ops = {$/;"	v	typeref:struct:eventop
win_fd_set	win32select.c	/^struct win_fd_set {$/;"	s	file:
win_fd_set::fd_array	win32select.c	/^	SOCKET fd_array[1];$/;"	m	struct:win_fd_set	file:	access:public
win_fd_set::fd_count	win32select.c	/^	u_int fd_count;$/;"	m	struct:win_fd_set	file:	access:public
windows_socket_errors	evutil.c	/^static struct { int code; const char *msg; } windows_socket_errors[] = {$/;"	v	typeref:struct:__anon14	file:
wm_errorcb	test/regress_bufferevent.c	/^wm_errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *arg)
wm_read	include/event2/bufferevent_struct.h	/^	struct event_watermark wm_read;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_watermark	access:public
wm_readcb	test/regress_bufferevent.c	/^wm_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
wm_write	include/event2/bufferevent_struct.h	/^	struct event_watermark wm_write;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_watermark	access:public
wm_writecb	test/regress_bufferevent.c	/^wm_writecb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
woff	test/regress.c	/^static int woff;$/;"	v	file:
write	test/regress.c	97;"	d	file:
write_added	bufferevent_async.c	/^	unsigned write_added : 1;$/;"	m	struct:bufferevent_async	file:	access:public
write_blocked_on_read	bufferevent_openssl.c	/^	unsigned write_blocked_on_read : 1;$/;"	m	struct:bufferevent_openssl	file:	access:public
write_cb	test/test-changelist.c	/^write_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
write_cb	test/test-weof.c	/^write_cb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:	signature:(evutil_socket_t fd, short event, void *arg)
write_change	changelist-internal.h	/^	ev_uint8_t write_change;$/;"	m	struct:event_change	access:public
write_complete	bufferevent_async.c	/^write_complete(struct event_overlapped *eo, ev_uintptr_t key,$/;"	f	file:	signature:(struct event_overlapped *eo, ev_uintptr_t key, ev_ssize_t nbytes, int ok)
write_complete	test/regress_iocp.c	/^write_complete(struct event_overlapped *eo, uintptr_t key,$/;"	f	file:	signature:(struct event_overlapped *eo, uintptr_t key, ev_ssize_t nbytes, int ok)
write_in_progress	buffer_iocp.c	/^	unsigned write_in_progress : 1;$/;"	m	struct:evbuffer_overlapped	file:	access:public
write_in_progress	bufferevent_async.c	/^	size_t write_in_progress;$/;"	m	struct:bufferevent_async	file:	access:public
write_limit	ratelim-internal.h	/^	ev_ssize_t read_limit, write_limit;$/;"	m	struct:ev_token_bucket	access:public
write_maximum	ratelim-internal.h	/^	size_t write_maximum;$/;"	m	struct:ev_token_bucket_cfg	access:public
write_on_connectedcb	test/test-ratelim.c	/^write_on_connectedcb(struct bufferevent *bev, short what, void *ctx)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *ctx)
write_overlapped	bufferevent_async.c	/^	struct event_overlapped write_overlapped;$/;"	m	struct:bufferevent_async	typeref:struct:bufferevent_async::event_overlapped	file:	access:public
write_pos_plus1	win32select.c	/^	int write_pos_plus1;$/;"	m	struct:idx_info	file:	access:public
write_rate	ratelim-internal.h	/^	size_t write_rate;$/;"	m	struct:ev_token_bucket_cfg	access:public
write_suspended	bufferevent-internal.h	/^	bufferevent_suspend_flags write_suspended;$/;"	m	struct:bufferevent_private	access:public
write_suspended	bufferevent-internal.h	/^	unsigned write_suspended : 1;$/;"	m	struct:bufferevent_rate_limit_group	access:public
write_timeout_at	test/regress_bufferevent.c	/^	struct timeval write_timeout_at;$/;"	m	struct:timeout_cb_result	typeref:struct:timeout_cb_result::timeval	file:	access:public
write_waiting	evdns.c	/^	char write_waiting;  \/* true if we are waiting for EV_WRITE events *\/$/;"	m	struct:nameserver	file:	access:public
writecb	include/event2/bufferevent_struct.h	/^	bufferevent_data_cb writecb;$/;"	m	struct:bufferevent	access:public
writecb	test/regress_bufferevent.c	/^writecb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
writecb	test/regress_zlib.c	/^writecb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
writecb_finished	test/regress_zlib.c	/^static int writecb_finished;$/;"	v	file:
writecb_pending	bufferevent-internal.h	/^	unsigned writecb_pending : 1;$/;"	m	struct:bufferevent_private	access:public
writes	test/bench.c	/^static int count, writes, fired;$/;"	v	file:
writeset_in	win32select.c	/^	struct win_fd_set *writeset_in;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
writeset_out	win32select.c	/^	struct win_fd_set *writeset_out;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
zlib_deflate_free	test/regress_zlib.c	/^zlib_deflate_free(void *ctx)$/;"	f	file:	signature:(void *ctx)
zlib_inflate_free	test/regress_zlib.c	/^zlib_inflate_free(void *ctx)$/;"	f	file:	signature:(void *ctx)
zlib_input_filter	test/regress_zlib.c	/^zlib_input_filter(struct evbuffer *src, struct evbuffer *dst,$/;"	f	file:	signature:(struct evbuffer *src, struct evbuffer *dst, ev_ssize_t lim, enum bufferevent_flush_mode state, void *ctx)
zlib_output_filter	test/regress_zlib.c	/^zlib_output_filter(struct evbuffer *src, struct evbuffer *dst,$/;"	f	file:	signature:(struct evbuffer *src, struct evbuffer *dst, ev_ssize_t lim, enum bufferevent_flush_mode state, void *ctx)
